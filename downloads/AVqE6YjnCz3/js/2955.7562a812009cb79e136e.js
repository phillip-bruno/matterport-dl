"use strict";(self.webpackChunkmp_webgl=self.webpackChunkmp_webgl||[]).push([[2955],{9933:A=>{A.exports="data:application/wasm;base64,AGFzbQEAAAAB9wEkYAJ/fwF/YAN/f38Bf2ACf38AYAN/f38AYAF/AGABfwF/YAV/f39/fwBgA29/fwFvYAV/f39/fwF/YAR/f39/AGABbwFvYANvb38AYAFvAX9gAAF/YAAAYAd/f39/f39/AX9gAX0BfWAGf39/f39/AGAEf39/fwF/YAF/AW9gAAFvYAd/f39/f39/AGACf34Bf2ADf35+AGACf34AYAt9fX19fX19fX9vfwFvYAZ/f39/f38Bf2AFf398f38AYAR/fH9/AGAFf399f38AYAR/fX9/AGAFf39+f38AYAR/fn9/AGADf35+AX9gA39vbwF/YAJ9fQF9AvIEEQN3YmcdX193YmdfYnVmZmVyXzYwOWNjM2VlZTUxZWQxNTgACgN3YmcaX193YmdfbmV3XzlmZWU5N2E0MDliMzJiNjgACgN3YmcaX193Ymdfc2V0X2Y0ZjFmMGRhYTMwNjk2ZmMACwN3YmcdX193YmdfbGVuZ3RoXzhjZmQyYzY0MDlhZjg4YWQADAN3YmcxX193YmdfbmV3d2l0aGJ5dGVvZmZzZXRhbmRsZW5ndGhfZjFkZWFkNDRkMWZjNzIxMgAHA3diZxpfX3diZ19uZXdfZTNiMzIxZGNmZWY4OWZjNwAKA3diZxpfX3diZ19zZXRfZDIzNjYxZDE5MTQ4YjIyOQALA3diZx1fX3diZ19sZW5ndGhfNmNhNTI3NjY1ZDg5Njk0ZAAMA3diZzFfX3diZ19uZXd3aXRoYnl0ZW9mZnNldGFuZGxlbmd0aF9lNmI3ZTY5YWNkNGM3MzU0AAcDd2JnGl9fd2JnX3NldF8xMGJhZDliZWUwZTljNThiAAsDd2JnHV9fd2JnX2xlbmd0aF8zYjRmMDIyMTg4YWU4ZGI2AAwDd2JnH19fd2JnX3N1YmFycmF5Xzc2OWUxZTBmODFiYjI1OWIABwN3YmcfX193Ymdfc3ViYXJyYXlfM2FhZWVjODliYjI1NDRmMAAHA3diZyRfX3diZ19uZXd3aXRobGVuZ3RoXzVhNWVmZTMxM2NmZDU5ZjEAEwN3YmcQX193YmluZGdlbl90aHJvdwACA3diZxFfX3diaW5kZ2VuX21lbW9yeQAUA3diZx9fX3diaW5kZ2VuX2luaXRfZXh0ZXJucmVmX3RhYmxlAA4DwAG+AQUAAAYPAAUF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BSADOgAcIAUgAjYCGCAFIAUpAwA3AhBBlM/AACgCACAFQRBqQZjPwAAoAgAoAhQRAgBBkM/AACgCAEEBawUgBgs2AgBB6NLAAEEAOgAAIANFDQAACwALsgEBBn8CQAJAIABBhAFJDQAgANBvJgEQRSIBKAIMIQUgASgCECECIAFCADcCDCABKAIIIQMgASgCBCEEIAFCBDcCBCABKAIAIQYgAUEANgIAIAAgAkkNASAAIAJrIgAgA08NASAEIABBAnRqIAU2AgAgASACNgIQIAEgADYCDCABIAM2AgggASgCBCABIAQ2AgQgASgCACEAIAEgBjYCACAARQ0AIABBAnRBBBCwAQsPCwALqQEBAX8jAEEQayIGJAACQCABBEAgBkEEaiABIAMgBCAFIAIoAhARBgACQCAGKAIEIgIgBigCDCIBTQRAIAYoAgghBQwBCyACQQJ0IQIgBigCCCEDIAFFBEBBBCEFIAMgAkEEELABDAELIAMgAkEEIAFBAnQiAhCXASIFRQ0CCyAAIAE2AgQgACAFNgIAIAZBEGokAA8LQZiPwABBMhC5AQALQQQgAhCUAQALowEBAn8jAEEgayIDJAACQCABRQRAQQFBACACEMYBIQAMAQsgAyABNgIMIAMgADYCCCADQRBqIANBCGoQLSADKAIQIgEEQANAIAMoAhQhBCADKAIcRQRAIAEgBCACEMYBIQAMAwtBASEAIAIgASAEEJkBDQIgAkH9/wMQnAENAiADQRBqIANBCGoQLSADKAIQIgENAAsLQQAhAAsgA0EgaiQAIAALiwEBAX8CQCACQQBOBEACfyADKAIEBEACQCADKAIIIgRFBEAMAQsgAygCACAEIAEgAhCXAQwCCwsgASACRQ0AGkH9zsAALQAAGiACIAEQpgELIgMEQCAAIAI2AgggACADNgIEIABBADYCAA8LIAAgAjYCCCAAIAE2AgQMAQsgAEEANgIECyAAQQE2AgALqwEBAn8jAEEgayIBJAACQCAAKAIEIgJBA0YgAkECSXINAAJAAkAgAC0AGEEBaw4CAgABCyABQQE2AgggAUGshcAANgIEIAFCADcCECABIAFBHGo2AgwgAUEEakGQhsAAEIQBAAsgAEEIahBOIAAoAggiAkUNACAAKAIMIAJBDGxBBBCwAQsgACgCHCICBEAgACgCICACQQEQsAELIABBKEEEELABIAFBIGokAAuaAQECfyMAQSBrIgEkAAJAIAAoAgRBAkcNAAJAAkAgAC0AGEEBaw4CAgABCyABQQE2AgggAUGshcAANgIEIAFCADcCECABIAFBHGo2AgwgAUEEakGQhsAAEIQBAAsgAEEIahBOIAAoAggiAkUNACAAKAIMIAJBDGxBBBCwAQsgACgCHCICBEAgACgCICACQQEQsAELIAFBIGokAAuSAQEEfyMAQRBrIgIkAEEBIQQCQCABKAIUIgNBJyABKAIYIgUoAhAiAREAAA0AIAJBBGogACgCAEGBAhAiAkAgAi0ABEGAAUYEQCADIAIoAgggAREAAEUNAQwCCyADIAItAA4iACACQQRqaiACLQAPIABrIAUoAgwRAQANAQsgA0EnIAERAAAhBAsgAkEQaiQAIAQLlQEBAn8jAEEgayIDJAACQCAAKAIEIgRBA0YgBEECSXINAAJAAkAgAC0AGEEBaw4CAgABCyADQQE2AgggA0GshcAANgIEIANCADcCECADIANBHGo2AgwgA0EEakGQhsAAEIQBAAsgAEEIahBOIAAoAggiBEUNACAAKAIMIARBDGxBBBCwAQsgAEEoQQQQsAEgA0EgaiQAC4QBAQN/An8CQCAAKAIAIgFFDQADQAJAIAAoAggiAyAAKAIETw0AIAEgA2otAABBxQBHDQAgACADQQFqNgIIDAILAkAgAkUNACAAKAIQIgFFDQBB+aTAAEECIAEQxgFFDQBBAQ8LQQEgAEEBEBMNAhogAkEBayECIAAoAgAiAQ0ACwtBAAsLegEBfyMAQSBrIgIkAAJ/IAAoAgBBgICAgHhHBEAgASAAKAIEIAAoAggQmQEMAQsgAkEQaiAAKAIMKAIAIgBBCGopAgA3AwAgAkEYaiAAQRBqKQIANwMAIAIgACkCADcDCCABKAIUIAEoAhggAkEIahApCyACQSBqJAALSQEDfiAAIAFC/////w+DIgJCPn4iA0IAIgIgAUIgiEI+fnwiAUIghnwiBDcDACAAIAMgBFatIAEgAlStQiCGIAFCIIiEfDcDCAt8AQF/IwBBQGoiBSQAIAUgATYCDCAFIAA2AgggBSADNgIUIAUgAjYCECAFQQI2AhwgBUG8rsAANgIYIAVCAjcCJCAFIAVBEGqtQoCAgICADIQ3AzggBSAFQQhqrUKAgICAkAyENwMwIAUgBUEwajYCICAFQRhqIAQQhAEAC3gBA38CQCAAKAIAIgFBgICAgHhHBEAgAUUNASAAKAIEIAFBARCwAQ8LIAAtAARBA0cNACAAKAIIIgAoAgAhASAAQQRqKAIAIgMoAgAiAgRAIAEgAhEEAAsgAygCBCICBEAgASACIAMoAggQsAELIABBDEEEELABCwvzAwIIfwF+IwBBEGsiAyQAIAAoAgQhBSAAKAIAIQAgASgCFEG4rMAAQQEgASgCGCgCDBEBACEEIANBBGoiAkEAOgAFIAIgBDoABCACIAE2AgAgBQRAA0AgAyAANgIMIANBDGohCCMAQUBqIgEkAEEBIQYCQCADQQRqIgQtAAQNACAELQAFIQkCQCAEKAIAIgIoAhwiB0EEcUUEQCAJQQFxRQ0BIAIoAhRB667AAEECIAIoAhgoAgwRAQBFDQEMAgsgCUEBcUUEQCACKAIUQfWuwABBASACKAIYKAIMEQEADQIgAigCHCEHCyABQQE6ABsgASACKQIUNwIMIAFBzK7AADYCNCABIAFBG2o2AhQgASACKQIINwIkIAIpAgAhCiABIAc2AjggASACKAIQNgIsIAEgAi0AIDoAPCABIAo3AhwgASABQQxqNgIwIAggAUEcakGAmcAAKAIAEQAADQEgASgCMEHwrsAAQQIgASgCNCgCDBEBACEGDAELIAggAkGAmcAAKAIAEQAAIQYLIARBAToABSAEIAY6AAQgAUFAayQAIABBAWohACAFQQFrIgUNAAsLQQEhACADQQRqIgEtAARFBEAgASgCACIAKAIUQfauwABBASAAKAIYKAIMEQEAIQALIAEgADoABCADQRBqJAAgAAtqAgF/AX4jAEEwayIDJAAgAyAANgIAIAMgATYCBCADQQI2AgwgA0HYscAANgIIIANCAjcCFCADQoCAgIDwAiIEIANBBGqthDcDKCADIAQgA62ENwMgIAMgA0EgajYCECADQQhqIAIQhAEAC2oCAX8BfiMAQTBrIgMkACADIAE2AgQgAyAANgIAIANBAjYCDCADQZitwAA2AgggA0ICNwIUIANCgICAgPACIgQgA62ENwMoIAMgBCADQQRqrYQ3AyAgAyADQSBqNgIQIANBCGogAhCEAQALagIBfwF+IwBBMGsiAyQAIAMgADYCACADIAE2AgQgA0ECNgIMIANB+LHAADYCCCADQgI3AhQgA0KAgICA8AIiBCADQQRqrYQ3AyggAyAEIAOthDcDICADIANBIGo2AhAgA0EIaiACEIQBAAtqAgF/AX4jAEEwayIDJAAgAyAANgIAIAMgATYCBCADQQI2AgwgA0GsssAANgIIIANCAjcCFCADQoCAgIDwAiIEIANBBGqthDcDKCADIAQgA62ENwMgIAMgA0EgajYCECADQQhqIAIQhAEAC2MBAX8jAEEQayIAJAACfyACKAIABEBBwJXAACEDQQkMAQsgAEEEaiACKAIEIAIoAggQJEHAlcAAIAAoAgggACgCBCICGyEDQQkgACgCDCACGwshAiADIAIgARBcIABBEGokAAtnACMAQTBrIgAkAEH8zsAALQAABEAgAEECNgIMIABB8JXAADYCCCAAQgE3AhQgACABNgIsIAAgAEEsaq1CgICAgPAChDcDICAAIABBIGo2AhAgAEEIakGQlsAAEIQBAAsgAEEwaiQAC+caAhJ/AX4jAEEgayIPJAACfyAAKAIAIgAoAgAEQAJ/IAEhDCMAQTBrIgYkACAAKAIIIREgACgCBCEIIAAoAgAhDgJAAkACQAJAAkADQAJAIBEgECIJRgRAQQAhAgwBCyAIRQ0GIAkgEUchEiAJQQFqIRAgCEEBayEHIA4iBC0AACEBQQAhAAJAAkACQAJAA0ACQCABwEEASARAIAFBH3EhAiAAIARqIgVBAWotAABBP3EhAyABQf8BcSIOQd8BTQRAIAJBBnQgA3IhAQwCCyAFQQJqLQAAQT9xIANBBnRyIQEgDkHwAUkEQCABIAJBDHRyIQEMAgsgAkESdEGAgPAAcSAFQQNqLQAAQT9xIAFBBnRyciIBQYCAxABHDQEMDQsgAUH/AXEhAQsCQAJAIAFBMGtBCU0EQCAAIAdGDQ4gACAEaiICQQFqLAAAIgFBv39KDQEgAiAIIABrIgBBASAAQcCdwAAQnQEACyAABEAgACAEaiwAAEG/f0wNAgsgBkEUaiEHIAQhAkEAIQMCQAJAAkACQAJAAkACQCAAIgEOAgQAAQtBASEDIAItAABBK2sOAwMBAwELIAItAABBK0YEQCACQQFqIQIgAUEKSSABQQFrIgMhAQ0BDAILIAEhAyABQQhLDQELQQAhBQNAIAItAABBMGsiAUEJSwRAQQEhAwwDCyACQQFqIQIgASAFQQpsaiEFIANBAWsiAw0ACwwCC0EAIQUDQCABRQ0CIAItAABBMGsiDkEJSwRAQQEhAwwCC0ECIQMgBa1CCn4iFEIgiKcNASACQQFqIQIgAUEBayEBIA4gFKciCmoiBSAKTw0ACwsgByADOgABIAdBAToAAAwBCyAHIAU2AgQgB0EAOgAACyAGLQAUDQMgCCAGKAIYIgVrIQoCQCAFRQ0AIAggAGsiASAFSwRAIAQgBWogAGoiAiwAAEG/f0wNBiACLAAAQb9/Sg0BIAAgBGogAUEAIAVB8J3AABCdAQALIAAgCkcNBQsgACAEaiIBIQcgBCAFaiAAaiEOIAVFIBAgEUdyDQYgDCgCHEEEcUUNBiAHLQAAQegARw0GIAVBAUcEQCABQQFqLAAAQb9/TA0GCyAAIARqQQFqIQEDQEEAIQIgASAORg0IAn8gASwAACIDQQBOBEAgA0H/AXEhCCABQQFqDAELIAEtAAFBP3EhDSADQR9xIQggA0FfTQRAIAhBBnQgDXIhCCABQQJqDAELIAEtAAJBP3EgDUEGdHIhDSADQXBJBEAgDSAIQQx0ciEIIAFBA2oMAQsgCEESdEGAgPAAcSABLQADQT9xIA1BBnRyciIIQYCAxABGDQkgAUEEagshASAIQTBrQQpJIAhBIHJB4QBrQQZJcg0ACwwGCyAAQQFqIQAMAQsLIAQgCEEAIABB0J3AABCdAQALIAYgBi0AFToACEGEm8AAQSsgBkEIakG0n8AAQcSfwAAQZQALIAAgBGogASAFIAFB4J3AABCdAQALIAEgBUEBIAVBoJ3AABCdAQALAkAgCUUNACAMQYCewABBAhCZAUUNACASIQIMAQsCQCAFQQJJDQAgBy8AAEHfyABHDQAgACAEaiIBQQFqIgcsAABBv39MDQMgBUEBayEFCyAKIABrIQgDQCAHIQQCQAJAAkACQAJAAkACQAJAAkACQCAFIgNFDQACQCAELQAAQSRrDgsCAQEBAQEBAQEBAAELIANBAUYNBSAELAABQb9/Sg0EIAQgA0EBIANBgJ/AABCdAQALIAMgBGohCUEAIQAgBCEBA0AgACECIAEiACAJRg0IAn8gACwAACIFQQBOBEAgBUH/AXEhBSAAQQFqDAELIAAtAAFBP3EhByAFQR9xIQEgBUFfTQRAIAFBBnQgB3IhBSAAQQJqDAELIAAtAAJBP3EgB0EGdHIhByAFQXBJBEAgByABQQx0ciEFIABBA2oMAQsgAUESdEGAgPAAcSAALQADQT9xIAdBBnRyciEFIABBBGoLIgEgAiAAa2ohACAFQSRrDgsCAAAAAAAAAAAAAgALAAsgA0EBRg0BIAQsAAFBv39KDQEgBCADQQEgA0G0nsAAEJ0BAAsCQAJAAkAgAgRAAkAgAiADTyIARQRAIAIgBGosAABBv39MDQEgDCAEIAIQmQFFDQRBASECDA4LIAIgA0YNAgsgBCADQQAgAkGUnsAAEJ0BAAsgDCAEIAIQmQFFDQJBASECDAsLIAwgBCACEJkBRQ0AQQEhAgwKCyAARQRAIAIgBGosAABBv39KDQEMDwsgAiADRw0OCyACIARqIQcgAyACayEFDAcLIAYgA0EBayIANgIkIAZBADYCICAGIAA2AhwgBkEkNgIUIAZBJDYCKCAGQQE6ACwgBiAEQQFqIgA2AhggBkEIaiAGQRRqEC4gBigCCEEBRw0EAkAgBigCDCICQX9HBEAgAkEBaiEBIANBAUcNAQwFCyMAQSBrIgAkACAAQQA2AhggAEEBNgIMIABB2LPAADYCCCAAQgQ3AhAgAEEIakHEnsAAEIQBAAsgACwAAEG/f0oNAwwLCwJAAn8gBCwAASIAQQBOBEAgAEH/AXEMAQsgBC0AAkE/cSICIABBH3EiAUEGdHIgAEFfTQ0AGiAELQADQT9xIAJBBnRyIgIgAUEMdHIgAEFwSQ0AGiABQRJ0QYCA8ABxIAQtAARBP3EgAkEGdHJyC0EuRwRAQQEhAiAMQaCfwABBARCZAQ0IIAQsAAFBQEgNAQwDCyAMQYCewABBAhCZAQRAQQEhAgwICwJAIANBA08EQCAELAACQUBIDQELIARBAmohByADQQJrIQUMBwsgBCADQQIgA0GQn8AAEJ0BAAsgBCADQQEgA0Gkn8AAEJ0BAAtBASECIAxBoJ/AAEEBEJkBDQULIARBAWohByADQQFrIQUMAwsCQAJAAkACQCABIANJBEAgASAEaiwAAEFASA0MIAJBAmohAQwBCyABIANHDQsgAkECaiIBRQ0BCwJAIAEgA0kEQCABIARqLAAAQb9/Sg0BDAsLIAEgA0cNCgsgASAEaiEHIAMgAWshBQJAAkAgAg4DBQEAAgsgAC8AAEHToAFGBEBB/57AACEADAYLIAAvAABBwqABRgRAQf6ewAAhAAwGCyAALwAAQdKMAUYEQEH9nsAAIQAMBgsgAC8AAEHMqAFGBEBB/J7AACEADAYLIAAvAABBx6gBRgRAQfuewAAhAAwGCyAALwAAQcygAUYEQEH6nsAAIQAMBgsgAC8AAEHSoAFHDQFB+Z7AACEADAULIAAtAABBwwBGBEBB+J7AACEADAULIAAtAABB9QBGDQEMAwsgBC0AAUH1AEcNAiACQQJJDQEgBCwAAkG/f0wNAQsgACACaiETIAJBAWshCSAEQQJqIgIhAAJAA0BBASENIAAgE0YNAQJ/IAAsAAAiAUEATgRAIAFB/wFxIQEgAEEBagwBCyAALQABQT9xIQsgAUEfcSEKIAFBX00EQCAKQQZ0IAtyIQEgAEECagwBCyAALQACQT9xIAtBBnRyIQsgAUFwSQRAIAsgCkEMdHIhASAAQQNqDAELIApBEnRBgIDwAHEgAC0AA0E/cSALQQZ0cnIiAUGAgMQARg0CIABBBGoLIQAgAUEwa0EKSSABQeEAa0EGSXINAAtBACENCyAGQRRqIQoCQAJAAkACQAJAAkACQCAJIgAOAgABAgsgCkEAOgABDAQLIAItAAAiAUEraw4DAgECAQsgAi0AACEBCwJAAkACQCABQf8BcUErRgRAIABBAWshASACQQFqIQIgAEEJSwRAIAEhAAwCCyABIgANAkEAIQEMAwsgAEEISw0ADAELQQAhAQJAA0AgAEUNAyACLQAAIgtBMGsiCUEKTwRAQX8gC0EgciIJQdcAayILIAsgCUHhAGtJGyIJQRBPDQULIAGtQgSGIhRCIIinDQEgAkEBaiECIABBAWshACAJIBSnIgtqIgEgC08NAAsgCkECOgABDAQLIApBAjoAAQwDC0EAIQEDQCACLQAAIgtBMGsiCUEKTwRAQX8gC0EgciIJQdcAayILIAsgCUHhAGtJGyIJQRBPDQMLIAJBAWohAiAJIAFBBHRqIQEgAEEBayIADQALCyAKIAE2AgQgCkEAOgAADAILIApBAToAASAKQQE6AAAMAQsgCkEBOgAACyAGLQAUDQEgDUVBgIDEACAGKAIYIgAgAEGAsANzQYCAxABrQYCQvH9JGyIAQYCAxABGcg0BIAYgADYCBCAAQSBJIABB/wBrQSFJcg0BIAZBBGogDBBGRQ0DQQEhAgwECyAAIAJBASACQeiewAAQnQEACyASIQIgDCAEIAMQmQFFDQMMAgtBASECIAwgAEEBEJkBRQ0ACwsLIAZBMGokACACDAULIAEgBUEBIAVBhJ7AABCdAQALIAQgAyABIANB1J7AABCdAQALIAQgA0EBIAFBxJ7AABCdAQALIAQgAyACIANBpJ7AABCdAQALQbCdwAAQswEACwwBCyAPQQA2AhwgDyABNgIYIA9CADcCECAPIAApAgQ3AgggD0EIakEBEBILIA9BIGokAAuYAQIDfwFvIwBBIGsiAyQAIAMgACgCABDLASIENgIAIAMgAjYCBCACIARHBEAgA0EANgIIIAMgA0EEaiADQQhqEH4ACxCeASIEEJUBIgUlARAFIQYQMyICIAYmASAFQYQBTwRAIAUQWgsgAiAAKAIAIAFBAnYQrwEgAkGEAU8EQCACEFoLIARBhAFPBEAgBBBaCyADQSBqJAALUAEBfyMAQTBrIgAkACAAQQE2AgwgAEGorMAANgIIIABCATcCFCAAIABBL2qtQoCAgIDwC4Q3AyAgACAAQSBqNgIQIABBCGpB/IPAABCEAQALQwEDfwJAIAJFDQADQCAALQAAIgQgAS0AACIFRgRAIABBAWohACABQQFqIQEgAkEBayICDQEMAgsLIAQgBWshAwsgAwtBAQF/IAIgACgCACAAKAIIIgNrSwRAIAAgAyACEEQgACgCCCEDCyAAKAIEIANqIAEgAhA8GiAAIAIgA2o2AghBAAtBAQF/IAIgACgCACAAKAIIIgNrSwRAIAAgAyACEEogACgCCCEDCyAAKAIEIANqIAEgAhA8GiAAIAIgA2o2AghBAAtPAQJ/IAAoAgQhAiAAKAIAIQMCQCAAKAIIIgAtAABFDQAgA0HkrsAAQQQgAigCDBEBAEUNAEEBDwsgACABQQpGOgAAIAMgASACKAIQEQAAC0cBAX8jAEEQayICJAAgAkEIaiABEHogAiACKAIIIAIoAgwoAhgRAgAgAigCBCEBIAAgAigCADYCACAAIAE2AgQgAkEQaiQAC08BAn9B/c7AAC0AABogASgCBCECIAEoAgAhA0EIQQQQpgEiAUUEQEEEQQgQxAEACyABIAI2AgQgASADNgIAIABBtJbAADYCBCAAIAE2AgALQQEBfyACIAAoAgAgACgCCCIDa0sEQCAAIAMgAhBVIAAoAgghAwsgACgCBCADaiABIAIQPBogACACIANqNgIIQQALQgEBfyMAQSBrIgMkACADQQA2AhAgA0EBNgIEIANCBDcCCCADIAE2AhwgAyAANgIYIAMgA0EYajYCACADIAIQhAEACz0BAn8gACAAKAIEIgMgAms2AgQgACAAKAIAIAIgA0tyIgQ2AgBBASEDIAQEfyADBSAAKAIIIAEgAhCZAQsLPgEBfyMAQRBrIgIkACACQQhqIAEgASgCACgCBBECACACKAIMIQEgACACKAIINgIAIAAgATYCBCACQRBqJAALxAIBA38gACgCACECIAEoAhwiAEEQcUUEQCAAQSBxRQRAIAIgARCyAQ8LQQAhACMAQYABayIEJAAgAigCACECA0AgACAEakH/AGogAkEPcSIDQTByIANBN2ogA0EKSRs6AAAgAEEBayEAIAJBEEkgAkEEdiECRQ0ACyAAQYABaiICQYEBTwRAIAJBgAFBjK/AABBoAAsgAUGcr8AAQQIgACAEakGAAWpBACAAaxAhIARBgAFqJAAPC0EAIQAjAEGAAWsiBCQAIAIoAgAhAgNAIAAgBGpB/wBqIAJBD3EiA0EwciADQdcAaiADQQpJGzoAACAAQQFrIQAgAkEQSSACQQR2IQJFDQALIABBgAFqIgJBgQFPBEAgAkGAAUGMr8AAEGgACyABQZyvwABBAiAAIARqQYABakEAIABrECEgBEGAAWokAAvNAwEDfyAAKAIAIQAgASgCHCIDQRBxRQRAIANBIHFFBEAjAEEQayIDJAACQAJAAkAgAC0AACIAQeQATwRAIAMgACAAQeQAbiIAQeQAbGtB/wFxQQF0QZ6vwABqLwAAOwAODAELQQIhAiAAQQpPDQELIANBDWogAmogAEEwcjoAAAwBC0EBIQIgAyAAQQF0QZ6vwABqLwAAOwAOCyABQQFBACADQQ1qIAJqIAJBA3MQISADQRBqJAAPCyMAQYABayIEJAAgAC0AACEAA0AgAiAEakH/AGogAEEPcSIDQTByIANBN2ogA0EKSRs6AAAgAkEBayECIAAiA0EEdiEAIANBEE8NAAsgAkGAAWoiAEGBAU8EQCAAQYABQYyvwAAQaAALIAFBnK/AAEECIAIgBGpBgAFqQQAgAmsQISAEQYABaiQADwsjAEGAAWsiBCQAIAAtAAAhAANAIAIgBGpB/wBqIABBD3EiA0EwciADQdcAaiADQQpJGzoAACACQQFrIQIgACIDQQR2IQAgA0EQTw0ACyACQYABaiIAQYEBTwRAIABBgAFBjK/AABBoAAsgAUGcr8AAQQIgAiAEakGAAWpBACACaxAhIARBgAFqJAALOAACQCACQYCAxABGDQAgACACIAEoAhARAABFDQBBAQ8LIANFBEBBAA8LIAAgAyAEIAEoAgwRAQALOQEBfyMAQRBrIgMkACADIAE2AgwgAyAANgIIIANBCGpBiI/AACADQQxqQYiPwAAgAkH4jsAAEDgACzwBAX8jAEEQayICJAAgAkGUkcAANgIMIAIgADYCCCACQQhqQZiRwAAgAkEMakGYkcAAIAFBjJXAABA4AAvcBAIHfwF+IwBBEGsiBiQAIAYgADYCDCAGQQxqIQgjAEEQayICJAAgASgCFEHwm8AAQQ0gASgCGCgCDBEBACEAIAJBADoADSACIAA6AAwgAiABNgIIIwBBQGoiACQAQQEhAwJAIAJBCGoiBC0ABA0AIAQtAAUhBSAEKAIAIgEoAhwiB0EEcUUEQCABKAIUQeuuwABB6K7AACAFQQFxIgUbQQJBAyAFGyABKAIYKAIMEQEADQEgASgCFEH9m8AAQQQgASgCGCgCDBEBAA0BIAEoAhRBuK7AAEECIAEoAhgoAgwRAQANASAIIAFB7JvAACgCABEAACEDDAELIAVBAXFFBEAgASgCFEHtrsAAQQMgASgCGCgCDBEBAA0BIAEoAhwhBwsgAEEBOgAbIAAgASkCFDcCDCAAQcyuwAA2AjQgACAAQRtqNgIUIAAgASkCCDcCJCABKQIAIQkgACAHNgI4IAAgASgCEDYCLCAAIAEtACA6ADwgACAJNwIcIAAgAEEMaiIBNgIwIAFB/ZvAAEEEECoNACABQbiuwABBAhAqDQAgCCAAQRxqQeybwAAoAgARAAANACAAKAIwQfCuwABBAiAAKAI0KAIMEQEAIQMLIARBAToABSAEIAM6AAQgAEFAayQAIAItAA0iASACLQAMIgNyIQACQCADQQFxIAFBAUdyDQAgBCgCACIALQAcQQRxRQRAIAAoAhRB867AAEECIAAoAhgoAgwRAQAhAAwBCyAAKAIUQfKuwABBASAAKAIYKAIMEQEAIQALIAJBEGokACAAQQFxIAZBEGokAAsvAQF/IwBBEGsiAiQAIAJBCGogABB6IAIoAgggASACKAIMKAIQEQAAIAJBEGokAAs5AQF/QQEhAgJAIAAgARA/DQAgASgCFEH0q8AAQQIgASgCGCgCDBEBAA0AIABBBGogARA/IQILIAIL1hMCF30LfxAzIiMgCSYBAn8gCCEqIwBBMGsiIiQAICIgIzYCBCAiQoCAgIDAADcCCCAiQQA2AhBB7M7AACErQejOwAAoAgBFBEACf0H9zsAALQAAGgJAQYCAwAAQESIIRQ0AIAhBBGstAABBA3FFDQAgCEGAgMAAEFcaCyAIBEBB+M7AAEGAgBA2AgBB7M7AAEEANgIAQfTOwAAoAgAhI0H0zsAAIAg2AgBB8M7AACgCACEmQfDOwABBgIAQNgIAQejOwAAoAgBB6M7AAEEBNgIARSAmRXJFBEAgIyAmQQJ0QQQQsAELQezOwAAMAQtBBEGAgMAAEJQBAAshKwsgKygCAEUEQCArQX82AgACQCArAn8gKkUEQEEAISNBAAwBCyArQQxqKAIAISwgK0EIaigCACEIAkAgCgRAQQAhIwNAICIgIkEEaiAjQQJ0ICNBgIAEICogI2siCiAKQYCABE8bIgpqIiZBAnQQsQE2AhQgCkECdCIjICxLDQQgIkEUaiAIICMQbyAiIAI4AiAgIiABOAIcICIgADgCGCAiIAU4AiwgIiAEOAIoICIgAzgCJCAIIQojAEEQayInJAAgIwRAICJBCGohKCAiQSRqIiQqAgAhFSAkKgIEIRggJCoCCCEZICJBGGoiJCoCCCEfICQqAgQhICAkKgIAISEDQCAjQQQgI0EESSIkGyEpAkAgCi0AA7NDAAB/Q5VDzczMPV0NACAnQQRqIAogKRAmAn0CQCAkRQRAICcqAgwhDiAnKgIIIQwgJyoCBCELQwAAAAAhFkMAAAAAIRcgCigCDCIlQf8BcQRAICVBAWtB/wFxs0NFIpE9lEMAABDBkhAsIRcLICVBCHYiJEH/AXEEQCAkQQFrQf8BcbNDRSKRPZRDAAAQwZIQLCEWCyAfIA6TIQ8gICAMkyESICEgC5MhESAlQRB2IiRB/wFxDQFDAAAAAAwCC0EDIClBnIPAABBpAAsgJEEBa0H/AXGzQ0UikT2UQwAAEMGSECwLIRogGSAKKAIIIiRBGHWyQwAA/kKVIhMgGCAlQRh1skMAAP5ClSIUlCAZIBOUkyIQlCAkQRB2wLJDAAD+QpUiDSAZIA2UIBUgFJSTIg6UkyAVIBOUIBggDZSTIgxDAACAPyANIA2UkyATIBOUkyAUIBSUk0MAAAAAEJIBkSIblJIiCyALkpIhHCAYIA0gDJQgFCAQlJMgDiAblJIiCyALkpIhHSAVIBQgDpQgEyAMlJMgECAblJIiCyALkpIhHiAPIBMgEiAUlCAPIBOUkyIQlCANIA8gDZQgESAUlJMiDpSTIBEgE5QgEiANlJMiDCAblJIiCyALkpIhDyASIA0gDJQgFCAQlJMgDiAblJIiCyALkpIhDSARIBQgDpQgEyAMlJMgECAblJIiCyALkpIhDAJAIBogFyAWEJIBIBoQkgFDCtcjPJQiC11FBEAgCyAWXkUEQCALIBdeRQRAQwAAgD8gGpUiCyAPlCIPIAsgHJQiEpRDAACAPyAXlSILIAyUIhEgCyAelCIMlEMAAIA/IBaVIgsgDZQiECALIB2UIguUkpIiDiAOlCASIBKUIAwgDJQgCyALlJKSIgwgDyAPlCARIBGUIBAgEJSSkkMAAIC/kpSTIgtDAAAAAF0NBCAOjCALkZMgDJUhDAwDCyAei0O9N4Y1XQ0DIA0gHSAMjCAelSIMlJIgFpUiCyALlCAPIBwgDJSSIBqVIgsgC5SSQwAAgD9eRQ0CDAMLIB2LQ703hjVdDQIgDCAeIA2MIB2VIgyUkiAXlSILIAuUIA8gHCAMlJIgGpUiCyALlJJDAACAP14NAgwBCyAci0O9N4Y1XQ0BIAwgHiAPjCAclSIMlJIgF5UiCyALlCANIB0gDJSSIBaVIgsgC5SSQwAAgD9eDQELIAYgDF9FIAcgDGBFcg0AICgoAggiJCAoKAIARgRAICgQTwsgKCgCBCAkQQJ0aiAMOAIAICggJEEBajYCCAsgCiApQQJ0aiEKICMgKWsiIw0ACwsgJ0EQaiQAICIoAhQiCkGEAU8EQCAKEFoLICYiIyAqSQ0ACwwBC0EAISMDQCAiICJBBGogI0ECdCAjQYCABCAqICNrIgogCkGAgARPGyIKaiImQQJ0ELEBNgIUIApBAnQiIyAsSw0DICJBFGogCCAjEG8gIiACOAIgICIgATgCHCAiIAA4AhggIiAFOAIsICIgBDgCKCAiIAM4AiQgCCEKIwBBEGsiJyQAICMEQCAiQQhqISggIkEkaiIkKgIAIhggGJQgJCoCBCIZIBmUkiAkKgIIIg8gD5SSIRIgIkEYaiIkKgIIIR8gJCoCBCEgICQqAgAhIQNAICNBBCAjQQRJIiQbISkCQCAKLQADs0MAAH9DlUPNzMw9XQ0AICdBBGogCiApECYCfQJAICRFBEAgJyoCDCEOICcqAgghDCAnKgIEIQtDAAAAACERQwAAAAAhECAKKAIMIiVB/wFxBEAgJUEBa0H/AXGzQ0UikT2UQwAAEMGSEMwBIRALICVBCHYiJEH/AXEEQCAkQQFrQf8BcbNDRSKRPZRDAAAQwZIQzAEhEQsgHyAOkyENICAgDJMhFSAhIAuTIQ4gJUEQdiIkQf8BcQ0BQwAAAAAMAgtBAyApQZyDwAAQaQALICRBAWtB/wFxs0NFIpE9lEMAABDBkhDMAQshCyAYIA6UIBkgFZSSIA8gDZSSIgwgDJQgEiAOIA6UIBUgFZSSIA0gDZSSIBAgEZIgC5JDAABAQJUiCyALlJOUkyILQwAAAABdDQAgDIwgC5GTIBKVIgsgBmBFIAcgC2BFcg0AICgoAggiJCAoKAIARgRAICgQTwsgKCgCBCAkQQJ0aiALOAIAICggJEEBajYCCAsgCiApQQJ0aiEKICMgKWsiIw0ACwsgJ0EQaiQAICIoAhQiCkGEAU8EQCAKEFoLICYiIyAqSQ0ACwsgIigCECEjICsoAgBBAWoLNgIAICMQDSEJEDMiCCAJJgEgIiAINgIkICIoAgwhIyAiKAIQISQjAEEgayIlJAAgIkEkaigCACIKJQEQCiEmICUgJDYCBCAlICY2AgACQCAkICZGBEAQngEiKhCVASImJQEgIyAkEAghCRAzIiMgCSYBICpBhAFPBEAgKhBaCyAmQYQBTwRAICYQWgsgCiUBICMlAUEAEAkgI0GEAU8EQCAjEFoLICVBIGokAAwBCyAlQQA2AgggJSAlQQRqICVBCGoQfgALICIoAggiCgRAICIoAgwgCkECdEEEELABCyAiKAIEIgpBhAFPBEAgChBaCyAiQTBqJAAgCAwCCyAjICxB5IbAABBqAAsQcAALIgglASAIEFoL+gECAn8BfiMAQRBrIgIkACACQQE7AQwgAiABNgIIIAIgADYCBCMAQRBrIgEkACACQQRqIgApAgAhBCABIAA2AgwgASAENwIEIwBBEGsiACQAIAFBBGoiASgCACICKAIMIQMCQAJAAkACQCACKAIEDgIAAQILIAMNAUEBIQJBACEDDAILIAMNACACKAIAIgIoAgQhAyACKAIAIQIMAQsgAEGAgICAeDYCACAAIAE2AgwgAEHglsAAIAEoAgQgASgCCCIALQAIIAAtAAkQWQALIAAgAzYCBCAAIAI2AgAgAEHElsAAIAEoAgQgASgCCCIALQAIIAAtAAkQWQALJQAgAEUEQEGYj8AAQTIQuQEACyAAIAIgAyAEIAUgASgCEBEIAAsoACABIAAoAgAtAABBAnQiAEHkp8AAaigCACAAQdCnwABqKAIAEJkBCyMAIABFBEBBmI/AAEEyELkBAAsgACACIAMgBCABKAIQEQkACyMAIABFBEBBmI/AAEEyELkBAAsgACACIAMgBCABKAIQERIACyMAIABFBEBBmI/AAEEyELkBAAsgACACIAMgBCABKAIQERwACyMAIABFBEBBmI/AAEEyELkBAAsgACACIAMgBCABKAIQER4ACyMAIABFBEBBmI/AAEEyELkBAAsgACACIAMgBCABKAIQESAACygBAX8gACgCACIBQYCAgIB4ckGAgICAeEcEQCAAKAIEIAFBARCwAQsLJwAgAEEcakEAIAJC2KGkg7Hi0d18URtBACABQpXX3ZjDl4qMC1EbCyEAIABFBEBBmI/AAEEyELkBAAsgACACIAMgASgCEBEDAAsfACAARQRAQZiPwABBMhC5AQALIAAgAiABKAIQEQAAC+MVAQx/EDMiBCABJgECfyAAIQYQMyIAIAImASMAQdAAayIIJAAgCCAANgIYIAggBDYCFCAIQRRqKAIAEMoBIQtBvM7AACgCAEUEQEHkzsAAQQA2AgBB2M7AAEEANgIAQczOwABBADYCAEHAzsAAQQA2AgBB4M7AACgCACEFQeDOwABBBDYCAEHczsAAKAIAIQ1B3M7AAEEANgIAQdTOwAAoAgAhA0HUzsAAQQQ2AgBB0M7AACgCACEJQdDOwABBADYCAEHIzsAAKAIAIQRByM7AAEECNgIAQcTOwAAoAgAhB0HEzsAAQQA2AgBBvM7AACgCACEAQbzOwABBATYCAAJAIABFDQAgBwRAIAQgB0EBdEECELABCyAJBEAgAyAJQQJ0QQQQsAELIA1FDQAgBSAN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IABBAWshACACQRBJIAJBBHYhAkUNAAsgAEGAAWoiAkGBAUkEQCABQZyvwABBAiAAIARqQYABakEAIABrECEgASAFNgIcIAEgBzYCBCABIAY2AgAgBEGAAWokAAwBCyACQYABQYyvwAAQaAALCwwAIAAgASkCADcDAAsNACABQfCYwABBAhAeCw0AIABBhJzAACABECkLDgAgAUGvm8AAQQUQmQELDgAgAUG8p8AAQRIQmQELDQAgAEHQqcAAIAEQKQsOACABQcipwABBBRCZAQsZACAAIAFBjM/AACgCACIAQTogABsRAgAACw0AIABBzK7AACABECkLCgAgAiAAIAEQHguQBQEHfwJAAn8CQCACIgUgACABa0sEQCABIAJqIQMgACACaiECIAAgBUEQSQ0CGiACQXxxIQRBACACQQNxIgZrIQcgBgRAIANBAWshAANAIAJBAWsiAiAALQAAOgAAIABBAWshACACIARLDQALCyAEIAUgBmsiBkF8cSIFayECIAMgB2oiA0EDcQRAIAVBAEwNAiADQQN0IgBBGHEhByADQXxxIghBBGshAUEAIABrQRhxIQkgCCgCACEAA0AgBEEEayIEIAAgCXQgASgCACIAIAd2cjYCACABQQRrIQEgAiAESQ0ACwwCCyAFQQBMDQEgASAGakEEayEBA0AgBEEEayIEIAEoAgA2AgAgAUEEayEBIAIgBEkNAAsMAQsCQCAFQRBJBEAgACECDAELIABBACAAa0EDcSIDaiEEIAMEQCAAIQIgASEAA0AgAiAALQAAOgAAIABBAWohACACQQFqIgIgBEkNAAsLIAQgBSADayIFQXxxIgZqIQICQCABIANqIgNBA3EEQCAGQQBMDQEgA0EDdCIAQRhxIQcgA0F8cSIIQQRqIQFBACAAa0EYcSEJIAgoAgAhAANAIAQgACAHdiABKAIAIgAgCXRyNgIAIAFBBGohASAEQQRqIgQgAkkNAAsMAQsgBkEATA0AIAMhAQNAIAQgASgCADYCACABQQRqIQEgBEEEaiIEIAJJDQALCyAFQQNxIQUgAyAGaiEBCyAFRQ0CIAIgBWohAANAIAIgAS0AADoAACABQQFqIQEgAkEBaiICIABJDQALDAILIAZBA3EiAEUNASADIAVrIQMgAiAAawshACADQQFrIQEDQCACQQFrIgIgAS0AADoA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YTBhYWYvbGlicmFyeS9jb3JlL3NyYy9zbGljZS9pbmRleC5ycwB0AxAATwAAAGgDAAA0AAAAdAMQAE8AAABvAwAAMgAAAGFzc2VydGlvbiBmYWlsZWQ6IHNlbGYuaXNfY2hhcl9ib3VuZGFyeShuKS9ydXN0Yy85MGIzNWE2MjM5YzNkOGJkYWJjNTMwYTZhMDgxNmY3ZmY4OWEwYWFmL2xpYnJhcnkvYWxsb2Mvc3JjL3N0cmluZy5ycwAAAA4EEABLAAAAxAcAAB0AAAAOBBAASwAAAMwHAAAdAAAAHAAAAAwAAAAEAAAAHQAAAB4AAAAfAAAARXJyb3Jhc3NlcnRpb24gZmFpbGVkOiBzZWxmLmlzX2NoYXJfYm91bmRhcnkobmV3X2xlbikvcnVzdGMvOTBiMzVhNjIzOWMzZDhiZGFiYzUzMGE2YTA4MTZmN2ZmODlhMGFhZi9saWJyYXJ5L2FsbG9jL3NyYy9zdHJpbmcucnPJBBAASwAAAMAFAAANAAAAAAAAABAAAAAEAAAAIgAAACMAAAAkAAAAYmFja3RyYWNlIGNhcHR1cmUgZmFpbGVkL1VzZXJzL2RtYXJjb3MvLmNhcmdvL3JlZ2lzdHJ5L3NyYy9pbmRleC5jcmF0ZXMuaW8tNmYxN2QyMmJiYTE1MDAxZi9hbnlob3ctMS4wLjk4L3NyYy9lcnJvci5ycwAAVAUQAF4AAABnBAAADgAAAAEAAAAAAAAAOiAAAMwFEAACAAAACgpDYXVzZWQgYnk6CgAAACUAAAAMAAAABAAAACYAAAAnAAAAHwAAAAoKc3RhY2sgYmFja3RyYWNlOlN0YWNrIGJhY2t0cmFjZToKABIGEAARAAAAUwBBuIzAAAvZBAEAAAAoAAAAYSBEaXNwbGF5IGltcGxlbWVudGF0aW9uIHJldHVybmVkIGFuIGVycm9yIHVuZXhwZWN0ZWRseQDJBBAASwAAAHsKAAAOAAAAL3J1c3RjLzkwYjM1YTYyMzljM2Q4YmRhYmM1MzBhNmEwODE2ZjdmZjg5YTBhYWYvbGlicmFyeS9hbGxvYy9zcmMvdmVjL21vZC5yc4gGEABMAAAALQoAACQAAAAAAAAAEAAAAAQAAAAiAAAAIwAAACQAAAAgICAgOiAAAAEAAAAAAAAAAAcQAAIAAAAgICAgICAgL1VzZXJzL2RtYXJjb3MvLmNhcmdvL3JlZ2lzdHJ5L3NyYy9pbmRleC5jcmF0ZXMuaW8tNmYxN2QyMmJiYTE1MDAxZi9qcy1zeXMtMC4zLjc3L3NyYy9saWIucnMAGwcQAFwAAAD7GAAAAQAAAAAAAAAEAAAABAAAADUAAABjbG9zdXJlIGludm9rZWQgcmVjdXJzaXZlbHkgb3IgYWZ0ZXIgYmVpbmcgZHJvcHBlZExhenkgaW5zdGFuY2UgaGFzIHByZXZpb3VzbHkgYmVlbiBwb2lzb25lZMoHEAAqAAAAL1VzZXJzL2RtYXJjb3MvLmNhcmdvL3JlZ2lzdHJ5L3NyYy9pbmRleC5jcmF0ZXMuaW8tNmYxN2QyMmJiYTE1MDAxZi9vbmNlX2NlbGwtMS4yMS4zL3NyYy9saWIucnMA/AcQAF8AAAAIAwAAGQAAAHJlZW50cmFudCBpbml0AABsCBAADgAAAPwHEABfAAAAegIAAA0AQZyRwAALlQ8EAAAABAAAADsAAAA6AAAAPAAAAAwAAAAEAAAAPQAAAD4AAAA/AAAAL3J1c3QvZGVwcy9kbG1hbGxvYy0wLjIuNi9zcmMvZGxtYWxsb2MucnNhc3NlcnRpb24gZmFpbGVkOiBwc2l6ZSA+PSBzaXplICsgbWluX292ZXJoZWFkAMQIEAApAAAAqAQAAAkAAABhc3NlcnRpb24gZmFpbGVkOiBwc2l6ZSA8PSBzaXplICsgbWF4X292ZXJoZWFkAADECBAAKQAAAK4EAAANAAAAc3RkL3NyYy9iYWNrdHJhY2UucnNvcGVyYXRpb24gbm90IHN1cHBvcnRlZCBvbiB0aGlzIHBsYXRmb3JtgAkQACgAAAAkAAAAAAAAAAIAAACoCRAAdW5zdXBwb3J0ZWQgYmFja3RyYWNlZGlzYWJsZWQgYmFja3RyYWNlAGwJEAAUAAAAigEAAB0AAABAAAAAEAAAAAQAAABBAAAAQgAAAAEAAAAAAAAAOiBzdGQvc3JjL3N5bmMvbGF6eV9sb2NrLnJzABYKEAAZAAAA0AAAABMAAABjYW5ub3QgcmVjdXJzaXZlbHkgYWNxdWlyZSBtdXRleEAKEAAgAAAAc3RkL3NyYy9zeXMvc3luYy9tdXRleC9ub190aHJlYWRzLnJzaAoQACQAAAAUAAAACQAAAHN0ZC9zcmMvc3luYy9v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Zm9ybWF0dGluZyB0cmFpdCBpbXBsZW1lbnRhdGlvbiByZXR1cm5lZCBhbiBlcnJvciB3aGVuIHRoZSB1bmRlcmx5aW5nIHN0cmVhbSBkaWQgbm90YWxsb2Mvc3JjL2ZtdC5ycwAAjhUQABAAAAB+AgAADgAAAGZyb21fc3RyX3JhZGl4X2ludDogbXVzdCBsaWUgaW4gdGhlIHJhbmdlIGBbMiwgMzZdYCAtIGZvdW5kILAVEAA8AAAALi4wMTIzNDU2Nzg5YWJjZGVmQm9ycm93TXV0RXJyb3JhbHJlYWR5IGJvcnJvd2VkOiAAABQWEAASAAAAAQAAAAAAAABbY2FsbGVkIGBPcHRpb246OnVud3JhcCgpYCBvbiBhIGBOb25lYCB2YWx1ZWluZGV4IG91dCBvZiBib3VuZHM6IHRoZSBsZW4gaXMgIGJ1dCB0aGUgaW5kZXggaXMgAABkFhAAIAAAAIQWEAASAAAAPT0hPW1hdGNoZXNhc3NlcnRpb24gYGxlZnQgIHJpZ2h0YCBmYWlsZWQKICBsZWZ0OiAKIHJpZ2h0OiAAsxYQABAAAADDFhAAFwAAANoWEAAJAAAAIHJpZ2h0YCBmYWlsZWQ6IAogIGxlZnQ6IAAAALMWEAAQAAAA/BYQABAAAAAMFxAACQAAANoWEAAJAAAAOiAAAAEAAAAAAAAAOBcQAAIAAAAAAAAADAAAAAQAAABlAAAAZgAAAGcAAAAgICAgIHsgLCAgewosCn0gfQpdY29yZS9zcmMvZm10L251bS5ycwAAdxcQABMAAABmAAAAFwAAADB4MDAwMTAyMDMwNDA1MDYwNzA4MDkxMDExMTIxMzE0MTUxNjE3MTgxOTIwMjEyMjIzMjQyNTI2MjcyODI5MzAzMTMyMzMzNDM1MzYzNzM4Mzk0MDQxNDI0MzQ0NDU0NjQ3NDg0OTUwNTE1MjUzNTQ1NTU2NTc1ODU5NjA2MTYyNjM2NDY1NjY2NzY4Njk3MDcxNzI3Mzc0NzU3Njc3Nzg3OTgwODE4MjgzODQ4NTg2ODc4ODg5OTA5MTkyOTM5NDk1OTY5Nzk4OTljb3JlL3NyYy9mbXQvbW9kLnJzZmFsc2V0cnVlAABmGBAAEwAAAKMJAAAmAAAAZhgQABMAAACsCQAAGgAAAHJhbmdlIHN0YXJ0IGluZGV4ICBvdXQgb2Yg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"},42955:(A,n,t)=>{t.r(n),t.d(n,{FINGER_TIPS:()=>BI,FpsMovement:()=>pI,HANDS:()=>QI,Hand:()=>oI,HandMovement:()=>EI,JOINT_IDS:()=>eI,JOINT_INDEX:()=>sI,JOINT_RADIUS:()=>gI,JOINT_SEGMENTS:()=>aI,JOINT_SEGMENT_STEPS:()=>II,JOINT_TIPS:()=>rI,JointEnum:()=>tI,NUM_JOINTS:()=>iI,PackedSplats:()=>oa,PlyReader:()=>Yg,PointerControls:()=>yI,Readback:()=>Qg,Sint8ToFloat:()=>Xn,SparkControls:()=>dI,SparkRenderer:()=>Fa,SparkViewpoint:()=>ha,SplatAccumulator:()=>pa,SplatEdit:()=>wg,SplatEditRgbaBlendMode:()=>dg,SplatEditSdf:()=>yg,SplatEditSdfType:()=>hg,SplatEdits:()=>fg,SplatFileType:()=>ea,SplatGenerator:()=>Ng,SplatLoader:()=>ta,SplatMesh:()=>Rg,SplatModifier:()=>Gg,SplatSkinning:()=>Ja,SplatTransformer:()=>kg,SpzReader:()=>ba,SpzWriter:()=>La,Uint8ToFloat:()=>jn,VRButton:()=>nI,XrHands:()=>CI,constructAxes:()=>_a,constructGrid:()=>Ka,constructSpherePoints:()=>za,dyno:()=>Bg,flipPixels:()=>It,floatToSint8:()=>Vn,floatToUint8:()=>Wn,fromHalf:()=>On,generators:()=>Va,getSplatFileType:()=>ia,imageSplats:()=>Pa,isAndroid:()=>gt,isMobile:()=>st,isOculus:()=>at,isPcSogs:()=>ga,modifiers:()=>$a,pixelsToPngUrl:()=>rt,setPackedSplat:()=>nt,textSplats:()=>Za,toHalf:()=>Pn,transcodeSpz:()=>Ya,unpackSplat:()=>et,unpackSplats:()=>Ia,utils:()=>Dt});var e=t(68909);let i;const s="undefined"!=typeof TextDecoder?new TextDecoder("utf-8",{ignoreBOM:!0,fatal:!0}):{decode:()=>{throw Error("TextDecoder not available")}};"undefined"!=typeof TextDecoder&&s.decode();let g=null;function a(A,n){return A>>>=0,s.decode((null!==g&&0!==g.byteLength||(g=new Uint8Array(i.memory.buffer)),g).subarray(A,A+n))}async function I(A){if(void 0!==i)return i;void 0!==A&&(Object.getPrototypeOf(A)===Object.prototype?({module_or_path:A}=A):console.warn("using deprecated parameters for the initialization function; pass a single object instead")),void 0===A&&(A=new URL(t(9933),t.b));const n=function(){const A={wbg:{}};return A.wbg.__wbg_buffer_609cc3eee51ed158=function(A){return A.buffer},A.wbg.__wbg_length_3b4f022188ae8db6=function(A){return A.length},A.wbg.__wbg_length_6ca527665d89694d=function(A){return A.length},A.wbg.__wbg_length_8cfd2c6409af88ad=function(A){return A.length},A.wbg.__wbg_new_9fee97a409b32b68=function(A){return new Uint16Array(A)},A.wbg.__wbg_new_e3b321dcfef89fc7=function(A){return new Uint32Array(A)},A.wbg.__wbg_newwithbyteoffsetandlength_e6b7e69acd4c7354=function(A,n,t){return new Float32Array(A,n>>>0,t>>>0)},A.wbg.__wbg_newwithbyteoffsetandlength_f1dead44d1fc7212=function(A,n,t){return new Uint32Array(A,n>>>0,t>>>0)},A.wbg.__wbg_newwithlength_5a5efe313cfd59f1=function(A){return new Float32Array(A>>>0)},A.wbg.__wbg_set_10bad9bee0e9c58b=function(A,n,t){A.set(n,t>>>0)},A.wbg.__wbg_set_d23661d19148b229=function(A,n,t){A.set(n,t>>>0)},A.wbg.__wbg_set_f4f1f0daa30696fc=function(A,n,t){A.set(n,t>>>0)},A.wbg.__wbg_subarray_3aaeec89bb2544f0=function(A,n,t){return A.subarray(n>>>0,t>>>0)},A.wbg.__wbg_subarray_769e1e0f81bb259b=function(A,n,t){return A.subarray(n>>>0,t>>>0)},A.wbg.__wbindgen_init_externref_table=function(){const A=i.__wbindgen_export_0,n=A.grow(4);A.set(0,void 0),A.set(n+0,void 0),A.set(n+1,null),A.set(n+2,!0),A.set(n+3,!1)},A.wbg.__wbindgen_memory=function(){return i.memory},A.wbg.__wbindgen_throw=function(A,n){throw new Error(a(A,n))},A}();("string"==typeof A||"function"==typeof Request&&A instanceof Request||"function"==typeof URL&&A instanceof URL)&&(A=fetch(A));const{instance:e,module:s}=await async function(A,n){if("function"==typeof Response&&A instanceof Response){if("function"==typeof WebAssembly.instantiateStreaming)try{return await WebAssembly.instantiateStreaming(A,n)}catch(n){if("application/wasm"==A.headers.get("Content-Type"))throw n;console.warn("`WebAssembly.instantiateStreaming` failed because your server does not serve Wasm with `application/wasm` MIME type. Falling back to `WebAssembly.instantiate` which is slower. Original error:\n",n)}const t=await A.arrayBuffer();return await WebAssembly.instantiate(t,n)}{const t=await WebAssembly.instantiate(A,n);return t instanceof WebAssembly.Instance?{instance:t,module:A}:t}}(await A,n);return function(A,n){return i=A.exports,I.__wbindgen_wasm_module=n,g=null,i.__wbindgen_start(),i}(e,s)}const r=-9,B=(9-r)/254,o=2048,Q=2048,C=1;function E(A){return"bool"===A||"bvec2"===A||"bvec3"===A||"bvec4"===A}function c(A){return"int"===A||"uint"===A||"float"===A}function l(A){return"int"===A||"ivec2"===A||"ivec3"===A||"ivec4"===A}function h(A){return"uint"===A||"uvec2"===A||"uvec3"===A||"uvec4"===A}function u(A){return"float"===A||"vec2"===A||"vec3"===A||"vec4"===A}function d(A){return"mat2"===A||"mat2x2"===A||"mat2x3"===A||"mat2x4"===A||"mat3"===A||"mat3x2"===A||"mat3x3"===A||"mat3x4"===A||"mat4"===A||"mat4x2"===A||"mat4x3"===A||"mat4x4"===A}function p(A){return u(A)||d(A)}function y(A){return"vec2"===A||"ivec2"===A||"uvec2"===A}function D(A){return"vec3"===A||"ivec3"===A||"uvec3"===A}function w(A){return"vec4"===A||"ivec4"===A||"uvec4"===A}function f(A){return"mat2"===A||"mat2x2"===A}function m(A){return"mat3"===A||"mat3x3"===A}function S(A){return"mat4"===A||"mat4x4"===A}function x(A){switch(A){case"vec2":case"vec3":case"vec4":return"float";case"ivec2":case"ivec3":case"ivec4":return"int";case"uvec2":case"uvec3":case"uvec4":return"uint";default:throw new Error(`Invalid vector type: ${A}`)}}function F(A){switch(A){case"vec2":case"ivec2":case"uvec2":return 2;case"vec3":case"ivec3":case"uvec3":return 3;case"vec4":case"ivec4":case"uvec4":return 4;default:throw new Error(`Invalid vector type: ${A}`)}}function G(A){if(c(A))return"uint";if(y(A))return"uvec2";if(D(A))return"uvec3";if(w(A))return"uvec4";throw new Error(`Invalid vector type: ${A}`)}function k(A){if("string"==typeof A)return A;if("object"==typeof A&&A.type)return A.type;throw new Error(`Invalid DynoType: ${String(A)}`)}function N(A){return Math.trunc(A).toString()}function M(A){return`${Math.max(0,Math.trunc(A)).toString()}u`}function R(A){return A===Number.POSITIVE_INFINITY?"INFINITY":A===Number.NEGATIVE_INFINITY?"-INFINITY":Number.isInteger(A)?A.toFixed(1):A.toString()}function b(A){if(A instanceof U)return A.type;return A.dynoOut().type}class U{constructor(A){this.__isDynoValue=!0,this.type=A}}class v extends U{constructor(A,n){super(A.outTypes[n]),this.dyno=A,this.key=n}}class L extends U{constructor(A,n){super(A),this.literal=n}getLiteral(){return this.literal}}function Y(A,n){return new L(A,n)}class J extends L{constructor(A,n){super(A,""),this.value=n}getLiteral(){const{type:A,value:n}=this;switch(A){case"bool":return n?"true":"false";case"uint":return M(n);case"int":return N(n);case"float":return R(n);case"bvec2":{const A=n;return`bvec2(${A[0]}, ${A[1]})`}case"uvec2":{if(n instanceof e.Vector2)return`uvec2(${M(n.x)}, ${M(n.y)})`;const A=n;return`uvec2(${M(A[0])}, ${M(A[1])})`}case"ivec2":{if(n instanceof e.Vector2)return`ivec2(${N(n.x)}, ${N(n.y)})`;const A=n;return`ivec2(${N(A[0])}, ${N(A[1])})`}case"vec2":{if(n instanceof e.Vector2)return`vec2(${R(n.x)}, ${R(n.y)})`;const A=n;return`vec2(${R(A[0])}, ${R(A[1])})`}case"bvec3":{const A=n;return`bvec3(${A[0]}, ${A[1]}, ${A[2]})`}case"uvec3":{if(n instanceof e.Vector3)return`uvec3(${M(n.x)}, ${M(n.y)}, ${M(n.z)})`;const A=n;return`uvec3(${M(A[0])}, ${M(A[1])}, ${M(A[2])})`}case"ivec3":{if(n instanceof e.Vector3)return`ivec3(${N(n.x)}, ${N(n.y)}, ${N(n.z)})`;const A=n;return`ivec3(${N(A[0])}, ${N(A[1])}, ${N(A[2])})`}case"vec3":{if(n instanceof e.Vector3)return`vec3(${R(n.x)}, ${R(n.y)}, ${R(n.z)})`;const A=n;return`vec3(${R(A[0])}, ${R(A[1])}, ${R(A[2])})`}case"bvec4":{const A=n;return`bvec4(${A[0]}, ${A[1]}, ${A[2]}, ${A[3]})`}case"uvec4":{if(n instanceof e.Vector4)return`uvec4(${M(n.x)}, ${M(n.y)}, ${M(n.z)}, ${M(n.w)})`;const A=n;return`uvec4(${M(A[0])}, ${M(A[1])}, ${M(A[2])}, ${M(A[3])})`}case"ivec4":{if(n instanceof e.Vector4)return`ivec4(${N(n.x)}, ${N(n.y)}, ${N(n.z)}, ${N(n.w)})`;const A=n;return`ivec4(${N(A[0])}, ${N(A[1])}, ${N(A[2])}, ${N(A[3])})`}case"vec4":{if(n instanceof e.Vector4)return`vec4(${R(n.x)}, ${R(n.y)}, ${R(n.z)}, ${R(n.w)})`;if(n instanceof e.Quaternion)return`vec4(${R(n.x)}, ${R(n.y)}, ${R(n.z)}, ${R(n.w)})`;const A=n;return`vec4(${R(A[0])}, ${R(A[1])}, ${R(A[2])}, ${R(A[3])})`}case"mat2":case"mat2x2":{const t=n,i=t instanceof e.Matrix2?t.elements:n,s=new Array(4).fill(0).map(((A,n)=>R(i[n])));return`${A}(${s.join(", ")})`}case"mat2x3":{const t=n,e=new Array(6).fill(0).map(((A,n)=>R(t[n])));return`${A}(${e.join(", ")})`}case"mat2x4":{const t=n,e=new Array(8).fill(0).map(((A,n)=>R(t[n])));return`${A}(${e.join(", ")})`}case"mat3":case"mat3x3":{const t=n,i=t instanceof e.Matrix3?t.elements:n,s=new Array(9).fill(0).map(((A,n)=>R(i[n])));return`${A}(${s.join(", ")})`}case"mat3x2":{const t=n,e=new Array(6).fill(0).map(((A,n)=>R(t[n])));return`${A}(${e.join(", ")})`}case"mat3x4":{const t=n,e=new Array(12).fill(0).map(((A,n)=>R(t[n])));return`${A}(${e.join(", ")})`}case"mat4":case"mat4x4":{const t=n,i=t instanceof e.Matrix4?t.elements:n,s=new Array(16).fill(0).map(((A,n)=>R(i[n])));return`${A}(${s.join(", ")})`}case"mat4x2":{const t=n,e=new Array(8).fill(0).map(((A,n)=>R(t[n])));return`${A}(${e.join(", ")})`}case"mat4x3":{const t=n,e=new Array(12).fill(0).map(((A,n)=>R(t[n])));return`${A}(${e.join(", ")})`}default:throw new Error(`Type not implemented: ${String(A)}`)}}}function H(A,n){return new J(A,n)}function T(A){const n=String(A);if(E(A))return`${n}(false)`;if(p(A))return`${n}(0.0)`;if(l(A))return`${n}(0)`;if(h(A))return`${n}(0u)`;throw new Error(`Type not implemented: ${n}`)}const q="    ";class K{constructor({indent:A}={}){this.globals=new Set,this.statements=[],this.uniforms={},this.declares=new Set,this.updaters=[],this.sequence=0,this.indent=q,this.indent=A??q}nextSequence(){return this.sequence++}}class _{constructor({inTypes:A,outTypes:n,inputs:t,update:e,globals:i,statements:s,generate:g}){this.inTypes=A??{},this.outTypes=n??{},this.inputs=t??{},this.update=e,this.globals=i,this.statements=s,this.generate=g??(({inputs:A,outputs:n,compile:t})=>{var e,i;return{globals:null==(e=this.globals)?void 0:e.call(this,{inputs:A,outputs:n,compile:t}),statements:null==(i=this.statements)?void 0:i.call(this,{inputs:A,outputs:n,compile:t})}})}get outputs(){const A={};for(const n in this.outTypes)A[n]=new v(this,n);return A}apply(A){return Object.assign(this.inputs,A),this.outputs}compile({inputs:A,outputs:n,compile:t}){const e=[`// ${this.constructor.name}(${Object.values(A).join(", ")}) => (${Object.values(n).join(", ")})`],i=[];for(const A in n){const e=n[A];e&&!t.declares.has(e)&&(t.declares.add(e),i.push(A))}const{globals:s,statements:g,uniforms:a}=this.generate({inputs:A,outputs:n,compile:t});for(const A of s??[])t.globals.add(A);for(const A in a)t.uniforms[A]=a[A];this.update&&t.updaters.push(this.update);for(const A of i){const i=n[A];i&&(t.uniforms[i]||e.push(`${O(i,this.outTypes[A])};`))}return(null==g?void 0:g.length)&&(e.push("{"),e.push(...g.map((A=>t.indent+A))),e.push("}")),e}}class z extends _{constructor({inTypes:A,outTypes:n,inputs:t,update:e,globals:i,construct:s}){super({inTypes:A,outTypes:n,inputs:t,update:e,globals:i,generate:A=>this.generateBlock(A)}),this.construct=s}generateBlock({inputs:A,outputs:n,compile:t}){var e,i;const s={},g={};for(const n in A)null!=A[n]&&(s[n]=new L(this.inTypes[n],A[n]));for(const A in n)null!=n[A]&&(g[A]=new U(this.outTypes[A]));const a={roots:[]},I=this.construct(s,g,a);for(const i of(null==(e=this.globals)?void 0:e.call(this,{inputs:A,outputs:n,compile:t}))??[])t.globals.add(i);const r=[],B=new Map;function o(A,n,e){let i=B.get(A);if(!i){i={sequence:t.nextSequence(),outNames:new Map,newOuts:new Set},B.set(A,i);for(const n in A.inputs){let t=A.inputs[n];for(;t;){if(t instanceof U){t instanceof v&&o(t.dyno,t.key);break}t=t.dynoOut()}}r.push(A)}n&&(e||i.newOuts.add(n),i.outNames.set(n,e??`${n}_${i.sequence}`))}for(const A of a.roots)o(A);for(const A in g){let t=(null==I?void 0:I[A])??g[A];for(;t;){if(t instanceof U){t instanceof v&&o(t.dyno,t.key,n[A]);break}t=t.dynoOut()}g[A]=t}const Q=[];for(const A of r){const n={},e={};for(const t in A.inputs){let e=A.inputs[t];for(;e;){if(e instanceof U){if(e instanceof L)n[t]=e.getLiteral();else if(e instanceof v){const A=null==(i=B.get(e.dyno))?void 0:i.outNames.get(e.key);if(!A)throw new Error(`Source not found for ${e.dyno.constructor.name}.${e.key}`);n[t]=A}break}e=e.dynoOut()}}const s=B.get(A)??{outNames:new Map};for(const[A,n]of s.outNames.entries())e[A]=n;const g=A.compile({inputs:n,outputs:e,compile:t});Q.push(g)}const C=[];for(const A in n)g[A]instanceof L&&C.push(`${n[A]} = ${g[A].getLiteral()};`);C.length>0&&Q.push(C);return{statements:Q.flatMap(((A,n)=>0===n?A:["",...A]))}}}function Z(A,n,t,{update:e,globals:i}={}){return new z({inTypes:A,outTypes:n,construct:t,update:e,globals:i})}function P({inTypes:A,outTypes:n,inputs:t,update:e,globals:i,statements:s,generate:g}){return new _({inTypes:A,outTypes:n,inputs:t,update:e,globals:i,statements:s,generate:g})}function O(A,n,t){const e="string"==typeof n?n:n.type;if(!e)throw new Error(`Invalid DynoType: ${String(n)}`);return`${e} ${A}${null!=t?`[${t}]`:""}`}function W(A){var n;let t=!1;const e=A.split("\n").map((A=>{const n=A.trimEnd();return t?n:n.length>0?(t=!0,n):null})).filter((A=>null!=A));for(;e.length>0&&0===e[e.length-1].length;)e.pop();if(0===e.length)return[];const i=null==(n=e[0].match(/^\s*/))?void 0:n[0];if(!i)return e;const s=new RegExp(`^${i}`);return e.map((A=>A.replace(s,"")))}function V(A){return W(A).join("\n")}class j extends _{constructor({a:A,outKey:n,outTypeFunc:t}){const e={a:b(A)},i=t(b(A));super({inTypes:e,outTypes:{[n]:i},inputs:{a:A}}),this.outKey=n}dynoOut(){return new v(this,this.outKey)}}class X extends _{constructor({a:A,b:n,outKey:t,outTypeFunc:e}){const i={a:b(A),b:b(n)},s=e(b(A),b(n));super({inTypes:i,outTypes:{[t]:s},inputs:{a:A,b:n}}),this.outKey=t}dynoOut(){return new v(this,this.outKey)}}class $ extends _{constructor({a:A,b:n,c:t,outKey:e,outTypeFunc:i}){const s={a:b(A),b:b(n),c:b(t)},g=i(b(A),b(n),b(t));super({inTypes:s,outTypes:{[e]:g},inputs:{a:A,b:n,c:t}}),this.outKey=e}dynoOut(){return new v(this,this.outKey)}}const AA={type:"Gsplat"},nA={type:"PackedSplats"},tA=(A,n)=>new QA({packedSplats:A,index:n}),eA=(A,n,t,e)=>new CA({packedSplats:A,index:n,base:t,count:e}),iA=A=>new EA({gsplat:A}),sA=({gsplat:A,flags:n,index:t,center:e,scales:i,quaternion:s,rgba:g,rgb:a,opacity:I,x:r,y:B,z:o,r:Q,g:C,b:E})=>new cA({gsplat:A,flags:n,index:t,center:e,scales:i,quaternion:s,rgba:g,rgb:a,opacity:I,x:r,y:B,z:o,r:Q,g:C,b:E}),gA=A=>new hA({gsplat:A}),aA=(A,{scale:n,rotate:t,translate:e,recolor:i})=>new uA({gsplat:A,scale:n,rotate:t,translate:e,recolor:i}),IA=V("\n  struct Gsplat {\n    vec3 center;\n    uint flags;\n    vec3 scales;\n    int index;\n    vec4 quaternion;\n    vec4 rgba;\n  };\n  const uint GSPLAT_FLAG_ACTIVE = 1u << 0u;\n\n  bool isGsplatActive(uint flags) {\n    return (flags & GSPLAT_FLAG_ACTIVE) != 0u;\n  }\n"),rA=V("\n  struct PackedSplats {\n    usampler2DArray texture;\n    int numSplats;\n  };\n");class BA extends j{constructor({packedSplats:A}){super({a:A,outKey:"numSplats",outTypeFunc:()=>"int"}),this.statements=({inputs:A,outputs:n})=>[`${n.numSplats} = ${A.a}.numSplats;`]}}const oA=V("\n  bool readPackedSplat(usampler2DArray texture, int numSplats, int index, out Gsplat gsplat) {\n    if ((index >= 0) && (index < numSplats)) {\n      uvec4 packed = texelFetch(texture, splatTexCoord(index), 0);\n      unpackSplat(packed, gsplat.center, gsplat.scales, gsplat.quaternion, gsplat.rgba);\n      return true;\n    } else {\n      return false;\n    }\n  }\n");class QA extends _{constructor({packedSplats:A,index:n}){super({inTypes:{packedSplats:nA,index:"int"},outTypes:{gsplat:AA},inputs:{packedSplats:A,index:n},globals:()=>[IA,rA,oA],statements:({inputs:A,outputs:n})=>{const{gsplat:t}=n;if(!t)return[];const{packedSplats:e,index:i}=A;let s;return s=e&&i?W(`\n            if (readPackedSplat(${e}.texture, ${e}.numSplats, ${i}, ${t})) {\n              bool zeroSize = all(equal(${t}.scales, vec3(0.0, 0.0, 0.0)));\n              ${t}.flags = zeroSize ? 0u : GSPLAT_FLAG_ACTIVE;\n            } else {\n              ${t}.flags = 0u;\n            }\n          `):[`${t}.flags = 0u;`],s.push(`${t}.index = ${i??"0"};`),s}})}dynoOut(){return new v(this,"gsplat")}}class CA extends _{constructor({packedSplats:A,index:n,base:t,count:e}){super({inTypes:{packedSplats:nA,index:"int",base:"int",count:"int"},outTypes:{gsplat:AA},inputs:{packedSplats:A,index:n,base:t,count:e},globals:()=>[IA,rA,oA],statements:({inputs:A,outputs:n})=>{const{gsplat:t}=n;if(!t)return[];const{packedSplats:e,index:i,base:s,count:g}=A;let a;return a=e&&i&&s&&g?W(`\n            ${t}.flags = 0u;\n            if ((${i} >= ${s}) && (${i} < (${s} + ${g}))) {\n              if (readPackedSplat(${e}.texture, ${e}.numSplats, ${i}, ${t})) {\n                bool zeroSize = all(equal(${t}.scales, vec3(0.0, 0.0, 0.0)));\n                ${t}.flags = zeroSize ? 0u : GSPLAT_FLAG_ACTIVE;\n              }\n            }\n          `):[`${t}.flags = 0u;`],a.push(`${t}.index = ${i??"0"};`),a}})}dynoOut(){return new v(this,"gsplat")}}class EA extends _{constructor({gsplat:A}){super({inTypes:{gsplat:AA},outTypes:{flags:"uint",active:"bool",index:"int",center:"vec3",scales:"vec3",quaternion:"vec4",rgba:"vec4",rgb:"vec3",opacity:"float",x:"float",y:"float",z:"float",r:"float",g:"float",b:"float"},inputs:{gsplat:A},globals:()=>[IA],statements:({inputs:A,outputs:n})=>{const{gsplat:t}=A,{flags:e,active:i,index:s,center:g,scales:a,quaternion:I,rgba:r,rgb:B,opacity:o,x:Q,y:C,z:E,r:c,g:l,b:h}=n;return[e?`${e} = ${t?`${t}.flags`:"0u"};`:null,i?`${i} = isGsplatActive(${t?`${t}.flags`:"0u"});`:null,s?`${s} = ${t?`${t}.index`:"0"};`:null,g?`${g} = ${t?`${t}.center`:"vec3(0.0, 0.0, 0.0)"};`:null,a?`${a} = ${t?`${t}.scales`:"vec3(0.0, 0.0, 0.0)"};`:null,I?`${I} = ${t?`${t}.quaternion`:"vec4(0.0, 0.0, 0.0, 1.0)"};`:null,r?`${r} = ${t?`${t}.rgba`:"vec4(0.0, 0.0, 0.0, 0.0)"};`:null,B?`${B} = ${t?`${t}.rgba.rgb`:"vec3(0.0, 0.0, 0.0)"};`:null,o?`${o} = ${t?`${t}.rgba.a`:"0.0"};`:null,Q?`${Q} = ${t?`${t}.center.x`:"0.0"};`:null,C?`${C} = ${t?`${t}.center.y`:"0.0"};`:null,E?`${E} = ${t?`${t}.center.z`:"0.0"};`:null,c?`${c} = ${t?`${t}.rgba.r`:"0.0"};`:null,l?`${l} = ${t?`${t}.rgba.g`:"0.0"};`:null,h?`${h} = ${t?`${t}.rgba.b`:"0.0"};`:null].filter(Boolean)}})}}class cA extends _{constructor({gsplat:A,flags:n,index:t,center:e,scales:i,quaternion:s,rgba:g,rgb:a,opacity:I,x:r,y:B,z:o,r:Q,g:C,b:E}){super({inTypes:{gsplat:AA,flags:"uint",index:"int",center:"vec3",scales:"vec3",quaternion:"vec4",rgba:"vec4",rgb:"vec3",opacity:"float",x:"float",y:"float",z:"float",r:"float",g:"float",b:"float"},outTypes:{gsplat:AA},inputs:{gsplat:A,flags:n,index:t,center:e,scales:i,quaternion:s,rgba:g,rgb:a,opacity:I,x:r,y:B,z:o,r:Q,g:C,b:E},globals:()=>[IA],statements:({inputs:A,outputs:n})=>{const{gsplat:t}=n;if(!t)return[];const{gsplat:e,flags:i,index:s,center:g,scales:a,quaternion:I,rgba:r,rgb:B,opacity:o,x:Q,y:C,z:E,r:c,g:l,b:h}=A;return[`${t}.flags = ${i??(e?`${e}.flags`:"0u")};`,`${t}.index = ${s??(e?`${e}.index`:"0")};`,`${t}.center = ${g??(e?`${e}.center`:"vec3(0.0, 0.0, 0.0)")};`,`${t}.scales = ${a??(e?`${e}.scales`:"vec3(0.0, 0.0, 0.0)")};`,`${t}.quaternion = ${I??(e?`${e}.quaternion`:"vec4(0.0, 0.0, 0.0, 1.0)")};`,`${t}.rgba = ${r??(e?`${e}.rgba`:"vec4(0.0, 0.0, 0.0, 0.0)")};`,B?`${t}.rgba.rgb = ${B};`:null,o?`${t}.rgba.a = ${o};`:null,Q?`${t}.center.x = ${Q};`:null,C?`${t}.center.y = ${C};`:null,E?`${t}.center.z = ${E};`:null,c?`${t}.rgba.r = ${c};`:null,l?`${t}.rgba.g = ${l};`:null,h?`${t}.rgba.b = ${h};`:null].filter(Boolean)}})}dynoOut(){return new v(this,"gsplat")}}const lA=V("\n  vec3 gsplatNormal(vec3 scales, vec4 quaternion) {\n    float minScale = min(scales.x, min(scales.y, scales.z));\n    vec3 normal;\n    if (scales.z == minScale) {\n      normal = vec3(0.0, 0.0, 1.0);\n    } else if (scales.y == minScale) {\n      normal = vec3(0.0, 1.0, 0.0);\n    } else {\n      normal = vec3(1.0, 0.0, 0.0);\n    }\n    return quatVec(quaternion, normal);\n  }\n");class hA extends j{constructor({gsplat:A}){super({a:A,outKey:"normal",outTypeFunc:()=>"vec3"}),this.globals=()=>[IA,lA],this.statements=({inputs:A,outputs:n})=>[`${n.normal} = gsplatNormal(${A.a}.scales, ${A.a}.quaternion);`]}}class uA extends _{constructor({gsplat:A,scale:n,rotate:t,translate:e,recolor:i}){super({inTypes:{gsplat:AA,scale:"float",rotate:"vec4",translate:"vec3",recolor:"vec4"},outTypes:{gsplat:AA},inputs:{gsplat:A,scale:n,rotate:t,translate:e,recolor:i},globals:()=>[IA],statements:({inputs:A,outputs:n,compile:t})=>{const{gsplat:e}=n;if(!e||!A.gsplat)return[];const{scale:i,rotate:s,translate:g,recolor:a}=A,I=t.indent;return[`${e} = ${A.gsplat};`,`if (isGsplatActive(${e}.flags)) {`,i?`${I}${e}.center *= ${i};`:null,s?`${I}${e}.center = quatVec(${s}, ${e}.center);`:null,g?`${I}${e}.center += ${g};`:null,i?`${I}${e}.scales *= ${i};`:null,s?`${I}${e}.quaternion = quatQuat(${s}, ${e}.quaternion);`:null,a?`${I}${e}.rgba *= ${a};`:null,"}"].filter(Boolean)}})}dynoOut(){return new v(this,"gsplat")}}const dA=A=>new pA({gsplat:A});class pA extends _{constructor({gsplat:A}){super({inTypes:{gsplat:AA},inputs:{gsplat:A},globals:()=>[IA],statements:({inputs:A,outputs:n})=>{const{output:t}=n;if(!t)return[];const{gsplat:e}=A;return e?W(`\n            if (isGsplatActive(${e}.flags)) {\n              ${t} = packSplat(${e}.center, ${e}.scales, ${e}.quaternion, ${e}.rgba);\n            } else {\n              ${t} = uvec4(0u, 0u, 0u, 0u);\n            }\n          `):[`${t} = uvec4(0u, 0u, 0u, 0u);`]}})}dynoOut(){return new v(this,"output")}}class yA extends _{constructor({rgba8:A}){super({inTypes:{rgba8:"vec4"},inputs:{rgba8:A},statements:({inputs:A,outputs:n})=>[`target = ${A.rgba8??"vec4(0.0, 0.0, 0.0, 0.0)"};`]})}dynoOut(){return new v(this,"rgba8")}}const DA=(A=0,n)=>new FA({key:n,value:A}),wA=(A,n)=>new vA({key:n,value:A});class fA extends _{constructor({key:A,type:n,count:t,value:e,update:i,globals:s}){A=A??"value",super({outTypes:{[A]:n},update:()=>{if(i){const A=i(this.value);void 0!==A&&(this.value=A)}this.uniform.value=this.value},generate:({inputs:e,outputs:i})=>{const g=(null==s?void 0:s({inputs:e,outputs:i}))??[],a={},I=i[A];return I&&(g.push(`uniform ${O(I,n,t)};`),a[I]=this.uniform),{globals:g,uniforms:a}}}),this.type=n,this.count=t,this.value=e,this.uniform={value:e},this.outKey=A}dynoOut(){return new v(this,this.outKey)}}class mA extends fA{constructor({key:A,value:n,update:t}){super({key:A,type:"bool",value:n,update:t})}}class SA extends fA{constructor({key:A,value:n,update:t}){super({key:A,type:"uint",value:n,update:t})}}class xA extends fA{constructor({key:A,value:n,update:t}){super({key:A,type:"int",value:n,update:t})}}class FA extends fA{constructor({key:A,value:n,update:t}){super({key:A,type:"float",value:n,update:t})}}class GA extends fA{constructor({key:A,value:n,update:t}){super({key:A,type:"bvec2",value:n,update:t})}}class kA extends fA{constructor({key:A,value:n,update:t}){super({key:A,type:"uvec2",value:n,update:t})}}class NA extends fA{constructor({key:A,value:n,update:t}){super({key:A,type:"ivec2",value:n,update:t})}}class MA extends fA{constructor({key:A,value:n,update:t}){super({key:A,type:"vec2",value:n,update:t})}}class RA extends fA{constructor({key:A,value:n,update:t}){super({key:A,type:"bvec3",value:n,update:t})}}class bA extends fA{constructor({key:A,value:n,update:t}){super({key:A,type:"uvec3",value:n,update:t})}}class UA extends fA{constructor({key:A,value:n,update:t}){super({key:A,type:"ivec3",value:n,update:t})}}class vA extends fA{constructor({key:A,value:n,update:t}){super({key:A,type:"vec3",value:n,update:t})}}class LA extends fA{constructor({key:A,value:n,update:t}){super({key:A,type:"bvec4",value:n,update:t})}}class YA extends fA{constructor({key:A,value:n,update:t}){super({key:A,type:"uvec4",value:n,update:t})}}class JA extends fA{constructor({key:A,value:n,update:t}){super({key:A,type:"ivec4",value:n,update:t})}}class HA extends fA{constructor({key:A,value:n,update:t}){super({key:A,type:"vec4",value:n,update:t})}}class TA extends fA{constructor({key:A,value:n,update:t}){super({key:A,type:"mat2",value:n,update:t})}}class qA extends fA{constructor({key:A,value:n,update:t}){super({key:A,type:"mat2x2",value:n,update:t})}}class KA extends fA{constructor({key:A,value:n,update:t}){super({key:A,type:"mat2x3",value:n,update:t})}}class _A extends fA{constructor({key:A,value:n,update:t}){super({key:A,type:"mat2x4",value:n,update:t})}}class zA extends fA{constructor({key:A,value:n,update:t}){super({key:A,type:"mat3",value:n,update:t})}}class ZA extends fA{constructor({key:A,value:n,update:t}){super({key:A,type:"mat3x2",value:n,update:t})}}class PA extends fA{constructor({key:A,value:n,update:t}){super({key:A,type:"mat3x3",value:n,update:t})}}class OA extends fA{constructor({key:A,value:n,update:t}){super({key:A,type:"mat3x4",value:n,update:t})}}class WA extends fA{constructor({key:A,value:n,update:t}){super({key:A,type:"mat4",value:n,update:t})}}class VA extends fA{constructor({key:A,value:n,update:t}){super({key:A,type:"mat4x2",value:n,update:t})}}class jA extends fA{constructor({key:A,value:n,update:t}){super({key:A,type:"mat4x3",value:n,update:t})}}class XA extends fA{constructor({key:A,value:n,update:t}){super({key:A,type:"mat4x4",value:n,update:t})}}class $A extends fA{constructor({key:A,value:n,update:t}){super({key:A,type:"usampler2D",value:n,update:t})}}class An extends fA{constructor({key:A,value:n,update:t}){super({key:A,type:"isampler2D",value:n,update:t})}}class nn extends fA{constructor({key:A,value:n,update:t}){super({key:A,type:"sampler2D",value:n,update:t})}}class tn extends fA{constructor({key:A,value:n,update:t}){super({key:A,type:"usampler2DArray",value:n,update:t})}}class en extends fA{constructor({key:A,value:n,update:t}){super({key:A,type:"isampler2DArray",value:n,update:t})}}class sn extends fA{constructor({key:A,value:n,update:t}){super({key:A,type:"sampler2DArray",value:n,update:t})}}class gn extends fA{constructor({key:A,value:n,update:t}){super({key:A,type:"usampler3D",value:n,update:t})}}class an extends fA{constructor({key:A,value:n,update:t}){super({key:A,type:"isampler3D",value:n,update:t})}}class In extends fA{constructor({key:A,value:n,update:t}){super({key:A,type:"sampler3D",value:n,update:t})}}class rn extends fA{constructor({key:A,value:n,update:t}){super({key:A,type:"usamplerCube",value:n,update:t})}}class Bn extends fA{constructor({key:A,value:n,update:t}){super({key:A,type:"isamplerCube",value:n,update:t})}}class on extends fA{constructor({key:A,value:n,update:t}){super({key:A,type:"samplerCube",value:n,update:t})}}class Qn extends fA{constructor({key:A,value:n,update:t}){super({key:A,type:"sampler2DShadow",value:n,update:t})}}class Cn extends fA{constructor({key:A,value:n,update:t}){super({key:A,type:"sampler2DArrayShadow",value:n,update:t})}}class En extends fA{constructor({key:A,value:n,update:t}){super({key:A,type:"samplerCubeShadow",value:n,update:t})}}var cn=Uint8Array,ln=Uint16Array,hn=Int32Array,un=new cn([0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0,0,0,0]),dn=new cn([0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13,0,0]),pn=new cn([16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15]),yn=function(A,n){for(var t=new ln(31),e=0;e<31;++e)t[e]=n+=1<<A[e-1];var i=new hn(t[30]);for(e=1;e<30;++e)for(var s=t[e];s<t[e+1];++s)i[s]=s-t[e]<<5|e;return{b:t,r:i}},Dn=yn(un,2),wn=Dn.b,fn=Dn.r;wn[28]=258,fn[258]=28;for(var mn=yn(dn,0).b,Sn=new ln(32768),xn=0;xn<32768;++xn){var Fn=(43690&xn)>>1|(21845&xn)<<1;Fn=(61680&(Fn=(52428&Fn)>>2|(13107&Fn)<<2))>>4|(3855&Fn)<<4,Sn[xn]=((65280&Fn)>>8|(255&Fn)<<8)>>1}var Gn=function(A,n,t){for(var e=A.length,i=0,s=new ln(n);i<e;++i)A[i]&&++s[A[i]-1];var g,a=new ln(n);for(i=1;i<n;++i)a[i]=a[i-1]+s[i-1]<<1;if(t){g=new ln(1<<n);var I=15-n;for(i=0;i<e;++i)if(A[i])for(var r=i<<4|A[i],B=n-A[i],o=a[A[i]-1]++<<B,Q=o|(1<<B)-1;o<=Q;++o)g[Sn[o]>>I]=r}else for(g=new ln(e),i=0;i<e;++i)A[i]&&(g[i]=Sn[a[A[i]-1]++]>>15-A[i]);return g},kn=new cn(288);for(xn=0;xn<144;++xn)kn[xn]=8;for(xn=144;xn<256;++xn)kn[xn]=9;for(xn=256;xn<280;++xn)kn[xn]=7;for(xn=280;xn<288;++xn)kn[xn]=8;var Nn=new cn(32);for(xn=0;xn<32;++xn)Nn[xn]=5;var Mn=Gn(kn,9,1),Rn=Gn(Nn,5,1),bn=function(A){for(var n=A[0],t=1;t<A.length;++t)A[t]>n&&(n=A[t]);return n},Un=function(A,n,t){var e=n/8|0;return(A[e]|A[e+1]<<8)>>(7&n)&t},vn=function(A,n){var t=n/8|0;return(A[t]|A[t+1]<<8|A[t+2]<<16)>>(7&n)},Ln=function(A){return(A+7)/8|0},Yn=function(A,n,t){return(null==n||n<0)&&(n=0),(null==t||t>A.length)&&(t=A.length),new cn(A.subarray(n,t))},Jn=["unexpected EOF","invalid block type","invalid length/literal","invalid distance","stream finished","no stream handler",,"no callback","invalid UTF-8 data","extra field too long","date not in range 1980-2099","filename too long","stream finishing","invalid zip data"],Hn=function(A,n,t){var e=new Error(n||Jn[A]);if(e.code=A,Error.captureStackTrace&&Error.captureStackTrace(e,Hn),!t)throw e;return e},Tn=new cn(0),qn=function(){function A(A,n){"function"==typeof A&&(n=A,A={}),this.ondata=n;var t=A&&A.dictionary&&A.dictionary.subarray(-32768);this.s={i:0,b:t?t.length:0},this.o=new cn(32768),this.p=new cn(0),t&&this.o.set(t)}return A.prototype.e=function(A){if(this.ondata||Hn(5),this.d&&Hn(4),this.p.length){if(A.length){var n=new cn(this.p.length+A.length);n.set(this.p),n.set(A,this.p.length),this.p=n}}else this.p=A},A.prototype.c=function(A){this.s.i=+(this.d=A||!1);var n=this.s.b,t=function(A,n,t,e){var i=A.length;if(!i||n.f&&!n.l)return t||new cn(0);var s=!t,g=s||2!=n.i,a=n.i;s&&(t=new cn(3*i));var I=function(A){var n=t.length;if(A>n){var e=new cn(Math.max(2*n,A));e.set(t),t=e}},r=n.f||0,B=n.p||0,o=n.b||0,Q=n.l,C=n.d,E=n.m,c=n.n,l=8*i;do{if(!Q){r=Un(A,B,1);var h=Un(A,B+1,3);if(B+=3,!h){var u=A[(G=Ln(B)+4)-4]|A[G-3]<<8,d=G+u;if(d>i){a&&Hn(0);break}g&&I(o+u),t.set(A.subarray(G,d),o),n.b=o+=u,n.p=B=8*d,n.f=r;continue}if(1==h)Q=Mn,C=Rn,E=9,c=5;else if(2==h){var p=Un(A,B,31)+257,y=Un(A,B+10,15)+4,D=p+Un(A,B+5,31)+1;B+=14;for(var w=new cn(D),f=new cn(19),m=0;m<y;++m)f[pn[m]]=Un(A,B+3*m,7);B+=3*y;var S=bn(f),x=(1<<S)-1,F=Gn(f,S,1);for(m=0;m<D;){var G,k=F[Un(A,B,x)];if(B+=15&k,(G=k>>4)<16)w[m++]=G;else{var N=0,M=0;for(16==G?(M=3+Un(A,B,3),B+=2,N=w[m-1]):17==G?(M=3+Un(A,B,7),B+=3):18==G&&(M=11+Un(A,B,127),B+=7);M--;)w[m++]=N}}var R=w.subarray(0,p),b=w.subarray(p);E=bn(R),c=bn(b),Q=Gn(R,E,1),C=Gn(b,c,1)}else Hn(1);if(B>l){a&&Hn(0);break}}g&&I(o+131072);for(var U=(1<<E)-1,v=(1<<c)-1,L=B;;L=B){var Y=(N=Q[vn(A,B)&U])>>4;if((B+=15&N)>l){a&&Hn(0);break}if(N||Hn(2),Y<256)t[o++]=Y;else{if(256==Y){L=B,Q=null;break}var J=Y-254;if(Y>264){var H=un[m=Y-257];J=Un(A,B,(1<<H)-1)+wn[m],B+=H}var T=C[vn(A,B)&v],q=T>>4;if(T||Hn(3),B+=15&T,b=mn[q],q>3&&(H=dn[q],b+=vn(A,B)&(1<<H)-1,B+=H),B>l){a&&Hn(0);break}g&&I(o+131072);var K=o+J;if(o<b){var _=0-b,z=Math.min(b,K);for(_+o<0&&Hn(3);o<z;++o)t[o]=e[_+o]}for(;o<K;++o)t[o]=t[o-b]}}n.l=Q,n.p=L,n.b=o,n.f=r,Q&&(r=1,n.m=E,n.d=C,n.n=c)}while(!r);return o!=t.length&&s?Yn(t,0,o):t.subarray(0,o)}(this.p,this.s,this.o);this.ondata(Yn(t,n,this.s.b),this.d),this.o=Yn(t,this.s.b-32768),this.s.b=this.o.length,this.p=Yn(this.p,this.s.p/8|0),this.s.p&=7},A.prototype.push=function(A,n){this.e(A),this.c(n)},A}(),Kn=function(){function A(A,n){this.v=1,this.r=0,qn.call(this,A,n)}return A.prototype.push=function(A,n){if(qn.prototype.e.call(this,A),this.r+=A.length,this.v){var t=this.p.subarray(this.v-1),e=t.length>3?function(A){31==A[0]&&139==A[1]&&8==A[2]||Hn(6,"invalid gzip data");var n=A[3],t=10;4&n&&(t+=2+(A[10]|A[11]<<8));for(var e=(n>>3&1)+(n>>4&1);e>0;e-=!A[t++]);return t+(2&n)}(t):4;if(e>t.length){if(!n)return}else this.v>1&&this.onmember&&this.onmember(this.r-t.length);this.p=t.subarray(e),this.v=0}qn.prototype.c.call(this,n),!this.s.f||this.s.l||n||(this.v=Ln(this.s.p)+9,this.s={i:0},this.o=new cn(0),this.push(new cn(0),n))},A}(),_n="undefined"!=typeof TextDecoder&&new TextDecoder;try{_n.decode(Tn,{stream:!0})}catch(A){}const zn=new Float32Array(1),Zn=new Uint32Array(zn.buffer);function Pn(A){zn[0]=A;const n=Zn[0],t=n>>23&255,e=8388607&n,i=(n>>31&1)<<15;if(255===t)return 0!==e?32767|i:31744|i;const s=t-127+15;if(s>=31)return 31744|i;if(s<=0){if(s<-10)return i;return i|(8388608|e)>>1-s+13}return i|s<<10|e>>13}function On(A){const n=A>>15&1,t=A>>10&31,e=1023&A;let i;if(0===t)if(0===e)i=n<<31;else{let A=e,t=-14;for(;!(1024&A);)A<<=1,t--;A&=1023;i=n<<31|t+127<<23|A<<13}else if(31===t)i=0===e?n<<31|2139095040:n<<31|2143289344;else{i=n<<31|t-15+127<<23|e<<13}return Zn[0]=i,zn[0]}function Wn(A){return Math.max(0,Math.min(255,Math.round(255*A)))}function Vn(A){return Math.max(-127,Math.min(127,Math.round(127*A)))}function jn(A){return A/255}function Xn(A){return A/127}function $n(A){const n=[],t=new Set;return function A(e){e&&"object"==typeof e&&!t.has(e)&&(t.add(e),e instanceof ArrayBuffer?n.push(e):ArrayBuffer.isView(e)?n.push(e.buffer):Array.isArray(e)?e.forEach(A):Object.values(e).forEach(A))}(A),n}class At{constructor({allocate:A,dispose:n,valid:t}){this.items=[],this.allocate=A,this.dispose=n,this.valid=t}alloc(A){for(;;){const n=this.items.pop();if(!n)break;if(this.valid(n,A))return n;this.dispose&&this.dispose(n)}return this.allocate(A)}free(A){this.items.push(A)}disposeAll(){let A;for(A=this.items.pop();A;)this.dispose&&this.dispose(A),A=this.items.pop()}}function nt(A,n,t,i,s,g,a,I,o,Q,C,E,c,l,h,u){const d=Wn(l),p=Wn(h),y=Wn(u),D=Wn(c),w=ht(new e.Quaternion(o,Q,C,E)),f=255&w,m=w>>>8&255,S=w>>>16&255,x=0===g?0:Math.min(255,Math.max(0,Math.round((Math.log(g)-r)/B)+1)),F=0===a?0:Math.min(255,Math.max(0,Math.round((Math.log(a)-r)/B)+1)),G=0===I?0:Math.min(255,Math.max(0,Math.round((Math.log(I)-r)/B)+1)),k=Pn(t),N=Pn(i),M=Pn(s),R=4*n;A[R]=d|p<<8|y<<16|D<<24,A[R+1]=k|N<<16,A[R+2]=M|f<<16|m<<24,A[R+3]=x|F<<8|G<<16|S<<24}const tt={center:new e.Vector3,scales:new e.Vector3,quaternion:new e.Quaternion,color:new e.Color,opacity:0};function et(A,n){const t=tt,e=4*n,i=A[e],s=A[e+1],g=A[e+2],a=A[e+3];t.color.set((255&i)/255,(i>>>8&255)/255,(i>>>16&255)/255),t.opacity=(i>>>24&255)/255,t.center.set(On(65535&s),On(s>>>16&65535),On(65535&g));const I=255&a;t.scales.x=0===I?0:Math.exp(r+(I-1)*B);const o=a>>>8&255;t.scales.y=0===o?0:Math.exp(r+(o-1)*B);const Q=a>>>16&255;t.scales.z=0===Q?0:Math.exp(r+(Q-1)*B);return ut(g>>>16&65535|a>>>8&16711680,t.quaternion),t}function it(A){const n=o,t=Math.max(C,Math.min(Q,Math.ceil(A/n))),e=Math.ceil(A/(n*t));return{width:n,height:t,depth:e,maxSplats:n*t*e}}function st(){return navigator.maxTouchPoints>0||/Mobi|Android|iPhone|iPad|iPod|Opera Mini|IEMobile/.test(navigator.userAgent)}function gt(){return/Android/.test(navigator.userAgent)}function at(){return/Oculus/.test(navigator.userAgent)}function It(A,n,t){const e=new Uint8Array(4*n);for(let i=0;i<t/2;i++){const s=i*n*4,g=(t-1-i)*n*4;e.set(A.subarray(s,s+4*n)),A.set(A.subarray(g,g+4*n),s),A.set(e,g)}return A}function rt(A,n,t){const e=document.createElement("canvas");e.width=n,e.height=t;const i=e.getContext("2d");if(!i)throw new Error("Can't get 2d context");const s=i.createImageData(n,t);return s.data.set(A),i.putImageData(s,0,0),e.toDataURL("image/png")}function Bt(A){const n=new e.Clock(A.autoStart);return n.startTime=A.startTime,n.oldTime=A.oldTime,n.elapsedTime=A.elapsedTime,n.running=A.running,n}const ot=V("\n  precision highp float;\n\n  in vec3 position;\n\n  void main() {\n    gl_Position = vec4(position.xy, 0.0, 1.0);\n  }\n");function Qt(A){const n=new e.Vector3;for(const t of A)n.add(t);return n.divideScalar(A.length)}function Ct(A){if(0===A.length)return new e.Quaternion;const n=A[0].clone();for(let t=1;t<A.length;t++)A[t].dot(A[0])<0?(n.x-=A[t].x,n.y-=A[t].y,n.z-=A[t].z,n.w-=A[t].w):(n.x+=A[t].x,n.y+=A[t].y,n.z+=A[t].z,n.w+=A[t].w);return n.normalize()}function Et(A,n){const t=new e.Vector3(0,0,0).applyMatrix4(A),i=new e.Vector3(0,0,0).applyMatrix4(n),s=new e.Vector3(0,0,-1).applyMatrix4(A).sub(t).normalize(),g=new e.Vector3(0,0,-1).applyMatrix4(n).sub(i).normalize();return{distance:t.distanceTo(i),coincidence:s.dot(g)}}function ct(A,n){const[t,i]=[new e.Vector3,new e.Quaternion],[s,g]=[new e.Vector3,new e.Quaternion];A.decompose(t,i,new e.Vector3),n.decompose(s,g,new e.Vector3);return{distance:t.distanceTo(s),coorient:Math.abs(i.dot(g))}}function lt({matrix1:A,matrix2:n,maxDistance:t,minCoorient:e}){const{distance:i,coorient:s}=ct(A,n);return i<=t&&(null==e||s>=e)}function ht(A){const n=A.clone().normalize();n.w<0&&n.set(-n.x,-n.y,-n.z,-n.w);const t=2*Math.acos(n.w),i=Math.sqrt(n.x*n.x+n.y*n.y+n.z*n.z),s=i<1e-6?new e.Vector3(1,0,0):new e.Vector3(n.x,n.y,n.z).divideScalar(i),g=Math.abs(s.x)+Math.abs(s.y)+Math.abs(s.z);let a=s.x/g,I=s.y/g;if(s.z<0){const A=a;a=(1-Math.abs(I))*(a>=0?1:-1),I=(1-Math.abs(A))*(I>=0?1:-1)}const r=.5*a+.5,B=.5*I+.5,o=Math.round(255*r),Q=Math.round(255*B);return Math.round(t*(255/Math.PI))<<16|Q<<8|o}function ut(A,n){const t=A>>>16&255;let i=2*((255&A)/255-.5),s=2*((A>>>8&255)/255-.5);const g=1-(Math.abs(i)+Math.abs(s)),a=Math.max(-g,0);i+=i>=0?-a:a,s+=s>=0?-a:a;const I=new e.Vector3(i,s,g).normalize(),r=.5*(t/255*Math.PI),B=Math.sin(r),o=Math.cos(r);return n.set(I.x*B,I.y*B,I.z*B,o),n}function dt(A,n,t,e){return 255&Math.max(-127,Math.min(127,127*A))|(255&Math.max(-127,Math.min(127,127*n)))<<8|(255&Math.max(-127,Math.min(127,127*t)))<<16|(255&Math.max(-127,Math.min(127,127*e)))<<24}function pt(A,n){const t=[];let e=0,i=null;const s=new Kn(((A,s)=>{if(t.push(A),e+=A.length,s||e>=n){const A=new Uint8Array(e);let s=0;for(const n of t)A.set(n,s),s+=n.length;i=A.slice(0,n)}}));let g=0;for(;null==i&&g<A.length;){const n=A.slice(g,g+1024);s.push(n,!1),g+=1024}if(null==i&&(s.push(new Uint8Array,!0),null==i))throw new Error("Failed to decompress partial gzip");return i}class yt{constructor({fileBytes:A,chunkBytes:n=65536}){this.fileBytes=A,this.chunkBytes=n,this.offset=0,this.chunks=[],this.totalBytes=0,this.gunzip=new Kn(((A,n)=>{this.chunks.push(A),this.totalBytes+=A.length}))}read(A){for(;this.totalBytes<A&&this.offset<this.fileBytes.length;){const A=Math.min(this.offset+this.chunkBytes,this.fileBytes.length);this.gunzip.push(this.fileBytes.subarray(this.offset,A),!1),this.offset=A}if(this.totalBytes<A&&this.offset>=this.fileBytes.length&&this.gunzip.push(new Uint8Array(0),!0),this.totalBytes<A)throw new Error(`Unexpected EOF: needed ${A}, got ${this.totalBytes}`);const n=new Uint8Array(this.totalBytes);let t=0;for(const A of this.chunks)n.set(A,t),t+=A.length;const e=n.subarray(0,A);return this.chunks=[n.subarray(A)],this.totalBytes-=A,e}}const Dt=Object.freeze(Object.defineProperty({__proto__:null,DataCache:class{constructor({asyncFetch:A,maxItems:n=5}){this.asyncFetch=A,this.maxItems=n,this.items=[]}async getFetch(A){const n=this.items.findIndex((n=>n.key===A));if(n>=0){const A=this.items.splice(n,1)[0];return this.items.push(A),A.data}const t=await this.asyncFetch(A);for(this.items.push({key:A,data:t});this.items.length>this.maxItems;)this.items.shift();return t}},FreeList:At,GunzipReader:yt,IDENT_VERTEX_SHADER:ot,Sint8ToFloat:Xn,Uint8ToFloat:jn,averagePositions:Qt,averageQuaternions:Ct,cloneClock:Bt,coinciDist:Et,computeMaxSplats:function(A){const n=o,t=Math.max(C,Math.min(Q,Math.ceil(A/n)));return n*t*Math.ceil(A/(n*t))},coorientDist:ct,decodeQuatEulerXyz888:function(A,n){const t=(A>>>8&255)/255,e=(A>>>16&255)/255,i=(255&A)/255*(2*Math.PI)-Math.PI,s=t*(2*Math.PI)-Math.PI,g=e*(2*Math.PI)-Math.PI,a=Math.cos(.5*i),I=Math.sin(.5*i),r=Math.cos(.5*s),B=Math.sin(.5*s),o=Math.cos(.5*g),Q=Math.sin(.5*g);return n.w=a*r*o+I*B*Q,n.x=I*r*o-a*B*Q,n.y=a*B*o+I*r*Q,n.z=a*r*Q-I*B*o,n.normalize(),n},decodeQuatOctXy88R8:ut,decodeQuatXyz888:function(A,n){const t=A<<24>>24,e=A<<16>>24,i=A<<8>>24;n.set(t/127,e/127,i/127,0);const s=n.x*n.x+n.y*n.y+n.z*n.z;return n.w=Math.sqrt(Math.max(0,1-s)),n},decompressPartialGzip:pt,encodeQuatEulerXyz888:function(A){const n=A.clone().normalize(),t=2*(n.w*n.x+n.y*n.z),e=1-2*(n.x*n.x+n.y*n.y),i=Math.atan2(t,e),s=2*(n.w*n.y-n.z*n.x),g=Math.abs(s)>=1?Math.sign(s)*(Math.PI/2):Math.asin(s),a=2*(n.w*n.z+n.x*n.y),I=1-2*(n.y*n.y+n.z*n.z),r=Math.atan2(a,I),B=(i+Math.PI)/(2*Math.PI),o=(g+Math.PI)/(2*Math.PI),Q=(r+Math.PI)/(2*Math.PI),C=Math.round(255*B),E=Math.round(255*o);return Math.round(255*Q)<<16|E<<8|C},encodeQuatOctXy88R8:ht,encodeQuatXyz888:function(A){const n=A.w<0;return 255&Vn(n?-A.x:A.x)|(255&Vn(n?-A.y:A.y))<<8|(255&Vn(n?-A.z:A.z))<<16},encodeSh1Rgb:function(A,n,t){const e=2*n;for(let n=0;n<9;++n){const i=127&Math.max(-63,Math.min(63,63*t[n])),s=7*n,g=s+7,a=Math.floor(s/32),I=s-32*a,r=i<<I&4294967295;if(A[e+a]|=r,g>32*a+32){const n=i>>>32-I&4294967295;A[e+a+1]|=n}}},encodeSh2Rgb:function(A,n,t){A[4*n+0]=dt(t[0],t[1],t[2],t[3]),A[4*n+1]=dt(t[4],t[5],t[6],t[7]),A[4*n+2]=dt(t[8],t[9],t[10],t[11]),A[4*n+3]=dt(t[12],t[13],t[14],0)},encodeSh3Rgb:function(A,n,t){const e=4*n;for(let n=0;n<21;++n){const i=63&Math.max(-31,Math.min(31,31*t[n])),s=6*n,g=s+6,a=Math.floor(s/32),I=s-32*a,r=i<<I&4294967295;if(A[e+a]|=r,g>32*a+32){const n=i>>>32-I&4294967295;A[e+a+1]|=n}}},epsilonSign:function(A,n=.001){return Math.abs(A)<n?0:Math.sign(A)},flipPixels:It,floatBitsToUint:function(A){return zn[0]=A,Zn[0]},floatToSint8:Vn,floatToUint8:Wn,fromHalf:On,getArrayBuffers:$n,getTextureSize:it,isAndroid:gt,isMobile:st,isOculus:at,mapFilterObject:function(A,n){const t=Object.entries(A).map((([A,t])=>[A,n(t,A)])).filter((([A,n])=>void 0!==n));return Object.fromEntries(t)},mapObject:function(A,n){const t=Object.entries(A).map((([A,t])=>[A,n(t,A)]));return Object.fromEntries(t)},newArray:function(A,n){return new Array(A).fill(null).map(((A,t)=>n(t)))},omitUndefined:function(A){return Object.fromEntries(Object.entries(A).filter((([A,n])=>void 0!==n)))},pixelsToPngUrl:rt,setPackedSplat:nt,setPackedSplatCenter:function(A,n,t,e,i){const s=Pn(t),g=Pn(e),a=Pn(i),I=4*n;A[I+1]=s|g<<16,A[I+2]=a|4294901760&A[I+2]},setPackedSplatOpacity:function(A,n,t){const e=Wn(t),i=4*n;A[i]=16777215&A[i]|e<<24},setPackedSplatQuat:function(A,n,t,i,s,g){const a=ht(new e.Quaternion(t,i,s,g)),I=255&a,r=a>>>8&255,B=a>>>16&255,o=4*n;A[o+2]=65535&A[o+2]|I<<16|r<<24,A[o+3]=16777215&A[o+3]|B<<24},setPackedSplatRgb:function(A,n,t,e,i){const s=Wn(t),g=Wn(e),a=Wn(i),I=4*n;A[I]=s|g<<8|a<<16|4278190080&A[I]},setPackedSplatRgba:function(A,n,t,e,i,s){const g=Wn(t),a=Wn(e),I=Wn(i),r=Wn(s);A[4*n]=g|a<<8|I<<16|r<<24},setPackedSplatScales:function(A,n,t,e,i){const s=0===t?0:Math.min(255,Math.max(0,Math.round((Math.log(t)-r)/B)+1)),g=0===e?0:Math.min(255,Math.max(0,Math.round((Math.log(e)-r)/B)+1)),a=0===i?0:Math.min(255,Math.max(0,Math.round((Math.log(i)-r)/B)+1)),I=4*n;A[I+3]=s|g<<8|a<<16|4278190080&A[I+3]},toHalf:Pn,uintBitsToFloat:function(A){return Zn[0]=A,zn[0]},unpackSplat:et,withinCoinciDist:function({matrix1:A,matrix2:n,maxDistance:t,minCoincidence:e}){const{distance:i,coincidence:s}=Et(A,n);return i<=t&&(null==e||s>=e)},withinCoorientDist:lt,withinDist:function({matrix1:A,matrix2:n,maxDistance:t}){const i=new e.Vector3(0,0,0).applyMatrix4(A),s=new e.Vector3(0,0,0).applyMatrix4(n);return i.distanceTo(s)<=t}},Symbol.toStringTag,{value:"Module"}));class wt{constructor({graph:A,inputs:n,outputs:t,template:e}){this.graph=A,this.template=e,this.inputs=n??{},this.outputs=t??{};const i=new K({indent:this.template.indent});for(const A in this.outputs)this.outputs[A]&&i.declares.add(this.outputs[A]);const s=A.compile({inputs:this.inputs,outputs:this.outputs,compile:i});this.shader=e.generate({globals:i.globals,statements:s}),this.uniforms=i.uniforms,this.updaters=i.updaters}prepareMaterial(){return function(A){let n=mt.get(A);if(n)return n;return n=new e.RawShaderMaterial({glslVersion:e.GLSL3,vertexShader:ot,fragmentShader:A.shader,uniforms:A.uniforms}),mt.set(A,n),n}(this)}update(){for(const A of this.updaters)A()}}class ft{constructor(A){const n=A.match(/^([ \t]*)\{\{\s*GLOBALS\s*\}\}/m),t=A.match(/^([ \t]*)\{\{\s*STATEMENTS\s*\}\}/m);if(!n||!t)throw new Error("Template must contain {{ GLOBALS }} and {{ STATEMENTS }}");this.before=A.substring(0,n.index),this.between=A.substring(n.index+n[0].length,t.index),this.after=A.substring(t.index+t[0].length),this.indent=t[1]}generate({globals:A,statements:n}){return this.before+Array.from(A).join("\n\n")+this.between+n.map((A=>this.indent+A)).join("\n")+this.after}}const mt=new Map;function St(A,n,t="add"){const e=()=>{throw new Error(`Invalid ${t} types: ${A}, ${n}`)};if(A===n)return A;if("int"===A){if(l(n))return n;e()}if("int"===n){if(l(A))return A;e()}if("uint"===A){if(h(n))return n;e()}if("uint"===n){if(h(A))return A;e()}if("float"===A){if(p(n))return n;e()}if("float"===n){if(p(A))return A;e()}throw new Error(`Invalid ${t} types: ${A}, ${n}`)}function xt(A,n){return St(A,n,"sub")}function Ft(A,n){const t=()=>{throw new Error(`Invalid mul types: ${A}, ${n}`)};if("int"===A){if(l(n))return n;t()}if("int"===n){if(l(A))return A;t()}if("uint"===A){if(h(n))return n;t()}if("uint"===n){if(h(A))return A;t()}if("float"===A){if(p(n))return n;t()}if("float"===n){if(p(A))return A;t()}if(l(A)||h(A)||l(n)||h(n)){if(A===n)return A;t()}if("vec2"===A){if("vec2"===n||f(n))return"vec2";if("mat3x2"===n)return"vec3";if("mat4x2"===n)return"vec4";t()}if("vec3"===A){if("mat2x3"===n)return"vec2";if("vec3"===n||m(n))return"vec3";if("mat4x3"===n)return"vec4";t()}if("vec4"===A){if("mat2x4"===n)return"vec2";if("mat3x4"===n)return"vec3";if("vec4"===n||S(n))return"vec4";t()}if("vec2"===n){if(f(A))return"vec2";if("mat2x3"===A)return"vec3";if("mat2x4"===A)return"vec4";t()}if("vec3"===n){if("mat3x2"===A)return"vec2";if(m(A))return"vec3";if("mat3x4"===A)return"vec4";t()}if("vec4"===n){if("mat4x2"===A)return"vec2";if("mat4x3"===A)return"vec3";if(S(A))return"vec4";t()}if(f(A)){if(f(n))return"mat2";if("mat3x2"===n)return"mat3x2";if("mat4x2"===n)return"mat4x2";t()}if("mat2x3"===A){if(f(n))return"mat2x3";if("mat3x2"===n)return"mat3";if("mat4x2"===n)return"mat4x3";t()}if("mat2x4"===A){if(f(n))return"mat2x4";if("mat3x2"===n)return"mat3x4";if("mat4x2"===n)return"mat4";t()}if("mat3x2"===A){if("mat2x3"===n)return"mat2";if(m(n))return"mat3x2";if("mat4x3"===n)return"mat4x2";t()}if(m(A)){if("mat2x3"===n)return"mat2x3";if(m(n))return"mat3";if("mat4x3"===n)return"mat4x3";t()}if("mat3x4"===A){if("mat2x3"===n)return"mat2x4";if(m(n))return"mat3x4";if("mat4x3"===n)return"mat4";t()}if("mat4x2"===A){if("mat2x4"===n)return"mat2";if("mat3x4"===n)return"mat3x2";if(S(n))return"mat4x2";t()}if("mat4x3"===A){if("mat2x4"===n)return"mat2x3";if("mat3x4"===n)return"mat3";if(S(n))return"mat4x3";t()}if(S(A)){if("mat2x4"===n)return"mat2x4";if("mat3x4"===n)return"mat3x4";if(S(n))return"mat4";t()}throw new Error(`Invalid mul types: ${A}, ${n}`)}function Gt(A,n){return St(A,n,"div")}function kt(A,n){if(A===n)return A;if("int"===A){if(l(n))return n}else if("int"===n){if(l(A))return A}else if("uint"===A){if(h(n))return n}else if("uint"===n&&h(A))return A;throw new Error(`Invalid imod types: ${A}, ${n}`)}function Nt(A,n){if(A===n||"float"===n)return A;throw new Error(`Invalid mod types: ${A}, ${n}`)}function Mt(A){return A}function Rt(A){return A}function bt(A){return A}function Ut(A){return A}function vt(A){return A}function Lt(A){return A}function Yt(A){return A}function Jt(A){return A}function Ht(A){return A}function Tt(A){return A}function qt(A){return A}function Kt(A){return A}function _t(A){return A}function zt(A){return A}function Zt(A){return A}function Pt(A){return A}function Ot(A,n,t="min"){if(A===n)return A;if("float"===n){if(u(A))return A}else if("int"===n){if(l(A))return A}else if("uint"===n&&h(A))return A;throw new Error(`Invalid ${t} types: ${A}, ${n}`)}function Wt(A,n){return Ot(A,n,"max")}function Vt(A,n,t){if("float"===n){if(u(A))return A}else if("int"===n){if(l(A))return A}else if("uint"===n&&h(A))return A;throw new Error(`Invalid clamp types: ${A}, ${n}`)}function jt(A,n,t){if(t===A)return A;if("float"===t)return A;if("bool"===t&&"float"===A)return A;if("bvec2"===t&&"vec2"===A)return A;if("bvec3"===t&&"vec3"===A)return A;if("bvec4"===t&&"vec4"===A)return A;throw new Error(`Invalid mix types: ${A}, ${n}, ${t}`)}function Xt(A,n){if(A===n||"float"===n)return n;throw new Error(`Invalid step types: ${A}, ${n}`)}function $t(A,n,t){if(A===n&&(A===t||"float"===A))return t;throw new Error(`Invalid smoothstep types: ${A}, ${n}, ${t}`)}function Ae(A,n="isNan"){if("float"===A)return"bool";if("vec2"===A)return"bvec2";if("vec3"===A)return"bvec3";if("vec4"===A)return"bvec4";throw new Error(`Invalid ${n} types: ${A}`)}function ne(A){return Ae(A,"isInf")}const te=(A,n)=>new Qe({a:A,b:n}),ee=(A,n)=>new Ce({a:A,b:n}),ie=(A,n)=>new Ee({a:A,b:n}),se=(A,n)=>new ce({a:A,b:n}),ge=(A,n)=>new le({a:A,b:n}),ae=(A,n)=>new he({a:A,b:n}),Ie=A=>new de({a:A}),re=A=>new Se({a:A}),Be=(A,n)=>new ve({a:A,b:n}),oe=(A,n,t)=>new Ye({a:A,b:n,t});class Qe extends X{constructor({a:A,b:n}){super({a:A,b:n,outKey:"sum",outTypeFunc:St}),this.statements=({inputs:A,outputs:n})=>[`${n.sum} = ${A.a} + ${A.b};`]}}class Ce extends X{constructor({a:A,b:n}){super({a:A,b:n,outKey:"difference",outTypeFunc:xt}),this.statements=({inputs:A,outputs:n})=>[`${n.difference} = ${A.a} - ${A.b};`]}}class Ee extends X{constructor({a:A,b:n}){super({a:A,b:n,outKey:"product",outTypeFunc:Ft}),this.statements=({inputs:A,outputs:n})=>[`${n.product} = ${A.a} * ${A.b};`]}}class ce extends X{constructor({a:A,b:n}){super({a:A,b:n,outKey:"quotient",outTypeFunc:Gt}),this.statements=({inputs:A,outputs:n})=>[`${n.quotient} = ${A.a} / ${A.b};`]}}class le extends X{constructor({a:A,b:n}){super({a:A,b:n,outKey:"remainder",outTypeFunc:kt}),this.statements=({inputs:A,outputs:n})=>[`${n.remainder} = ${A.a} % ${A.b};`]}}class he extends X{constructor({a:A,b:n}){super({a:A,b:n,outKey:"remainder",outTypeFunc:Nt}),this.statements=({inputs:A,outputs:n})=>[`${n.remainder} = mod(${A.a}, ${A.b});`]}}class ue extends _{constructor({a:A}){const n={a:b(A)},t=n.a;super({inTypes:n,outTypes:{fract:t,integer:t},inputs:{a:A}}),this.statements=({inputs:A,outputs:n})=>[`${n.fract} = modf(${A.a}, ${n.integer});`]}}class de extends j{constructor({a:A}){super({a:A,outKey:"neg",outTypeFunc:Mt}),this.statements=({inputs:A,outputs:n})=>[`${n.neg} = -${A.a};`]}}class pe extends j{constructor({a:A}){super({a:A,outKey:"abs",outTypeFunc:Rt}),this.statements=({inputs:A,outputs:n})=>[`${n.abs} = abs(${A.a});`]}}class ye extends j{constructor({a:A}){super({a:A,outKey:"sign",outTypeFunc:bt}),this.statements=({inputs:A,outputs:n})=>[`${n.sign} = sign(${A.a});`]}}class De extends j{constructor({a:A}){super({a:A,outKey:"floor",outTypeFunc:Ut}),this.statements=({inputs:A,outputs:n})=>[`${n.floor} = floor(${A.a});`]}}class we extends j{constructor({a:A}){super({a:A,outKey:"ceil",outTypeFunc:vt}),this.statements=({inputs:A,outputs:n})=>[`${n.ceil} = ceil(${A.a});`]}}class fe extends j{constructor({a:A}){super({a:A,outKey:"trunc",outTypeFunc:Lt}),this.statements=({inputs:A,outputs:n})=>[`${n.trunc} = trunc(${A.a});`]}}class me extends j{constructor({a:A}){super({a:A,outKey:"round",outTypeFunc:Yt}),this.statements=({inputs:A,outputs:n})=>[`${n.round} = round(${A.a});`]}}class Se extends j{constructor({a:A}){super({a:A,outKey:"fract",outTypeFunc:Jt}),this.statements=({inputs:A,outputs:n})=>[`${n.fract} = fract(${A.a});`]}}class xe extends X{constructor({a:A,b:n}){super({a:A,b:n,outKey:"power",outTypeFunc:Ht}),this.statements=({inputs:A,outputs:n})=>[`${n.power} = pow(${A.a}, ${A.b});`]}}class Fe extends j{constructor({a:A}){super({a:A,outKey:"exp",outTypeFunc:Tt}),this.statements=({inputs:A,outputs:n})=>[`${n.exp} = exp(${A.a});`]}}class Ge extends j{constructor({a:A}){super({a:A,outKey:"exp2",outTypeFunc:qt}),this.statements=({inputs:A,outputs:n})=>[`${n.exp2} = exp2(${A.a});`]}}class ke extends j{constructor({a:A}){super({a:A,outKey:"log",outTypeFunc:Kt}),this.statements=({inputs:A,outputs:n})=>[`${n.log} = log(${A.a});`]}}class Ne extends j{constructor({a:A}){super({a:A,outKey:"log2",outTypeFunc:_t}),this.statements=({inputs:A,outputs:n})=>[`${n.log2} = log2(${A.a});`]}}class Me extends j{constructor({a:A}){super({a:A,outKey:"sqr",outTypeFunc:zt}),this.statements=({inputs:A,outputs:n})=>[`${n.sqr} = ${A.a} * ${A.a};`]}}class Re extends j{constructor({a:A}){super({a:A,outKey:"sqrt",outTypeFunc:Zt}),this.statements=({inputs:A,outputs:n})=>[`${n.sqrt} = sqrt(${A.a});`]}}class be extends j{constructor({a:A}){super({a:A,outKey:"inversesqrt",outTypeFunc:Pt}),this.statements=({inputs:A,outputs:n})=>[`${n.inversesqrt} = inversesqrt(${A.a});`]}}class Ue extends X{constructor({a:A,b:n}){super({a:A,b:n,outKey:"min",outTypeFunc:Ot}),this.statements=({inputs:A,outputs:n})=>[`${n.min} = min(${A.a}, ${A.b});`]}}class ve extends X{constructor({a:A,b:n}){super({a:A,b:n,outKey:"max",outTypeFunc:Wt}),this.statements=({inputs:A,outputs:n})=>[`${n.max} = max(${A.a}, ${A.b});`]}}class Le extends ${constructor({a:A,min:n,max:t}){super({a:A,b:n,c:t,outKey:"clamp",outTypeFunc:Vt}),this.statements=({inputs:A,outputs:n})=>{const{a:t,b:e,c:i}=A;return[`${n.clamp} = clamp(${t}, ${e}, ${i});`]}}}class Ye extends ${constructor({a:A,b:n,t}){super({a:A,b:n,c:t,outKey:"mix",outTypeFunc:jt}),this.statements=({inputs:A,outputs:n})=>{const{a:t,b:e,c:i}=A;return[`${n.mix} = mix(${t}, ${e}, ${i});`]}}}class Je extends X{constructor({edge:A,x:n}){super({a:A,b:n,outKey:"step",outTypeFunc:Xt}),this.statements=({inputs:A,outputs:n})=>{const{a:t,b:e}=A;return[`${n.step} = step(${t}, ${e});`]}}}class He extends ${constructor({edge0:A,edge1:n,x:t}){super({a:A,b:n,c:t,outKey:"smoothstep",outTypeFunc:$t}),this.statements=({inputs:A,outputs:n})=>{const{a:t,b:e,c:i}=A;return[`${n.smoothstep} = smoothstep(${t}, ${e}, ${i});`]}}}class Te extends j{constructor({a:A}){super({a:A,outKey:"isNan",outTypeFunc:Ae}),this.statements=({inputs:A,outputs:n})=>[`${n.isNan} = isNan(${A.a});`]}}class qe extends j{constructor({a:A}){super({a:A,outKey:"isInf",outTypeFunc:ne}),this.statements=({inputs:A,outputs:n})=>[`${n.isInf} = isInf(${A.a});`]}}const Ke=(A,n)=>new Xe({a:A,b:n}),_e=(A,n,t)=>new ei({cond:A,t:n,f:t});class ze extends X{constructor({a:A,b:n}){super({a:A,b:n,outTypeFunc:(A,n)=>A,outKey:"and"}),this.statements=({inputs:A,outputs:n})=>"bool"===this.outTypes.and?[`${n.and} = ${A.a} && ${A.b};`]:[`${n.and} = ${A.a} & ${A.b};`]}}class Ze extends X{constructor({a:A,b:n}){super({a:A,b:n,outTypeFunc:(A,n)=>A,outKey:"or"}),this.statements=({inputs:A,outputs:n})=>"bool"===this.outTypes.or?[`${n.or} = ${A.a} || ${A.b};`]:[`${n.or} = ${A.a} | ${A.b};`]}}class Pe extends X{constructor({a:A,b:n}){super({a:A,b:n,outTypeFunc:(A,n)=>A,outKey:"xor"}),this.statements=({inputs:A,outputs:n})=>"bool"===this.outTypes.xor?[`${n.xor} = ${A.a} ^^ ${A.b};`]:[`${n.xor} = ${A.a} ^ ${A.b};`]}}class Oe extends j{constructor({a:A}){super({a:A,outTypeFunc:A=>A,outKey:"not"}),this.statements=({inputs:A,outputs:n})=>"bool"===this.outTypes.not?[`${n.not} = !${A.a};`]:[`${n.not} = not(${A.a});`]}}class We extends X{constructor({a:A,b:n}){super({a:A,b:n,outTypeFunc:(A,n)=>ii(A,"lessThan"),outKey:"lessThan"}),this.statements=({inputs:A,outputs:n})=>"bool"===this.outTypes.lessThan?[`${n.lessThan} = ${A.a} < ${A.b};`]:[`${n.lessThan} = lessThan(${A.a}, ${A.b});`]}}class Ve extends X{constructor({a:A,b:n}){super({a:A,b:n,outTypeFunc:(A,n)=>ii(A,"lessThanEqual"),outKey:"lessThanEqual"}),this.statements=({inputs:A,outputs:n})=>"bool"===this.outTypes.lessThanEqual?[`${n.lessThanEqual} = ${A.a} <= ${A.b};`]:[`${n.lessThanEqual} = lessThanEqual(${A.a}, ${A.b});`]}}class je extends X{constructor({a:A,b:n}){super({a:A,b:n,outTypeFunc:(A,n)=>ii(A,"greaterThan"),outKey:"greaterThan"}),this.statements=({inputs:A,outputs:n})=>"bool"===this.outTypes.greaterThan?[`${n.greaterThan} = ${A.a} > ${A.b};`]:[`${n.greaterThan} = greaterThan(${A.a}, ${A.b});`]}}class Xe extends X{constructor({a:A,b:n}){super({a:A,b:n,outTypeFunc:(A,n)=>ii(A,"greaterThanEqual"),outKey:"greaterThanEqual"}),this.statements=({inputs:A,outputs:n})=>"bool"===this.outTypes.greaterThanEqual?[`${n.greaterThanEqual} = ${A.a} >= ${A.b};`]:[`${n.greaterThanEqual} = greaterThanEqual(${A.a}, ${A.b});`]}}class $e extends X{constructor({a:A,b:n}){super({a:A,b:n,outTypeFunc:si,outKey:"equal"}),this.statements=({inputs:A,outputs:n})=>"bool"===this.outTypes.equal?[`${n.equal} = ${A.a} == ${A.b};`]:[`${n.equal} = equal(${A.a}, ${A.b});`]}}class Ai extends X{constructor({a:A,b:n}){super({a:A,b:n,outTypeFunc:gi,outKey:"notEqual"}),this.statements=({inputs:A,outputs:n})=>"bool"===this.outTypes.notEqual?[`${n.notEqual} = ${A.a} != ${A.b};`]:[`${n.notEqual} = notEqual(${A.a}, ${A.b});`]}}class ni extends j{constructor({a:A}){super({a:A,outTypeFunc:A=>"bool",outKey:"any"}),this.statements=({inputs:A,outputs:n})=>[`${n.any} = any(${A.a});`]}}class ti extends j{constructor({a:A}){super({a:A,outTypeFunc:A=>"bool",outKey:"all"}),this.statements=({inputs:A,outputs:n})=>[`${n.all} = all(${A.a});`]}}class ei extends ${constructor({cond:A,t:n,f:t}){super({a:A,b:n,c:t,outKey:"select",outTypeFunc:(A,n,t)=>n}),this.statements=({inputs:A,outputs:n})=>{const{a:t,b:e,c:i}=A;return[`${n.select} = (${t}) ? (${e}) : (${i});`]}}}function ii(A,n){if(c(A))return"bool";if("ivec2"===A||"uvec2"===A||"vec2"===A)return"bvec2";if("ivec3"===A||"uvec3"===A||"vec3"===A)return"bvec3";if("ivec4"===A||"uvec4"===A||"vec4"===A)return"bvec4";throw new Error(`Invalid ${n} type: ${A}`)}function si(A,n="equal"){if(c(A))return"bool";if(E(A))return A;if("ivec2"===A||"uvec2"===A||"vec2"===A)return"bvec2";if("ivec3"===A||"uvec3"===A||"vec3"===A)return"bvec3";if("ivec4"===A||"uvec4"===A||"vec4"===A)return"bvec4";throw new Error(`Invalid ${n} type: ${A}`)}function gi(A){return si(A,"notEqual")}class ai extends j{constructor({a:A}){const n=function(A){if(E(A))return"bool";if(l(A))return"int";if(h(A))return"uint";throw new Error(`Invalid compXor type: ${A}`)}(b(A));super({a:A,outTypeFunc:A=>n,outKey:"compXor"}),this.statements=({inputs:A,outputs:t})=>{if(c(this.outTypes.compXor))return[`${t.compXor} = ${A.a};`];const e=(y(n)?["x","y"]:D(n)?["x","y","z"]:["x","y","z","w"]).map((n=>`${A.a}.${n}`)),i=E(n)?"^^":"^";return[`${t.compXor} = ${e.join(` ${i} `)};`]}}}const Ii=A=>new di({value:A}),ri=A=>new Gi({value:A}),Bi=A=>new ki({value:A}),oi=A=>new Ni({value:A}),Qi=A=>new Ui({value:A}),Ci=A=>new Ki({value:A}),Ei=A=>new zi({value:A});class ci extends j{constructor({value:A,outType:n,outKey:t}){super({a:A,outTypeFunc:()=>n,outKey:t}),this.statements=({inputs:A,outputs:e})=>[`${e[t]} = ${k(n)}(${A.a});`]}}class li extends ci{constructor({value:A}){super({value:A,outType:"bool",outKey:"bool"})}}class hi extends ci{constructor({value:A}){super({value:A,outType:"int",outKey:"int"})}}class ui extends ci{constructor({value:A}){super({value:A,outType:"uint",outKey:"uint"})}}class di extends ci{constructor({value:A}){super({value:A,outType:"float",outKey:"float"})}}class pi extends ci{constructor({value:A}){super({value:A,outType:"bvec2",outKey:"bvec2"})}}class yi extends ci{constructor({value:A}){super({value:A,outType:"bvec3",outKey:"bvec3"})}}class Di extends ci{constructor({value:A}){super({value:A,outType:"bvec4",outKey:"bvec4"})}}class wi extends ci{constructor({value:A}){super({value:A,outType:"ivec2",outKey:"ivec2"})}}class fi extends ci{constructor({value:A}){super({value:A,outType:"ivec3",outKey:"ivec3"})}}class mi extends ci{constructor({value:A}){super({value:A,outType:"ivec4",outKey:"ivec4"})}}class Si extends ci{constructor({value:A}){super({value:A,outType:"uvec2",outKey:"uvec2"})}}class xi extends ci{constructor({value:A}){super({value:A,outType:"uvec3",outKey:"uvec3"})}}class Fi extends ci{constructor({value:A}){super({value:A,outType:"uvec4",outKey:"uvec4"})}}class Gi extends ci{constructor({value:A}){super({value:A,outType:"vec2",outKey:"vec2"})}}class ki extends ci{constructor({value:A}){super({value:A,outType:"vec3",outKey:"vec3"})}}class Ni extends ci{constructor({value:A}){super({value:A,outType:"vec4",outKey:"vec4"})}}class Mi extends ci{constructor({value:A}){super({value:A,outType:"mat2",outKey:"mat2"})}}class Ri extends ci{constructor({value:A}){super({value:A,outType:"mat3",outKey:"mat3"})}}class bi extends ci{constructor({value:A}){super({value:A,outType:"mat4",outKey:"mat4"})}}class Ui extends j{constructor({value:A}){super({a:A,outKey:"int",outTypeFunc:()=>"int"}),this.statements=({inputs:A,outputs:n})=>[`${n.int} = floatBitsToInt(${A.a});`]}}class vi extends j{constructor({value:A}){super({a:A,outKey:"uint",outTypeFunc:()=>"uint"}),this.statements=({inputs:A,outputs:n})=>[`${n.uint} = floatBitsToUint(${A.a});`]}}class Li extends j{constructor({value:A}){super({a:A,outKey:"float",outTypeFunc:()=>"float"}),this.statements=({inputs:A,outputs:n})=>[`${n.float} = intBitsToFloat(${A.a});`]}}class Yi extends j{constructor({value:A}){super({a:A,outKey:"float",outTypeFunc:()=>"float"}),this.statements=({inputs:A,outputs:n})=>[`${n.float} = uintBitsToFloat(${A.a});`]}}class Ji extends j{constructor({value:A}){super({a:A,outKey:"uint",outTypeFunc:()=>"uint"}),this.statements=({inputs:A,outputs:n})=>[`${n.uint} = packSnorm2x16(${A.a});`]}}class Hi extends j{constructor({value:A}){super({a:A,outKey:"vec2",outTypeFunc:()=>"vec2"}),this.statements=({inputs:A,outputs:n})=>[`${n.vec2} = unpackSnorm2x16(${A.a});`]}}class Ti extends j{constructor({value:A}){super({a:A,outKey:"uint",outTypeFunc:()=>"uint"}),this.statements=({inputs:A,outputs:n})=>[`${n.uint} = packUnorm2x16(${A.a});`]}}class qi extends j{constructor({value:A}){super({a:A,outKey:"vec2",outTypeFunc:()=>"vec2"}),this.statements=({inputs:A,outputs:n})=>[`${n.vec2} = unpackUnorm2x16(${A.a});`]}}class Ki extends j{constructor({value:A}){super({a:A,outKey:"uint",outTypeFunc:()=>"uint"}),this.statements=({inputs:A,outputs:n})=>[`${n.uint} = packHalf2x16(${A.a});`]}}class _i extends j{constructor({value:A}){super({a:A,outKey:"vec2",outTypeFunc:()=>"vec2"}),this.statements=({inputs:A,outputs:n})=>[`${n.vec2} = unpackHalf2x16(${A.a});`]}}class zi extends j{constructor({value:A}){super({a:A,outKey:"rgba8",outTypeFunc:()=>"vec4"}),this.statements=({inputs:A,outputs:n})=>[`uvec4 uRgba = uvec4(${A.a} & 0xffu, (${A.a} >> 8u) & 0xffu, (${A.a} >> 16u) & 0xffu, (${A.a} >> 24u) & 0xffu);`,`${n.rgba8} = vec4(uRgba) / 255.0;`]}}const Zi=(A,n)=>new $i({a:A,b:n}),Pi=A=>new ns({a:A}),Oi=A=>new Es({vector:A}),Wi=({vector:A,vectorType:n,x:t,y:e,z:i,w:s,r:g,g:a,b:I,a:r})=>new cs({vector:A,vectorType:n,x:t,y:e,z:i,w:s,r:g,g:a,b:I,a:r}),Vi=(A,n)=>new es({a:A,b:n});class ji extends j{constructor({a:A}){super({a:A,outTypeFunc:A=>"float",outKey:"length"}),this.statements=({inputs:A,outputs:n})=>[`${n.length} = length(${A.a});`]}}class Xi extends X{constructor({a:A,b:n}){super({a:A,b:n,outKey:"distance",outTypeFunc:(A,n)=>"float"}),this.statements=({inputs:A,outputs:n})=>[`${n.distance} = distance(${A.a}, ${A.b});`]}}class $i extends X{constructor({a:A,b:n}){super({a:A,b:n,outKey:"dot",outTypeFunc:(A,n)=>"float"}),this.statements=({inputs:A,outputs:n})=>[`${n.dot} = dot(${A.a}, ${A.b});`]}}class As extends X{constructor({a:A,b:n}){super({a:A,b:n,outKey:"cross",outTypeFunc:(A,n)=>"vec3"}),this.statements=({inputs:A,outputs:n})=>[`${n.cross} = cross(${A.a}, ${A.b});`]}}class ns extends j{constructor({a:A}){super({a:A,outTypeFunc:A=>A,outKey:"normalize"}),this.statements=({inputs:A,outputs:n})=>[`${n.normalize} = normalize(${A.a});`]}}class ts extends j{constructor({a:A}){super({a:A,outTypeFunc:A=>function(A){if("vec3"===A)return"vec2";if("vec4"===A)return"vec3";throw new Error("Invalid type")}(A),outKey:"projected"}),this.statements=({inputs:A,outputs:n})=>{if("vec3"===this.inTypes.a)return[`${n.projected} = ${A.a}.xy / ${A.a}.z;`];if("vec4"===this.inTypes.a)return[`${n.projected} = ${A.a}.xyz / ${A.a}.w;`];throw new Error("Invalid type")}}}class es extends X{constructor({a:A,b:n}){const t=function(A){if("float"===A)return"vec2";if("vec2"===A)return"vec3";if("vec3"===A)return"vec4";throw new Error("Invalid type")}(b(A));super({a:A,b:n,outKey:"extend",outTypeFunc:()=>t}),this.statements=({inputs:A,outputs:n})=>[`${n.extend} = ${t}(${A.a}, ${A.b});`]}}class is extends ${constructor({a:A,b:n,c:t}){super({a:A,b:n,c:t,outKey:"forward",outTypeFunc:(A,n,t)=>A}),this.statements=({inputs:A,outputs:n})=>[`${n.forward} = faceforward(${A.a}, ${A.b}, ${A.c});`]}}class ss extends X{constructor({incident:A,normal:n}){super({a:A,b:n,outKey:"reflection",outTypeFunc:(A,n)=>A}),this.statements=({inputs:A,outputs:n})=>[`${n.reflection} = reflect(${A.a}, ${A.b});`]}}class gs extends ${constructor({incident:A,normal:n,eta:t}){super({a:A,b:n,c:t,outKey:"refraction",outTypeFunc:(A,n,t)=>A}),this.statements=({inputs:A,outputs:n})=>[`${n.refraction} = refract(${A.a}, ${A.b}, ${A.c});`]}}class as extends X{constructor({a:A,b:n}){super({a:A,b:n,outKey:"product",outTypeFunc:(A,n)=>A}),this.statements=({inputs:t,outputs:e})=>[`${e.product} = matrixCompMult(${A}, ${n});`]}}function Is(A,n){if("vec2"===A){if("vec2"===n)return"mat2";if("vec3"===n)return"mat3x2";if("vec4"===n)return"mat4x2"}if("vec3"===A){if("vec2"===n)return"mat2x3";if("vec3"===n)return"mat3";if("vec4"===n)return"mat4x3"}if("vec4"===A){if("vec2"===n)return"mat2x4";if("vec3"===n)return"mat3x4";if("vec4"===n)return"mat4"}throw new Error(`Invalid outer type: ${A}, ${n}`)}class rs extends X{constructor({a:A,b:n}){super({a:A,b:n,outKey:"outer",outTypeFunc:Is}),this.statements=({inputs:A,outputs:n})=>[`${n.outer} = outerProduct(${A.a}, ${A.b});`]}}function Bs(A){if("mat2"===A)return"mat2";if("mat3"===A)return"mat3";if("mat4"===A)return"mat4";if("mat2x2"===A)return"mat2x2";if("mat2x3"===A)return"mat3x2";if("mat2x4"===A)return"mat4x2";if("mat3x2"===A)return"mat2x3";if("mat3x3"===A)return"mat3x3";if("mat3x4"===A)return"mat4x3";if("mat4x2"===A)return"mat2x4";if("mat4x3"===A)return"mat3x4";if("mat4x4"===A)return"mat4x4";throw new Error(`Invalid transpose type: ${A}`)}class os extends j{constructor({a:A}){super({a:A,outKey:"transpose",outTypeFunc:Bs}),this.statements=({inputs:A,outputs:n})=>[`${n.transpose} = transpose(${A.a});`]}}class Qs extends j{constructor({a:A}){super({a:A,outKey:"det",outTypeFunc:A=>"float"}),this.statements=({inputs:A,outputs:n})=>[`${n.det} = determinant(${A.a});`]}}class Cs extends j{constructor({a:A}){super({a:A,outKey:"inverse",outTypeFunc:A=>A}),this.statements=({inputs:n,outputs:t})=>[`${t.inverse} = inverse(${A});`]}}class Es extends _{constructor({vector:A}){const n={vector:b(A)},t=function(A){switch(A){case"vec2":return{x:"float",y:"float",r:"float",g:"float"};case"vec3":return{x:"float",y:"float",z:"float",r:"float",g:"float",b:"float"};case"vec4":return{x:"float",y:"float",z:"float",w:"float",r:"float",g:"float",b:"float",a:"float"};case"ivec2":return{x:"int",y:"int",r:"int",g:"int"};case"ivec3":return{x:"int",y:"int",z:"int",r:"int",g:"int",b:"int"};case"ivec4":return{x:"int",y:"int",z:"int",w:"int",r:"int",g:"int",b:"int",a:"int"};case"uvec2":return{x:"uint",y:"uint",r:"uint",g:"uint"};case"uvec3":return{x:"uint",y:"uint",z:"uint",r:"uint",g:"uint",b:"uint"};case"uvec4":return{x:"uint",y:"uint",z:"uint",w:"uint",r:"uint",g:"uint",b:"uint",a:"uint"};default:throw new Error(`Invalid vector type: ${A}`)}}(n.vector);super({inTypes:n,outTypes:t,inputs:{vector:A}}),this.statements=({inputs:A,outputs:n})=>{const{x:t,y:e,z:i,w:s,r:g,g:a,b:I,a:r}=n,{vector:B}=A;return[t?`${t} = ${B}.x;`:null,e?`${e} = ${B}.y;`:null,i?`${i} = ${B}.z;`:null,s?`${s} = ${B}.w;`:null,g?`${g} = ${B}.r;`:null,a?`${a} = ${B}.g;`:null,I?`${I} = ${B}.b;`:null,r?`${r} = ${B}.a;`:null].filter(Boolean)}}}class cs extends _{constructor({vector:A,vectorType:n,x:t,y:e,z:i,w:s,r:g,g:a,b:I,a:r}){if(!A&&!n)throw new Error("Either vector or vectorType must be provided");const B=n??b(A),o=x(B),Q=F(B),C={vector:B,x:o,y:o,r:o,g:o},E={vector:A,x:t,y:e,r:g,g:a};Q>=3&&(Object.assign(C,{z:o,b:o}),Object.assign(E,{z:i,b:I})),Q>=4&&(Object.assign(C,{w:o,a:o}),Object.assign(E,{w:s,a:r})),super({inTypes:C,outTypes:{vector:B},inputs:E}),this.statements=({inputs:A,outputs:n})=>{const{vector:t}=n,{vector:e,x:i,y:s,z:g,w:a,r:I,g:r,b:B,a:C}=A,E=[`${t}.x = ${i??I??(e?`${e}.x`:T(o))};`,`${t}.y = ${s??r??(e?`${e}.y`:T(o))};`];return Q>=3&&E.push(`${t}.z = ${g??B??(e?`${e}.z`:T(o))};`),Q>=4&&E.push(`${t}.w = ${a??C??(e?`${e}.w`:T(o))};`),E}}dynoOut(){return new v(this,"vector")}}class ls extends j{constructor({vector:A,select:n}){super({a:A,outKey:"swizzle",outTypeFunc:A=>function(A,n){let t=null;if(u(A)?t=1===n.length?"float":2===n.length?"vec2":3===n.length?"vec3":4===n.length?"vec4":null:l(A)?t=1===n.length?"int":2===n.length?"ivec2":3===n.length?"ivec3":4===n.length?"ivec4":null:h(A)&&(t=1===n.length?"uint":2===n.length?"uvec2":3===n.length?"uvec3":4===n.length?"uvec4":null),null==t)throw new Error(`Invalid swizzle: ${n}`);return t}(A,n)}),this.statements=({inputs:A,outputs:t})=>[`${t.swizzle} = ${A.a}.${n};`]}}const hs=A=>new Fs({value:A}),us=A=>new Gs({value:A}),ds=A=>new ks({value:A}),ps=A=>new Ns({value:A}),ys=A=>new bs({value:A}),Ds=A=>new Us({value:A}),ws=(A,n,t)=>new vs({z:A,zNear:n,zFar:t}).outputs.depth;class fs extends _{constructor({from:A,to:n,index:t}){super({inTypes:{from:"int",to:"int",index:"int"},outTypes:{index:"int"},inputs:{from:A,to:n,index:t},statements:({inputs:A,outputs:n})=>[`${n.index} = ${A.index} - ${A.from} + ${A.to};`]})}dynoOut(){return new v(this,"index")}}class ms extends _{constructor({state:A}){const n=b(A);super({inTypes:{state:n},outTypes:{state:"uint"},inputs:{state:A},globals:()=>[V("\n          uint pcg_next(uint state) {\n            return state * 747796405u + 2891336453u;\n          }\n        ")],statements:({inputs:A,outputs:t})=>{const e="uint"===n?`${A.state}`:"int"===n?`uint(${A.state})`:`floatBitsToUint(${A.state})`;return[`${t.state} = pcg_next(${e});`]}})}dynoOut(){return new v(this,"state")}}class Ss extends _{constructor({state:A}){super({inTypes:{state:"uint"},outTypes:{hash:"uint"},inputs:{state:A},globals:()=>[V("\n          uint pcg_hash(uint state) {\n            uint hash = ((state >> ((state >> 28u) + 4u)) ^ state) * 277803737u;\n            return (hash >> 22u) ^ hash;\n          }\n        ")],statements:({inputs:A,outputs:n})=>[`${n.hash} = pcg_hash(${A.state});`]})}dynoOut(){return new v(this,"hash")}}class xs extends _{constructor({value:A}){const n=b(A),t=G(n);super({inTypes:{value:n},outTypes:{state:"uint"},inputs:{value:A},globals:()=>[V("\n          uint pcg_mix(uint value) {\n            return value;\n          }\n          uint pcg_mix(uvec2 value) {\n            return value.x + 0x9e3779b9u * value.y;\n          }\n          uint pcg_mix(uvec3 value) {\n            return value.x + 0x9e3779b9u * value.y + 0x85ebca6bu * value.z;\n          }\n          uint pcg_mix(uvec4 value) {\n            return value.x + 0x9e3779b9u * value.y + 0x85ebca6bu * value.z + 0xc2b2ae35u * value.w;\n          }\n        ")],statements:({inputs:A,outputs:e})=>{const i=h(n)?`${A.value}`:l(n)?`${t}(${A.value})`:`floatBitsToUint(${A.value})`;return[`${t} bits = ${i};`,`${e.state} = pcg_mix(bits);`]}})}dynoOut(){return new v(this,"state")}}class Fs extends z{constructor({value:A}){super({inTypes:{value:b(A)},outTypes:{hash:"uint"},inputs:{value:A},construct:({value:A})=>{if(!A)throw new Error("value is required");let n=new xs({value:A}).outputs.state;return n=new ms({state:n}).outputs.state,new Ss({state:n}).outputs}})}dynoOut(){return new v(this,"hash")}}class Gs extends z{constructor({value:A}){super({inTypes:{value:b(A)},outTypes:{hash:"uvec2"},inputs:{value:A},construct:({value:A})=>{if(!A)throw new Error("value is required");let n=new xs({value:A}).outputs.state;n=new ms({state:n}).outputs.state;const t=new Ss({state:n}).outputs.hash;n=new ms({state:n}).outputs.state;const e=new Ss({state:n}).outputs.hash;return{hash:Wi({vectorType:"uvec2",x:t,y:e})}}})}dynoOut(){return new v(this,"hash")}}class ks extends z{constructor({value:A}){super({inTypes:{value:b(A)},outTypes:{hash:"uvec3"},inputs:{value:A},construct:({value:A})=>{if(!A)throw new Error("value is required");let n=new xs({value:A}).outputs.state;n=new ms({state:n}).outputs.state;const t=new Ss({state:n}).outputs.hash;n=new ms({state:n}).outputs.state;const e=new Ss({state:n}).outputs.hash;n=new ms({state:n}).outputs.state;const i=new Ss({state:n}).outputs.hash;return{hash:Wi({vectorType:"uvec3",x:t,y:e,z:i})}}})}dynoOut(){return new v(this,"hash")}}class Ns extends z{constructor({value:A}){super({inTypes:{value:b(A)},outTypes:{hash:"uvec4"},inputs:{value:A},construct:({value:A})=>{if(!A)throw new Error("value is required");let n=new xs({value:A}).outputs.state;n=new ms({state:n}).outputs.state;const t=new Ss({state:n}).outputs.hash;n=new ms({state:n}).outputs.state;const e=new Ss({state:n}).outputs.hash;n=new ms({state:n}).outputs.state;const i=new Ss({state:n}).outputs.hash;n=new ms({state:n}).outputs.state;const s=new Ss({state:n}).outputs.hash;return{hash:Wi({vectorType:"uvec4",x:t,y:e,z:i,w:s})}}})}dynoOut(){return new v(this,"hash")}}class Ms extends z{constructor({value:A}){super({inTypes:{value:b(A)},outTypes:{hash:"float"},inputs:{value:A},construct:({value:A})=>{if(!A)throw new Error("value is required");const n=hs(A);return{hash:ie(Ii(n),H("float",1/2**32))}}})}dynoOut(){return new v(this,"hash")}}class Rs extends z{constructor({value:A}){super({inTypes:{value:b(A)},outTypes:{hash:"vec2"},inputs:{value:A},construct:({value:A})=>{if(!A)throw new Error("value is required");const n=us(A);return{hash:ie(ri(n),H("float",1/2**32))}}})}dynoOut(){return new v(this,"hash")}}class bs extends z{constructor({value:A}){super({inTypes:{value:b(A)},outTypes:{hash:"vec3"},inputs:{value:A},construct:({value:A})=>{if(!A)throw new Error("value is required");const n=ds(A);return{hash:ie(Bi(n),H("float",1/2**32))}}})}dynoOut(){return new v(this,"hash")}}class Us extends z{constructor({value:A}){super({inTypes:{value:b(A)},outTypes:{hash:"vec4"},inputs:{value:A},construct:({value:A})=>{if(!A)throw new Error("value is required");const n=ps(A);return{hash:ie(oi(n),H("float",1/2**32))}}})}dynoOut(){return new v(this,"hash")}}class vs extends _{constructor({z:A,zNear:n,zFar:t}){super({inTypes:{z:"float",zNear:"float",zFar:"float"},outTypes:{depth:"float"},inputs:{z:A,zNear:n,zFar:t},statements:({inputs:A,outputs:n})=>[`float clamped = clamp(${A.z}, ${A.zNear}, ${A.zFar});`,`${n.depth} = (log2(clamped + 1.0) - log2(${A.zNear} + 1.0)) / (log2(${A.zFar} + 1.0) - log2(${A.zNear} + 1.0));`]})}dynoOut(){return new v(this,"depth")}}const Ls=(A,{scale:n,scales:t,rotate:e,translate:i})=>new Js({position:A,scale:n,scales:t,rotate:e,translate:i}).outputs.position,Ys=(A,{scale:n,scales:t,rotate:e})=>new Hs({dir:A,scale:n,scales:t,rotate:e}).outputs.dir;class Js extends _{constructor({position:A,scale:n,scales:t,rotate:e,translate:i}){super({inTypes:{position:"vec3",scale:"float",scales:"vec3",rotate:"vec4",translate:"vec3"},outTypes:{position:"vec3"},inputs:{position:A,scale:n,scales:t,rotate:e,translate:i},statements:({inputs:A,outputs:n})=>{const{position:t}=n;if(!t)return[];const{scale:e,scales:i,rotate:s,translate:g}=A;return[`${t} = ${A.position??"vec3(0.0, 0.0, 0.0)"};`,e?`${t} *= ${e};`:null,i?`${t} *= ${i};`:null,s?`${t} = quatVec(${s}, ${t});`:null,g?`${t} += ${g};`:null].filter(Boolean)}})}}class Hs extends _{constructor({dir:A,scale:n,scales:t,rotate:e}){super({inTypes:{dir:"vec3",scale:"float",scales:"vec3",rotate:"vec4"},outTypes:{dir:"vec3"},inputs:{dir:A,scale:n,scales:t,rotate:e},statements:({inputs:A,outputs:n})=>{const{dir:t}=n;if(!t)return[];const{scale:e,scales:i,rotate:s}=A;return[`${t} = ${A.dir??"vec3(0.0, 0.0, 0.0)"};`,e?`${t} *= ${e};`:null,i?`${t} *= ${i};`:null,s?`${t} = quatVec(${s}, ${t});`:null].filter(Boolean)}})}}class Ts extends _{constructor({quaternion:A,rotate:n}){super({inTypes:{quaternion:"vec4",rotate:"vec4"},outTypes:{quaternion:"vec4"},inputs:{quaternion:A,rotate:n},statements:({inputs:A,outputs:t})=>{const{quaternion:e}=t;return e?[`${e} = ${A.quaternion??"vec4(0.0, 0.0, 0.0, 1.0)"};`,n?`${e} = quatQuat(${A.rotate}, ${e});`:null].filter(Boolean):[]}})}}class qs extends _{constructor({texture:A,lod:n}){const t=b(A);super({inTypes:{texture:t,lod:"int"},outTypes:{size:zs(t)},inputs:{texture:A,lod:n},statements:({inputs:A,outputs:n})=>[`${n.size} = textureSize(${A.texture}, ${A.lod??"0"});`]})}dynoOut(){return new v(this,"size")}}class Ks extends _{constructor({texture:A,coord:n,bias:t}){const e=b(A);super({inTypes:{texture:e,coord:Zs(e),bias:"float"},outTypes:{sample:Ps(e)},inputs:{texture:A,coord:n,bias:t},statements:({inputs:A,outputs:n})=>[`${n.sample} = texture(${A.texture}, ${A.coord}${A.bias?`, ${A.bias}`:""});`]})}dynoOut(){return new v(this,"sample")}}class _s extends _{constructor({texture:A,coord:n,lod:t}){const e=b(A);super({inTypes:{texture:e,coord:zs(e),lod:"int"},outTypes:{texel:Ps(e)},inputs:{texture:A,coord:n,lod:t},statements:({inputs:A,outputs:n})=>[`${n.texel} = texelFetch(${A.texture}, ${A.coord}, ${A.lod??"0"});`]})}dynoOut(){return new v(this,"texel")}}function zs(A){switch(A){case"sampler2D":case"usampler2D":case"isampler2D":case"samplerCube":case"usamplerCube":case"isamplerCube":case"sampler2DShadow":case"samplerCubeShadow":return"ivec2";case"sampler3D":case"usampler3D":case"isampler3D":case"sampler2DArray":case"usampler2DArray":case"isampler2DArray":case"sampler2DArrayShadow":return"ivec3";default:throw new Error(`Invalid texture type: ${A}`)}}function Zs(A){switch(A){case"sampler2D":case"usampler2D":case"isampler2D":return"vec2";case"sampler3D":case"usampler3D":case"isampler3D":case"samplerCube":case"usamplerCube":case"isamplerCube":case"sampler2DArray":case"usampler2DArray":case"isampler2DArray":case"sampler2DShadow":return"vec3";case"samplerCubeShadow":case"sampler2DArrayShadow":return"vec4";default:throw new Error(`Invalid texture type: ${A}`)}}function Ps(A){switch(A){case"sampler2D":case"sampler2DArray":case"sampler3D":case"samplerCube":case"sampler2DShadow":return"vec4";case"usampler2D":case"usampler2DArray":case"usampler3D":case"usamplerCube":return"uvec4";case"isampler2D":case"isampler2DArray":case"isampler3D":case"isamplerCube":return"ivec4";case"samplerCubeShadow":case"sampler2DArrayShadow":return"float";default:throw new Error(`Invalid texture type: ${A}`)}}const Os=A=>new js({radians:A});class Ws extends j{constructor({degrees:A}){super({a:A,outTypeFunc:A=>A,outKey:"radians"}),this.statements=({inputs:A,outputs:n})=>[`${n.radians} = radians(${A.a});`]}}class Vs extends j{constructor({radians:A}){super({a:A,outTypeFunc:A=>A,outKey:"degrees"}),this.statements=({inputs:A,outputs:n})=>[`${n.degrees} = degrees(${A.a});`]}}class js extends j{constructor({radians:A}){super({a:A,outTypeFunc:A=>A,outKey:"sin"}),this.statements=({inputs:A,outputs:n})=>[`${n.sin} = sin(${A.a});`]}}class Xs extends j{constructor({radians:A}){super({a:A,outTypeFunc:A=>A,outKey:"cos"}),this.statements=({inputs:A,outputs:n})=>[`${n.cos} = cos(${A.a});`]}}class $s extends j{constructor({radians:A}){super({a:A,outTypeFunc:A=>A,outKey:"tan"}),this.statements=({inputs:A,outputs:n})=>[`${n.tan} = tan(${A.a});`]}}class Ag extends j{constructor({sin:A}){super({a:A,outTypeFunc:A=>A,outKey:"asin"}),this.statements=({inputs:A,outputs:n})=>[`${n.asin} = asin(${A.a});`]}}class ng extends j{constructor({cos:A}){super({a:A,outTypeFunc:A=>A,outKey:"acos"}),this.statements=({inputs:A,outputs:n})=>[`${n.acos} = acos(${A.a});`]}}class tg extends j{constructor({tan:A}){super({a:A,outTypeFunc:A=>A,outKey:"atan"}),this.statements=({inputs:A,outputs:n})=>[`${n.atan} = atan(${A.a});`]}}class eg extends X{constructor({y:A,x:n}){super({a:A,b:n,outTypeFunc:(A,n)=>A,outKey:"atan2"}),this.statements=({inputs:A,outputs:n})=>[`${n.atan2} = atan2(${A.a}, ${A.b});`]}}class ig extends j{constructor({x:A}){super({a:A,outTypeFunc:A=>A,outKey:"sinh"}),this.statements=({inputs:A,outputs:n})=>[`${n.sinh} = sinh(${A.a});`]}}class sg extends j{constructor({x:A}){super({a:A,outTypeFunc:A=>A,outKey:"cosh"}),this.statements=({inputs:A,outputs:n})=>[`${n.cosh} = cosh(${A.a});`]}}class gg extends j{constructor({x:A}){super({a:A,outTypeFunc:A=>A,outKey:"tanh"}),this.statements=({inputs:A,outputs:n})=>[`${n.tanh} = tanh(${A.a});`]}}class ag extends j{constructor({x:A}){super({a:A,outTypeFunc:A=>A,outKey:"asinh"}),this.statements=({inputs:A,outputs:n})=>[`${n.asinh} = asinh(${A.a});`]}}class Ig extends j{constructor({x:A}){super({a:A,outTypeFunc:A=>A,outKey:"acosh"}),this.statements=({inputs:A,outputs:n})=>[`${n.acosh} = acosh(${A.a});`]}}class rg extends j{constructor({x:A}){super({a:A,outTypeFunc:A=>A,outKey:"atanh"}),this.statements=({inputs:A,outputs:n})=>[`${n.atanh} = atanh(${A.a});`]}}const Bg=Object.freeze(Object.defineProperty({__proto__:null,Abs:pe,Acos:ng,Acosh:Ig,Add:Qe,All:ti,And:ze,Any:ni,Asin:Ag,Asinh:ag,Atan:tg,Atan2:eg,Atanh:rg,BVec2:pi,BVec3:yi,BVec4:Di,BinaryOp:X,Bool:li,Ceil:we,Clamp:Le,Combine:cs,CombineGsplat:cA,CompMult:as,CompXor:ai,Compilation:K,Cos:Xs,Cosh:sg,Cross:As,Degrees:Vs,Determinant:Qs,Distance:Xi,Div:ce,Dot:$i,Dyno:_,DynoBlock:z,DynoBool:mA,DynoBvec2:GA,DynoBvec3:RA,DynoBvec4:LA,DynoConst:J,DynoFloat:FA,DynoInt:xA,DynoIsampler2D:An,DynoIsampler2DArray:en,DynoIsampler3D:an,DynoIsamplerCube:Bn,DynoIvec2:NA,DynoIvec3:UA,DynoIvec4:JA,DynoLiteral:L,DynoMat2:TA,DynoMat2x2:qA,DynoMat2x3:KA,DynoMat2x4:_A,DynoMat3:zA,DynoMat3x2:ZA,DynoMat3x3:PA,DynoMat3x4:OA,DynoMat4:WA,DynoMat4x2:VA,DynoMat4x3:jA,DynoMat4x4:XA,DynoOutput:v,DynoProgram:wt,DynoProgramTemplate:ft,DynoRemapIndex:fs,DynoSampler2D:nn,DynoSampler2DArray:sn,DynoSampler2DArrayShadow:Cn,DynoSampler2DShadow:Qn,DynoSampler3D:In,DynoSamplerCube:on,DynoSamplerCubeShadow:En,DynoUint:SA,DynoUniform:fA,DynoUsampler2D:$A,DynoUsampler2DArray:tn,DynoUsampler3D:gn,DynoUsamplerCube:rn,DynoUvec2:kA,DynoUvec3:bA,DynoUvec4:YA,DynoValue:U,DynoVec2:MA,DynoVec3:vA,DynoVec4:HA,Equal:$e,Exp:Fe,Exp2:Ge,ExtendVec:es,FaceForward:is,Float:di,FloatBitsToInt:Ui,FloatBitsToUint:vi,Floor:De,Fract:Se,GreaterThan:je,GreaterThanEqual:Xe,Gsplat:AA,GsplatNormal:hA,Hash:Fs,Hash2:Gs,Hash3:ks,Hash4:Ns,HashFloat:Ms,HashVec2:Rs,HashVec3:bs,HashVec4:Us,IMod:le,IVec2:wi,IVec3:fi,IVec4:mi,Int:hi,IntBitsToFloat:Li,Inverse:Cs,InverseSqrt:be,IsInf:qe,IsNan:Te,Length:ji,LessThan:We,LessThanEqual:Ve,Log:ke,Log2:Ne,Mat2:Mi,Mat3:Ri,Mat4:bi,Max:ve,Min:Ue,Mix:Ye,Mod:he,Modf:ue,Mul:Ee,Neg:de,Normalize:ns,NormalizedDepth:vs,Not:Oe,NotEqual:Ai,NumPackedSplats:BA,Or:Ze,Outer:rs,OutputPackedSplat:pA,OutputRgba8:yA,PackHalf2x16:Ki,PackSnorm2x16:Ji,PackUnorm2x16:Ti,PcgHash:Ss,PcgMix:xs,PcgNext:ms,Pow:xe,ProjectH:ts,Radians:Ws,ReadPackedSplat:QA,ReadPackedSplatRange:CA,ReflectVec:ss,RefractVec:gs,Round:me,Select:ei,Sign:ye,SimpleCast:ci,Sin:js,Sinh:ig,Smoothstep:He,Split:Es,SplitGsplat:EA,Sqr:Me,Sqrt:Re,Step:Je,Sub:Ce,Swizzle:ls,TPackedSplats:nA,Tan:$s,Tanh:gg,TexelFetch:_s,Texture:Ks,TextureSize:qs,TransformDir:Hs,TransformGsplat:uA,TransformPosition:Js,TransformQuaternion:Ts,Transpose:os,TrinaryOp:$,Trunc:fe,UVec2:Si,UVec3:xi,UVec4:Fi,Uint:ui,UintBitsToFloat:Yi,UintToRgba8:zi,UnaryOp:j,UnpackHalf2x16:_i,UnpackSnorm2x16:Hi,UnpackUnorm2x16:qi,Vec2:Gi,Vec3:ki,Vec4:Ni,Xor:Pe,abs:A=>new pe({a:A}),acos:A=>new ng({cos:A}),acosh:A=>new Ig({x:A}),add:te,all:A=>new ti({a:A}),and:(A,n)=>new ze({a:A,b:n}),any:A=>new ni({a:A}),arrayIndex:()=>{throw new Error("Not implemented")},arrayLength:()=>{throw new Error("Not implemented")},asin:A=>new Ag({sin:A}),asinh:A=>new ag({x:A}),atan:A=>new tg({tan:A}),atan2:(A,n)=>new eg({y:A,x:n}),atanh:A=>new rg({x:A}),bool:A=>new li({value:A}),bvec2:A=>new pi({value:A}),bvec3:A=>new yi({value:A}),bvec4:A=>new Di({value:A}),ceil:A=>new we({a:A}),clamp:(A,n,t)=>new Le({a:A,min:n,max:t}),combine:Wi,combineGsplat:sA,comment:()=>{throw new Error("Not implemented")},compMult:(A,n)=>new as({a:A,b:n}),compXor:A=>new ai({a:A}),cos:A=>new Xs({radians:A}),cosh:A=>new sg({x:A}),cross:(A,n)=>new As({a:A,b:n}),defineGsplat:IA,defineGsplatNormal:lA,definePackedSplats:rA,degrees:A=>new Vs({radians:A}),determinant:A=>new Qs({a:A}),distance:(A,n)=>new Xi({a:A,b:n}),div:se,dot:Zi,dyno:P,dynoBlock:Z,dynoBool:(A=!1,n)=>new mA({key:n,value:A}),dynoBvec2:(A,n)=>new GA({key:n,value:A}),dynoBvec3:(A,n)=>new RA({key:n,value:A}),dynoBvec4:(A,n)=>new LA({key:n,value:A}),dynoConst:H,dynoDeclare:O,dynoFloat:DA,dynoFor:()=>{throw new Error("Not implemented")},dynoIf:()=>{throw new Error("Not implemented")},dynoInt:(A=0,n)=>new xA({key:n,value:A}),dynoIsampler2D:(A,n)=>new An({key:n,value:A}),dynoIsampler2DArray:(A,n)=>new en({key:A,value:n}),dynoIsampler3D:(A,n)=>new an({key:n,value:A}),dynoIsamplerCube:(A,n)=>new Bn({key:n,value:A}),dynoIvec2:(A,n)=>new NA({key:n,value:A}),dynoIvec3:(A,n)=>new UA({key:n,value:A}),dynoIvec4:(A,n)=>new JA({key:n,value:A}),dynoLiteral:Y,dynoMat2:(A,n)=>new TA({key:n,value:A}),dynoMat2x2:(A,n)=>new qA({key:n,value:A}),dynoMat2x3:(A,n)=>new KA({key:n,value:A}),dynoMat2x4:(A,n)=>new _A({key:n,value:A}),dynoMat3:(A,n)=>new zA({key:n,value:A}),dynoMat3x2:(A,n)=>new ZA({key:n,value:A}),dynoMat3x3:(A,n)=>new PA({key:n,value:A}),dynoMat3x4:(A,n)=>new OA({key:n,value:A}),dynoMat4:(A,n)=>new WA({key:n,value:A}),dynoMat4x2:(A,n)=>new VA({key:n,value:A}),dynoMat4x3:(A,n)=>new jA({key:n,value:A}),dynoMat4x4:(A,n)=>new XA({key:n,value:A}),dynoSampler2D:(A,n)=>new nn({key:n,value:A}),dynoSampler2DArray:(A,n)=>new sn({key:n,value:A}),dynoSampler2DArrayShadow:(A,n)=>new Cn({key:n,value:A}),dynoSampler2DShadow:(A,n)=>new Qn({key:n,value:A}),dynoSampler3D:(A,n)=>new In({key:n,value:A}),dynoSamplerCube:(A,n)=>new on({key:n,value:A}),dynoSamplerCubeShadow:(A,n)=>new En({key:n,value:A}),dynoSwitch:()=>{throw new Error("Not implemented")},dynoUint:(A=0,n)=>new SA({key:n,value:A}),dynoUsampler2D:(A,n)=>new $A({key:n,value:A}),dynoUsampler2DArray:(A,n)=>new tn({key:n,value:A}),dynoUsampler3D:(A,n)=>new gn({key:n,value:A}),dynoUsamplerCube:(A,n)=>new rn({key:n,value:A}),dynoUvec2:(A,n)=>new kA({key:n,value:A}),dynoUvec3:(A,n)=>new bA({key:n,value:A}),dynoUvec4:(A,n)=>new YA({key:n,value:A}),dynoVec2:(A,n)=>new MA({key:n,value:A}),dynoVec3:wA,dynoVec4:(A,n)=>new HA({key:n,value:A}),equal:(A,n)=>new $e({a:A,b:n}),exp:A=>new Fe({a:A}),exp2:A=>new Ge({a:A}),extendVec:Vi,faceforward:(A,n,t)=>new is({a:A,b:n,c:t}),float:Ii,floatBitsToInt:Qi,floatBitsToUint:A=>new vi({value:A}),floor:A=>new De({a:A}),fract:re,greaterThan:(A,n)=>new je({a:A,b:n}),greaterThanEqual:Ke,gsplatNormal:gA,hash:hs,hash2:us,hash3:ds,hash4:ps,hashFloat:A=>new Ms({value:A}),hashVec2:A=>new Rs({value:A}),hashVec3:ys,hashVec4:Ds,imod:ge,int:A=>new hi({value:A}),intBitsToFloat:A=>new Li({value:A}),inverse:A=>new Cs({a:A}),inversesqrt:A=>new be({a:A}),isAllFloatType:p,isBoolType:E,isFloatType:u,isInf:A=>new qe({a:A}),isIntType:l,isMat2:f,isMat3:m,isMat4:S,isMatFloatType:d,isNan:A=>new Te({a:A}),isScalarType:c,isUintType:h,isVector2Type:y,isVector3Type:D,isVector4Type:w,isVectorType:function(A){return y(A)||D(A)||w(A)},ivec2:A=>new wi({value:A}),ivec3:A=>new fi({value:A}),ivec4:A=>new mi({value:A}),length:A=>new ji({a:A}),lessThan:(A,n)=>new We({a:A,b:n}),lessThanEqual:(A,n)=>new Ve({a:A,b:n}),literalNegOne:function(A){const n=String(A);if(E(A))return`${n}(true)`;if(p(A))return`${n}(-1.0)`;if(l(A))return`${n}(-1)`;if(h(A))return`${n}(0xFFFFFFFFu)`;throw new Error(`Type not implemented: ${n}`)},literalOne:function(A){const n=String(A);if(E(A))return`${n}(true)`;if(p(A))return`${n}(1.0)`;if(l(A))return`${n}(1)`;if(h(A))return`${n}(1u)`;throw new Error(`Type not implemented: ${n}`)},literalZero:T,log:A=>new ke({a:A}),log2:A=>new Ne({a:A}),mat2:A=>new Mi({value:A}),mat3:A=>new Ri({value:A}),mat4:A=>new bi({value:A}),max:Be,min:(A,n)=>new Ue({a:A,b:n}),mix:oe,mod:ae,modf:A=>new ue({a:A}).outputs,mul:ie,neg:Ie,normalize:Pi,normalizedDepth:ws,not:A=>new Oe({a:A}),notEqual:(A,n)=>new Ai({a:A,b:n}),numPackedSplats:A=>new BA({packedSplats:A}),numberAsFloat:R,numberAsInt:N,numberAsUint:M,or:(A,n)=>new Ze({a:A,b:n}),outer:(A,n)=>new rs({a:A,b:n}),outputPackedSplat:dA,outputRgba8:A=>new yA({rgba8:A}),packHalf2x16:Ci,packSnorm2x16:A=>new Ji({value:A}),packUnorm2x16:A=>new Ti({value:A}),pcgHash:A=>new Ss({state:A}),pcgMix:A=>new xs({value:A}),pcgNext:A=>new ms({state:A}),pow:(A,n)=>new xe({a:A,b:n}),projectH:A=>new ts({a:A}),radians:A=>new Ws({degrees:A}),readPackedSplat:tA,readPackedSplatRange:eA,reflectVec:(A,n)=>new ss({incident:A,normal:n}),refractVec:(A,n,t)=>new gs({incident:A,normal:n,eta:t}),remapIndex:(A,n,t)=>new fs({index:A,from:n,to:t}),round:A=>new me({a:A}),sameSizeIvec:function(A){if(c(A))return"int";if(y(A))return"ivec2";if(D(A))return"ivec3";if(w(A))return"ivec4";throw new Error(`Invalid vector type: ${A}`)},sameSizeUvec:G,sameSizeVec:function(A){if(c(A))return"float";if(y(A))return"vec2";if(D(A))return"vec3";if(w(A))return"vec4";throw new Error(`Invalid vector type: ${A}`)},select:_e,sign:A=>new ye({a:A}),sin:Os,sinh:A=>new ig({x:A}),smoothstep:(A,n,t)=>new He({edge0:A,edge1:n,x:t}),split:Oi,splitGsplat:iA,sqr:A=>new Me({a:A}),sqrt:A=>new Re({a:A}),step:(A,n)=>new Je({edge:A,x:n}),sub:ee,swizzle:(A,n)=>new ls({vector:A,select:n}),tan:A=>new $s({radians:A}),tanh:A=>new gg({x:A}),texelFetch:(A,n,t)=>new _s({texture:A,coord:n,lod:t}),texture:(A,n,t)=>new Ks({texture:A,coord:n,bias:t}),textureSize:(A,n)=>new qs({texture:A,lod:n}),transformDir:Ys,transformGsplat:aA,transformPos:Ls,transformQuat:(A,{rotate:n})=>new Ts({quaternion:A,rotate:n}).outputs.quaternion,transpose:A=>new os({a:A}),trunc:A=>new fe({a:A}),typeLiteral:k,uint:A=>new ui({value:A}),uintBitsToFloat:A=>new Yi({value:A}),uintToRgba8:Ei,uniform:(A,n,t)=>new fA({key:A,type:n,value:t}),unindent:V,unindentLines:W,unpackHalf2x16:A=>new _i({value:A}),unpackSnorm2x16:A=>new Hi({value:A}),unpackUnorm2x16:A=>new qi({value:A}),uvec2:A=>new Si({value:A}),uvec3:A=>new xi({value:A}),uvec4:A=>new Fi({value:A}),valType:b,vec2:ri,vec3:Bi,vec4:oi,vectorDim:F,vectorElementType:x,xor:(A,n)=>new Pe({a:A,b:n})},Symbol.toStringTag,{value:"Module"}));const og=class A{constructor({renderer:A}={}){this.renderer=A,this.capacity=0,this.count=0}dispose(){this.target&&(this.target.dispose(),this.target=void 0)}ensureBuffer(A,n){const t=4*(Math.ceil(Math.max(1,A)/o)*o);if(n.byteLength>=t)return n;const e=new ArrayBuffer(t);if(n instanceof ArrayBuffer)return e;return new(0,n.constructor)(e)}ensureCapacity(A){const{width:n,height:t,depth:i,maxSplats:s}=it(A);(!this.target||s>this.capacity)&&(this.dispose(),this.capacity=s,this.target=new e.WebGLArrayRenderTarget(n,t,i,{depthBuffer:!1,stencilBuffer:!1,generateMipmaps:!1,magFilter:e.NearestFilter,minFilter:e.NearestFilter}),this.target.texture.format=e.RGBAFormat,this.target.texture.type=e.UnsignedByteType,this.target.texture.internalFormat="RGBA8",this.target.scissorTest=!0)}prepareProgramMaterial(n){let t=A.readbackProgram.get(n);if(!t){const e=Z({index:"int"},{rgba8:"vec4"},(({index:A})=>{n.inputs.index=A;return{rgba8:new yA({rgba8:n.outputs.rgba8})}}));A.programTemplate||(A.programTemplate=new ft("precision highp float;\nprecision highp int;\nprecision highp sampler2D;\nprecision highp usampler2D;\nprecision highp isampler2D;\nprecision highp sampler2DArray;\nprecision highp usampler2DArray;\nprecision highp isampler2DArray;\nprecision highp sampler3D;\nprecision highp usampler3D;\nprecision highp isampler3D;\n\n#include <splatDefines>\n\nuniform uint targetLayer;\nuniform int targetBase;\nuniform int targetCount;\n\nout vec4 target;\n\n{{ GLOBALS }}\n\nvoid computeReadback(int index) {\n    {{ STATEMENTS }}\n}\n\nvoid main() {\n    int targetIndex = int(targetLayer << SPLAT_TEX_LAYER_BITS) + int(uint(gl_FragCoord.y) << SPLAT_TEX_WIDTH_BITS) + int(gl_FragCoord.x);\n    int index = targetIndex - targetBase;\n\n    if ((index >= 0) && (index < targetCount)) {\n        computeReadback(index);\n    } else {\n        target = vec4(0.0, 0.0, 0.0, 0.0);\n    }\n}")),t=new wt({graph:e,inputs:{index:"index"},outputs:{rgba8:"target"},template:A.programTemplate}),Object.assign(t.uniforms,{targetLayer:{value:0},targetBase:{value:0},targetCount:{value:0}}),A.readbackProgram.set(n,t)}const e=t.prepareMaterial();return A.mesh.material=e,{program:t,material:e}}saveRenderState(A){return{xrEnabled:A.xr.enabled,autoClear:A.autoClear}}resetRenderState(A,n){A.setRenderTarget(null),A.xr.enabled=n.xrEnabled,A.autoClear=n.autoClear}process({count:n,material:t}){const e=this.renderer;if(!e)throw new Error("No renderer");if(!this.target)throw new Error("No target");const i=o*Q;t.uniforms.targetBase.value=0,t.uniforms.targetCount.value=n;let s=0;for(;s<n;){const g=Math.floor(s/i),a=g*i,I=Math.min(Q,Math.ceil((n-a)/o));t.uniforms.targetLayer.value=g,this.target.scissor.set(0,0,o,I),e.setRenderTarget(this.target,g),e.xr.enabled=!1,e.autoClear=!1,e.render(A.scene,A.camera),s+=o*I}this.count=n}async read({readback:A}){const n=this.renderer;if(!n)throw new Error("No renderer");if(!this.target)throw new Error("No target");const t=Math.ceil(this.count/o)*o;if(A.byteLength<4*t)throw new Error(`Readback buffer too small: ${A.byteLength} < ${4*t}`);const e=new Uint8Array(A instanceof ArrayBuffer?A:A.buffer),i=o*Q;let s=0;const g=[];for(;s<this.count;){const A=Math.floor(s/i),t=A*i,a=Math.min(Q,Math.ceil((this.count-t)/o));n.setRenderTarget(this.target,A);const I=o*a*4,r=e.subarray(4*t,4*t+I),B=null==n?void 0:n.readRenderTargetPixelsAsync(this.target,0,0,o,a,r);g.push(B),s+=o*a}return Promise.all(g).then((()=>A))}render({reader:A,count:n,renderer:t}){if(this.renderer=t||this.renderer,!this.renderer)throw new Error("No renderer");this.ensureCapacity(n);const{program:e,material:i}=this.prepareProgramMaterial(A);e.update();const s=this.saveRenderState(this.renderer);this.process({count:n,material:i}),this.resetRenderState(this.renderer,s)}async readback({readback:A}){if(!this.renderer)throw new Error("No renderer");const n=this.saveRenderState(this.renderer),t=this.read({readback:A});return this.resetRenderState(this.renderer,n),t}async renderReadback({reader:A,count:n,renderer:t,readback:e}){if(this.renderer=t||this.renderer,!this.renderer)throw new Error("No renderer");this.ensureCapacity(n);const{program:i,material:s}=this.prepareProgramMaterial(A);i.update();const g=this.saveRenderState(this.renderer);this.process({count:n,material:s});const a=this.read({readback:e});return this.resetRenderState(this.renderer,g),a}getTexture(){var A;return null==(A=this.target)?void 0:A.texture}};og.programTemplate=null,og.readbackProgram=new Map,og.geometry=new e.PlaneGeometry(2,2),og.mesh=new e.Mesh(og.geometry,new e.RawShaderMaterial({visible:!1})),og.scene=(new e.Scene).add(og.mesh),og.camera=new e.Camera;let Qg=og;const Cg=class A{constructor(n={}){this.capacity=0,this.count=0,this.array=null,this.readback=null,this.source=null,this.needsUpdate=!0,this.dyno=new fA({key:"rgbaArray",type:cg,globals:()=>[lg],value:{texture:A.getEmpty(),count:0},update:n=>{var t;return n.texture=(null==(t=this.readback)?void 0:t.getTexture())??this.source??A.getEmpty(),n.count=this.count,n}}),n.array?(this.array=n.array,this.capacity=Math.floor(this.array.length/4),this.capacity=Math.floor(this.capacity/o)*o,this.count=Math.min(this.capacity,n.count??Number.POSITIVE_INFINITY)):(this.capacity=n.capacity??0,this.count=0)}dispose(){this.readback&&(this.readback.dispose(),this.readback=null),this.source&&(this.source.dispose(),this.source=null)}ensureCapacity(A){var n;if(!this.array||A>((null==(n=this.array)?void 0:n.length)??0)/4){this.capacity=it(A).maxSplats;const n=new Uint8Array(4*this.capacity);this.array&&n.set(this.array),this.array=n}return this.array}getTexture(){var n;let t=null==(n=this.readback)?void 0:n.getTexture();return(this.source||this.array)&&(t=this.maybeUpdateSource()),t??A.getEmpty()}maybeUpdateSource(){if(!this.array)throw new Error("No array");if(this.needsUpdate||!this.source){if(this.needsUpdate=!1,this.source){const{width:A,height:n,depth:t}=this.source.image;this.capacity!==A*n*t&&(this.source.dispose(),this.source=null)}if(this.source)this.array.buffer!==this.source.image.data.buffer&&(this.source.image.data=new Uint8Array(this.array.buffer));else{const{width:A,height:n,depth:t}=it(this.capacity);this.source=new e.DataArrayTexture(this.array,A,n,t),this.source.format=e.RGBAFormat,this.source.type=e.UnsignedByteType,this.source.internalFormat="RGBA8",this.source.needsUpdate=!0}this.source.needsUpdate=!0}return this.source}render({reader:A,count:n,renderer:t}){this.readback||(this.readback=new Qg({renderer:t})),this.readback.render({reader:A,count:n,renderer:t}),this.capacity=this.readback.capacity,this.count=this.readback.count}fromPackedSplats({packedSplats:n,base:t,count:e,renderer:i}){const{dynoSplats:s,dynoBase:g,dynoCount:a,reader:I}=A.makeDynos();return s.packedSplats=n,g.value=t,a.value=e,this.render({reader:I,count:e,renderer:i}),this}async read(){if(!this.readback)throw new Error("No readback");(!this.array||this.array.length<4*this.count)&&(this.array=new Uint8Array(4*this.capacity));return(await this.readback.readback({readback:this.array})).subarray(0,4*this.count)}static getEmpty(){if(!A.emptySource){const n=new Uint8Array(4);A.emptySource=new e.DataArrayTexture(n,1,1,1),A.emptySource.format=e.RGBAFormat,A.emptySource.type=e.UnsignedByteType,A.emptySource.internalFormat="RGBA8",A.emptySource.needsUpdate=!0}return A.emptySource}static makeDynos(){if(!A.dynos){const n=new Qa,t=new xA({value:0}),e=new xA({value:0}),i=Z({index:"int"},{rgba8:"vec4"},(({index:A})=>{if(!A)throw new Error("index is undefined");A=te(A,t);const i=eA(n,A,t,e);return{rgba8:iA(i).outputs.rgba}}));A.dynos={dynoSplats:n,dynoBase:t,dynoCount:e,reader:i}}return A.dynos}};Cg.emptySource=null,Cg.dynos=null;let Eg=Cg;const cg={type:"RgbaArray"},lg=V("\n  struct RgbaArray {\n    sampler2DArray texture;\n    int count;\n  };\n");var hg=(A=>(A.ALL="all",A.PLANE="plane",A.SPHERE="sphere",A.BOX="box",A.ELLIPSOID="ellipsoid",A.CYLINDER="cylinder",A.CAPSULE="capsule",A.INFINITE_CONE="infinite_cone",A))(hg||{});function ug(A){switch(A){case"all":return 0;case"plane":return 1;case"sphere":return 2;case"box":return 3;case"ellipsoid":return 4;case"cylinder":return 5;case"capsule":return 6;case"infinite_cone":return 7;default:throw new Error(`Unknown SDF type: ${A}`)}}var dg=(A=>(A.MULTIPLY="multiply",A.SET_RGB="set_rgb",A.ADD_RGBA="add_rgba",A))(dg||{});function pg(A){switch(A){case"multiply":return 0;case"set_rgb":return 1;case"add_rgba":return 2;default:throw new Error(`Unknown blend mode: ${A}`)}}class yg extends e.Object3D{constructor(A={}){super();const{type:n,invert:t,opacity:i,color:s,displace:g,radius:a}=A;this.type=n??"sphere",this.invert=t??!1,this.opacity=i??1,this.color=s??new e.Color(1,1,1),this.displace=g??new e.Vector3(0,0,0),this.radius=a??0}}const Dg=class A extends e.Object3D{constructor(n={}){const{name:t,rgbaBlendMode:e="multiply",sdfSmooth:i=0,softEdge:s=0,invert:g=!1,sdfs:a=null}=n;super(),this.rgbaBlendMode=e,this.sdfSmooth=i,this.softEdge=s,this.invert=g,this.sdfs=a,this.ordering=A.nextOrdering++,this.name=t??`Edit ${this.ordering}`}addSdf(A){null==this.sdfs&&(this.sdfs=[]),this.sdfs.includes(A)||this.sdfs.push(A)}removeSdf(A){null!=this.sdfs&&(this.sdfs=this.sdfs.filter((n=>n!==A)))}};Dg.nextOrdering=1;let wg=Dg;class fg{constructor({maxSdfs:A,maxEdits:n}){this.maxSdfs=Math.max(16,A??0),this.numSdfs=0,this.sdfData=new Uint32Array(8*this.maxSdfs*4),this.sdfFloatData=new Float32Array(this.sdfData.buffer),this.sdfTexture=this.newSdfTexture(this.sdfData,this.maxSdfs),this.dynoSdfArray=new fA({key:"sdfArray",type:mg,globals:()=>[Sg],value:{numSdfs:0,sdfTexture:this.sdfTexture},update:A=>(A.numSdfs=this.numSdfs,A.sdfTexture=this.sdfTexture,A)}),this.maxEdits=Math.max(16,n??0),this.numEdits=0,this.editData=new Uint32Array(4*this.maxEdits),this.editFloatData=new Float32Array(this.editData.buffer),this.dynoNumEdits=new xA({value:0}),this.dynoEdits=this.newEdits(this.editData,this.maxEdits)}newSdfTexture(A,n){const t=new e.DataTexture(A,8,n,e.RGBAIntegerFormat,e.UnsignedIntType);return t.internalFormat="RGBA32UI",t.needsUpdate=!0,t}newEdits(A,n){return new fA({key:"edits",type:"uvec4",count:n,globals:()=>[xg],value:A})}ensureCapacity({maxSdfs:A,maxEdits:n}){let t=!1;return A>this.sdfTexture.image.height&&(this.sdfTexture.dispose(),this.maxSdfs=Math.max(2*this.maxSdfs,A),this.sdfData=new Uint32Array(8*this.maxSdfs*4),this.sdfFloatData=new Float32Array(this.sdfData.buffer),this.sdfTexture=this.newSdfTexture(this.sdfData,this.maxSdfs)),n>(this.dynoEdits.count??0)&&(this.maxEdits=Math.max(2*this.maxEdits,n),this.editData=new Uint32Array(4*this.maxEdits),this.editFloatData=new Float32Array(this.editData.buffer),this.dynoEdits=this.newEdits(this.editData,this.maxEdits),t=!0),t}updateEditData(A,n){const t=this.editData[A]!==n;return this.editData[A]=n,t}updateEditFloatData(A,n){Fg[0]=n;const t=this.editFloatData[A]!==Fg[0];return t&&(this.editFloatData[A]=Fg[0]),t}encodeEdit(A,{sdfFirst:n,sdfCount:t,invert:e,rgbaBlendMode:i,softEdge:s,sdfSmooth:g}){const a=4*A;let I=!1;return I=this.updateEditData(a+0,i|(e?256:0))||I,I=this.updateEditData(a+1,n|t<<16)||I,I=this.updateEditFloatData(a+2,s)||I,I=this.updateEditFloatData(a+3,g)||I,I}updateSdfData(A,n){const t=this.sdfData[A]!==n;return this.sdfData[A]=n,t}updateSdfFloatData(A,n){Fg[0]=n;const t=this.sdfFloatData[A]!==Fg[0];return t&&(this.sdfFloatData[A]=Fg[0]),t}encodeSdf(A,{sdfType:n,invert:t,center:e,quaternion:i,scale:s,sizes:g},a){const I=32*A,r=n|(t?256:0);let B=!1;B=this.updateSdfFloatData(I+0,(null==e?void 0:e.x)??0)||B,B=this.updateSdfFloatData(I+1,(null==e?void 0:e.y)??0)||B,B=this.updateSdfFloatData(I+2,(null==e?void 0:e.z)??0)||B,B=this.updateSdfData(I+3,r)||B,B=this.updateSdfFloatData(I+4,(null==i?void 0:i.x)??0)||B,B=this.updateSdfFloatData(I+5,(null==i?void 0:i.y)??0)||B,B=this.updateSdfFloatData(I+6,(null==i?void 0:i.z)??0)||B,B=this.updateSdfFloatData(I+7,(null==i?void 0:i.w)??0)||B,B=this.updateSdfFloatData(I+8,(null==s?void 0:s.x)??0)||B,B=this.updateSdfFloatData(I+9,(null==s?void 0:s.y)??0)||B,B=this.updateSdfFloatData(I+10,(null==s?void 0:s.z)??0)||B,B=this.updateSdfData(I+11,0)||B,B=this.updateSdfFloatData(I+12,(null==g?void 0:g.x)??0)||B,B=this.updateSdfFloatData(I+13,(null==g?void 0:g.y)??0)||B,B=this.updateSdfFloatData(I+14,(null==g?void 0:g.z)??0)||B,B=this.updateSdfFloatData(I+15,(null==g?void 0:g.w)??0)||B;const o=Math.min(4,a.length);for(let A=0;A<o;++A){const n=I+16+4*A;B=this.updateSdfFloatData(n+0,a[A].x)||B,B=this.updateSdfFloatData(n+1,a[A].y)||B,B=this.updateSdfFloatData(n+2,a[A].z)||B,B=this.updateSdfFloatData(n+3,a[A].w)||B}return B}update(A){const n=A.reduce(((A,{sdfs:n})=>A+n.length),0),t=this.ensureCapacity({maxEdits:A.length,maxSdfs:n}),i=[new e.Vector4,new e.Vector4],s=new e.Vector3,g=new e.Quaternion,a=new e.Vector3,I=new e.Vector4;let r=0,B=t;A.length!==this.dynoNumEdits.value&&(this.dynoNumEdits.value=A.length,this.numEdits=A.length,B=!0);for(const[n,{edit:t,sdfs:e}]of A.entries()){B=this.encodeEdit(n,{sdfFirst:r,sdfCount:e.length,invert:t.invert,rgbaBlendMode:pg(t.rgbaBlendMode),softEdge:t.softEdge,sdfSmooth:t.sdfSmooth})||B;let A=!1;for(const n of e){I.set(n.scale.x,n.scale.y,n.scale.z,n.radius),n.scale.setScalar(1),n.updateMatrixWorld();n.matrixWorld.clone().invert().decompose(s,g,a),n.scale.set(I.x,I.y,I.z),n.updateMatrixWorld(),i[0].set(n.color.r,n.color.g,n.color.b,n.opacity),i[1].set(n.displace.x,n.displace.y,n.displace.z,1),A=this.encodeSdf(r,{sdfType:ug(n.type),invert:n.invert,center:s,quaternion:g,scale:a,sizes:I},i)||A,r+=1}this.numSdfs=r,A&&(this.sdfTexture.needsUpdate=!0),B||(B=A)}return{updated:B,dynoUpdated:t}}modify(A){return function(A,n,t,e){const i=new _({inTypes:{gsplat:AA,sdfArray:mg,numEdits:"int",rgbaDisplaceEdits:"uvec4"},outTypes:{gsplat:AA},globals:()=>[Sg,xg],inputs:{gsplat:A,sdfArray:n,numEdits:t,rgbaDisplaceEdits:e},statements:({inputs:A,outputs:n})=>{const{sdfArray:t,numEdits:e,rgbaDisplaceEdits:i}=A,{gsplat:s}=n;return W(`\n        ${s} = ${A.gsplat};\n        if (isGsplatActive(${s}.flags)) {\n          for (int editIndex = 0; editIndex < ${e}; ++editIndex) {\n            applyPackedRgbaDisplaceEdit(\n              ${i}[editIndex], ${t}.sdfTexture, ${t}.numSdfs,\n              ${s}.center, ${s}.rgba\n            );\n          }\n        }\n      `)}});return i.outputs.gsplat}(A,this.dynoSdfArray,this.dynoNumEdits,this.dynoEdits)}}const mg={type:"SdfArray"},Sg=V("\n  struct SdfArray {\n    int numSdfs;\n    usampler2D sdfTexture;\n  };\n\n  void unpackSdfArray(\n    usampler2D sdfTexture, int sdfIndex, out uint flags,\n    out vec3 center, out vec4 quaternion, out vec3 scale, out vec4 sizes,\n    int numValues, out vec4 values[4]\n  ) {\n    uvec4 temp = texelFetch(sdfTexture, ivec2(0, sdfIndex), 0);\n    flags = temp.w;\n    center = vec3(uintBitsToFloat(temp.x), uintBitsToFloat(temp.y), uintBitsToFloat(temp.z));\n\n    temp = texelFetch(sdfTexture, ivec2(1, sdfIndex), 0);\n    quaternion = vec4(uintBitsToFloat(temp.x), uintBitsToFloat(temp.y), uintBitsToFloat(temp.z), uintBitsToFloat(temp.w));\n\n    temp = texelFetch(sdfTexture, ivec2(2, sdfIndex), 0);\n    scale = vec3(uintBitsToFloat(temp.x), uintBitsToFloat(temp.y), uintBitsToFloat(temp.z));\n\n    temp = texelFetch(sdfTexture, ivec2(3, sdfIndex), 0);\n    sizes = vec4(uintBitsToFloat(temp.x), uintBitsToFloat(temp.y), uintBitsToFloat(temp.z), uintBitsToFloat(temp.w));\n\n    for (int i = 0; i < numValues; ++i) {\n      temp = texelFetch(sdfTexture, ivec2(4 + i, sdfIndex), 0);\n      values[i] = vec4(uintBitsToFloat(temp.x), uintBitsToFloat(temp.y), uintBitsToFloat(temp.z), uintBitsToFloat(temp.w));\n    }\n  }\n\n  const uint SDF_FLAG_TYPE = 0xFFu;\n  const uint SDF_FLAG_INVERT = 1u << 8u;\n\n  const uint SDF_TYPE_ALL = 0u;\n  const uint SDF_TYPE_PLANE = 1u;\n  const uint SDF_TYPE_SPHERE = 2u;\n  const uint SDF_TYPE_BOX = 3u;\n  const uint SDF_TYPE_ELLIPSOID = 4u;\n  const uint SDF_TYPE_CYLINDER = 5u;\n  const uint SDF_TYPE_CAPSULE = 6u;\n  const uint SDF_TYPE_INFINITE_CONE = 7u;\n\n  float evaluateSdfArray(\n    usampler2D sdfTexture, int numSdfs, int sdfFirst, int sdfCount, vec3 pos,\n    float smoothK, int numValues, out vec4 outValues[4]\n  ) {\n    float distanceAccum = (smoothK == 0.0) ? 1.0 / 0.0 : 0.0;\n    float maxExp = -1.0 / 0.0;\n    for (int i = 0; i < numValues; ++i) {\n        outValues[i] = vec4(0.0);\n    }\n\n    uint flags;\n    vec3 center, scale;\n    vec4 quaternion, sizes;\n    vec4 values[4];\n\n    int sdfLast = min(sdfFirst + sdfCount, numSdfs);\n    for (int index = sdfFirst; index < sdfLast; ++index) {\n      unpackSdfArray(sdfTexture, index, flags, center, quaternion, scale, sizes, numValues, values);\n      uint sdfType = flags & SDF_FLAG_TYPE;\n      vec3 sdfPos = quatVec(quaternion, pos * scale) + center;\n\n      float distance;\n      switch (sdfType) {\n        case SDF_TYPE_ALL:\n          distance = -1.0 / 0.0;\n          break;\n        case SDF_TYPE_PLANE: {\n          distance = sdfPos.z;\n          break;\n        }\n        case SDF_TYPE_SPHERE: {\n          distance = length(sdfPos) - sizes.w;\n          break;\n        }\n        case SDF_TYPE_BOX: {\n          vec3 q = abs(sdfPos) - sizes.xyz + sizes.w;\n          distance = length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0) - sizes.w;\n          break;\n        }\n        case SDF_TYPE_ELLIPSOID: {\n          vec3 sizes = sizes.xyz;\n          float k0 = length(sdfPos / sizes);\n          float k1 = length(sdfPos / dot(sizes, sizes));\n          distance = k0 * (k0 - 1.0) / k1;\n          break;\n        }\n        case SDF_TYPE_CYLINDER: {\n          vec2 d = abs(vec2(length(sdfPos.xz), sdfPos.y)) - sizes.wy;\n          distance = min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n          break;\n        }\n        case SDF_TYPE_CAPSULE: {\n          sdfPos.y -= clamp(sdfPos.y, -0.5 * sizes.y, 0.5 * sizes.y);\n          distance = length(sdfPos) - sizes.w;\n          break;\n        }\n        case SDF_TYPE_INFINITE_CONE: {\n          float angle = 0.25 * PI * sizes.w;\n          vec2 c = vec2(sin(angle), cos(angle));\n          vec2 q = vec2(length(sdfPos.xy), -sdfPos.z);\n          float d = length(q - c * max(dot(q, c), 0.0));\n          distance = d * (((q.x * c.y - q.y * c.x) < 0.0) ? -1.0 : 1.0);\n          break;\n        }\n      }\n\n      if ((flags & SDF_FLAG_INVERT) != 0u) {\n        distance = -distance;\n      }\n\n      if (smoothK == 0.0) {\n        if (distance < distanceAccum) {\n          distanceAccum = distance;\n          for (int i = 0; i < numValues; ++i) {\n            outValues[i] = values[i];\n          }\n        }\n      } else {\n        float scaledDistance = -distance / smoothK;\n        if (scaledDistance > maxExp) {\n          float scale = exp(maxExp - scaledDistance);\n          distanceAccum *= scale;\n          for (int i = 0; i < numValues; ++i) {\n            outValues[i] *= scale;\n          }\n          maxExp = scaledDistance;\n        }\n\n        float weight = exp(scaledDistance - maxExp);\n        distanceAccum += weight;\n        for (int i = 0; i < numValues; ++i) {\n          outValues[i] += weight * values[i];\n        }\n      }\n    }\n\n    if (smoothK == 0.0) {\n      return distanceAccum;\n    } else {\n      // Very distant SDFs may result in 0 accumulation\n      if (distanceAccum == 0.0) {\n        return 1.0 / 0.0;\n      }\n      for (int i = 0; i < numValues; ++i) {\n        outValues[i] /= distanceAccum;\n      }\n      return (-log(distanceAccum) - maxExp) * smoothK;\n    }\n  }\n\n  float modulateSdfArray(\n    usampler2D sdfTexture, int numSdfs, int sdfFirst, int sdfCount, vec3 pos,\n    float smoothK, int numValues, out vec4 values[4],\n    float softEdge, bool invert\n  ) {\n    float distance = evaluateSdfArray(sdfTexture, numSdfs, sdfFirst, sdfCount, pos, smoothK, numValues, values);\n    if (invert) {\n      distance = -distance;\n    }\n\n    return (softEdge == 0.0) ? ((distance < 0.0) ? 1.0 : 0.0)\n      : clamp(-distance / softEdge + 0.5, 0.0, 1.0);\n  }\n"),xg=V("\n  const uint EDIT_FLAG_BLEND = 0xFFu;\n  const uint EDIT_BLEND_MULTIPLY = 0u;\n  const uint EDIT_BLEND_SET_RGB = 1u;\n  const uint EDIT_BLEND_ADD_RGBA = 2u;\n  const uint EDIT_FLAG_INVERT = 0x100u;\n\n  void decodeEdit(\n    uvec4 packedEdit, out int sdfFirst, out int sdfCount,\n    out bool invert, out uint rgbaBlendMode, out float softEdge, out float sdfSmooth\n  ) {\n    rgbaBlendMode = packedEdit.x & EDIT_FLAG_BLEND;\n    invert = (packedEdit.x & EDIT_FLAG_INVERT) != 0u;\n\n    sdfFirst = int(packedEdit.y & 0xFFFFu);\n    sdfCount = int(packedEdit.y >> 16u);\n\n    softEdge = uintBitsToFloat(packedEdit.z);\n    sdfSmooth = uintBitsToFloat(packedEdit.w);\n  }\n\n  void applyRgbaDisplaceEdit(\n    usampler2D sdfTexture, int numSdfs, int sdfFirst, int sdfCount, inout vec3 pos,\n    float smoothK, float softEdge, bool invert, uint rgbaBlendMode, inout vec4 rgba\n  ) {\n    vec4 values[4];\n    float modulate = modulateSdfArray(sdfTexture, numSdfs, sdfFirst, sdfCount, pos, smoothK, 2, values, softEdge, invert);\n    // On Android, moving values[0] is necessary to work around a compiler bug.\n    vec4 sdfRgba = values[0];\n    vec4 sdfDisplaceScale = values[1];\n\n    vec4 target;\n    switch (rgbaBlendMode) {\n      case EDIT_BLEND_MULTIPLY:\n        target = rgba * sdfRgba;\n        break;\n      case EDIT_BLEND_SET_RGB:\n        target = vec4(sdfRgba.rgb, rgba.a * sdfRgba.a);\n        break;\n      case EDIT_BLEND_ADD_RGBA:\n        target = rgba + sdfRgba;\n        break;\n      default:\n        // Debug output if blend mode not set\n        target = vec4(fract(pos), 1.0);\n    }\n    rgba = mix(rgba, target, modulate);\n    pos += sdfDisplaceScale.xyz * modulate;\n  }\n\n  void applyPackedRgbaDisplaceEdit(uvec4 packedEdit, usampler2D sdfTexture, int numSdfs, inout vec3 pos, inout vec4 rgba) {\n    int sdfFirst, sdfCount;\n    bool invert;\n    uint rgbaBlendMode;\n    float softEdge, sdfSmooth;\n    decodeEdit(packedEdit, sdfFirst, sdfCount, invert, rgbaBlendMode, softEdge, sdfSmooth);\n    applyRgbaDisplaceEdit(sdfTexture, numSdfs, sdfFirst, sdfCount, pos, sdfSmooth, softEdge, invert, rgbaBlendMode, rgba);\n  }\n");const Fg=new Float32Array(1);class Gg{constructor(A){this.modifier=A,this.cache=new Map}apply(A){let n=this.cache.get(A);return n||(n=Z({index:"int"},{gsplat:AA},(({index:n})=>{const{gsplat:t}=A.apply({index:n});return this.modifier.apply({gsplat:t})})),this.cache.set(A,n)),n}}class kg{constructor(){this.scale=new FA({value:Number.NEGATIVE_INFINITY}),this.rotate=new HA({value:new e.Quaternion(Number.POSITIVE_INFINITY,Number.POSITIVE_INFINITY,Number.POSITIVE_INFINITY,Number.POSITIVE_INFINITY)}),this.translate=new vA({value:new e.Vector3(Number.POSITIVE_INFINITY,Number.POSITIVE_INFINITY,Number.POSITIVE_INFINITY)})}apply(A){return Ls(A,{scale:this.scale,rotate:this.rotate,translate:this.translate})}applyDir(A){return Ys(A,{rotate:this.rotate})}applyGsplat(A){return aA(A,{scale:this.scale,rotate:this.rotate,translate:this.translate})}updateFromMatrix(A){const n=new e.Vector3,t=new e.Quaternion,i=new e.Vector3;A.decompose(i,t,n);const s=(n.x+n.y+n.z)/3;let g=!1;return s!==this.scale.value&&(this.scale.value=s,g=!0),i.equals(this.translate.value)||(this.translate.value.copy(i),g=!0),t.equals(this.rotate.value)||(this.rotate.value.copy(t),g=!0),g}update(A){return A.updateMatrixWorld(),this.updateFromMatrix(A.matrixWorld)}}class Ng extends e.Object3D{constructor({numSplats:A,generator:n,construct:t,update:e}){if(super(),this.numSplats=A??0,this.generator=n,this.frameUpdate=e,this.version=0,t){const A=t(this);Object.assign(this,A)}}updateVersion(){this.version+=1}set needsUpdate(A){A&&this.updateVersion()}}const Mg=class A extends Ng{constructor(A={}){const n={transform:new kg,viewToWorld:new kg,worldToView:new kg,viewToObject:new kg,recolor:new HA({value:new e.Vector4(Number.NEGATIVE_INFINITY,Number.NEGATIVE_INFINITY,Number.NEGATIVE_INFINITY,Number.NEGATIVE_INFINITY)}),time:new FA({value:0}),deltaTime:new FA({value:0})};if(super({update:({time:A,deltaTime:n,viewToWorld:t,globalEdits:e})=>this.update({time:A,deltaTime:n,viewToWorld:t,globalEdits:e})}),this.isInitialized=!1,this.recolor=new e.Color(1,1,1),this.opacity=1,this.enableViewToObject=!1,this.enableViewToWorld=!1,this.enableWorldToView=!1,this.skinning=null,this.edits=null,this.rgbaDisplaceEdits=null,this.splatRgba=null,this.maxSh=3,this.packedSplats=A.packedSplats??new oa,this.numSplats=this.packedSplats.numSplats,this.editable=A.editable??!0,this.onFrame=A.onFrame,this.context=n,this.objectModifier=A.objectModifier,this.worldModifier=A.worldModifier,this.updateGenerator(),A.url||A.fileBytes||A.constructSplats||A.packedSplats&&!A.packedSplats.isInitialized)this.initialized=this.asyncInitialize(A).then((async()=>{if(this.updateGenerator(),this.isInitialized=!0,A.onLoad){const n=A.onLoad(this);n instanceof Promise&&await n}return this}));else if(this.isInitialized=!0,this.initialized=Promise.resolve(this),A.onLoad){const n=A.onLoad(this);n instanceof Promise&&(this.initialized=n.then((()=>this)))}}async asyncInitialize(A){const{url:n,fileBytes:t,fileType:e,fileName:i,maxSplats:s,constructSplats:g}=A;if(n||t||g){const A={url:n,fileBytes:t,fileType:e,fileName:i,maxSplats:s,construct:g};this.packedSplats.reinitialize(A)}this.packedSplats&&(await this.packedSplats.initialized,this.numSplats=this.packedSplats.numSplats,this.updateGenerator())}static async staticInitialize(){await I(),A.isStaticInitialized=!0}pushSplat(A,n,t,e,i){this.packedSplats.pushSplat(A,n,t,e,i)}forEachSplat(A){this.packedSplats.forEachSplat(A)}dispose(){this.packedSplats.dispose()}constructGenerator(A){const{transform:n,viewToObject:t,recolor:e}=A,i=Z({index:"int"},{gsplat:AA},(({index:A})=>{if(!A)throw new Error("index is undefined");let i=tA(this.packedSplats.dyno,A);if(this.maxSh>=1){const{sh1Texture:A,sh2Texture:n,sh3Texture:e}=this.ensureShTextures();if(A){const s=t.translate,{center:g}=iA(i).outputs,a=Pi(ee(g,s));let I=function(A,n,t){return P({inTypes:{gsplat:AA,sh1:"usampler2DArray",viewDir:"vec3"},outTypes:{rgb:"vec3"},inputs:{gsplat:A,sh1:n,viewDir:t},globals:()=>[IA,bg],statements:({inputs:A,outputs:n})=>W(`\n        if (isGsplatActive(${A.gsplat}.flags)) {\n          ${n.rgb} = evaluateSH1(${A.gsplat}, ${A.sh1}, ${A.viewDir});\n        } else {\n          ${n.rgb} = vec3(0.0);\n        }\n      `)}).outputs.rgb}(i,A,a);this.maxSh>=2&&n&&(I=te(I,function(A,n,t){return P({inTypes:{gsplat:AA,sh2:"usampler2DArray",viewDir:"vec3"},outTypes:{rgb:"vec3"},inputs:{gsplat:A,sh2:n,viewDir:t},globals:()=>[IA,Ug],statements:({inputs:A,outputs:n})=>W(`\n        if (isGsplatActive(${A.gsplat}.flags)) {\n          ${n.rgb} = evaluateSH2(${A.gsplat}, ${A.sh2}, ${A.viewDir});\n        } else {\n          ${n.rgb} = vec3(0.0);\n        }\n      `)}).outputs.rgb}(i,n,a))),this.maxSh>=3&&e&&(I=te(I,function(A,n,t){return P({inTypes:{gsplat:AA,sh3:"usampler2DArray",viewDir:"vec3"},outTypes:{rgb:"vec3"},inputs:{gsplat:A,sh3:n,viewDir:t},globals:()=>[IA,vg],statements:({inputs:A,outputs:n})=>W(`\n        if (isGsplatActive(${A.gsplat}.flags)) {\n          ${n.rgb} = evaluateSH3(${A.gsplat}, ${A.sh3}, ${A.viewDir});\n        } else {\n          ${n.rgb} = vec3(0.0);\n        }\n      `)}).outputs.rgb}(i,e,a)));let{rgba:r}=iA(i).outputs;r=te(r,Vi(I,H("float",0))),i=sA({gsplat:i,rgba:r})}}if(this.splatRgba){const n=function(A,n){return new _({inTypes:{rgba:cg,index:"int"},outTypes:{rgba:"vec4"},inputs:{rgba:A,index:n},globals:()=>[lg],statements:({inputs:A,outputs:n})=>W(`\n        if ((index >= 0) && (index < ${A.rgba}.count)) {\n          ${n.rgba} = texelFetch(${A.rgba}.texture, splatTexCoord(index), 0);\n        } else {\n          ${n.rgba} = vec4(0.0, 0.0, 0.0, 0.0);\n        }\n      `)}).outputs.rgba}(this.splatRgba.dyno,A);i=sA({gsplat:i,rgba:n})}this.skinning&&(i=this.skinning.modify(i)),this.objectModifier&&(i=this.objectModifier.apply({gsplat:i}).gsplat),i=n.applyGsplat(i);const s=ie(e,iA(i).outputs.rgba);return i=sA({gsplat:i,rgba:s}),this.rgbaDisplaceEdits&&(i=this.rgbaDisplaceEdits.modify(i)),this.worldModifier&&(i=this.worldModifier.apply({gsplat:i}).gsplat),{gsplat:i}}));this.generator=i}updateGenerator(){this.constructGenerator(this.context)}update({time:n,viewToWorld:t,deltaTime:i,globalEdits:s}){var g;this.numSplats=this.packedSplats.numSplats,this.context.time.value=n,this.context.deltaTime.value=i,A.dynoTime.value=n;const{transform:a,viewToObject:I,recolor:r}=this.context;let B=a.update(this);this.context.viewToWorld.updateFromMatrix(t)&&this.enableViewToWorld&&(B=!0);const o=t.clone().invert();this.context.worldToView.updateFromMatrix(o)&&this.enableWorldToView&&(B=!0);const Q=(new e.Matrix4).compose(a.translate.value,a.rotate.value,(new e.Vector3).setScalar(a.scale.value)).invert().multiply(t);I.updateFromMatrix(Q)&&(this.enableViewToObject||this.packedSplats.extra.sh1)&&(B=!0);const C=new e.Vector4(this.recolor.r,this.recolor.g,this.recolor.b,this.opacity);C.equals(r.value)||(r.value.copy(C),B=!0);const E=this.editable?(this.edits??[]).concat(s):[];this.editable&&!this.edits&&this.traverseVisible((A=>{A instanceof wg&&E.push(A)})),E.sort(((A,n)=>A.ordering-n.ordering));const c=E.map((A=>{if(null!=A.sdfs)return{edit:A,sdfs:A.sdfs};const n=[];return A.traverseVisible((A=>{A instanceof yg&&n.push(A)})),{edit:A,sdfs:n}}));if(c.length>0&&!this.rgbaDisplaceEdits){const A=c.length,n=c.reduce(((A,n)=>A+n.sdfs.length),0);this.rgbaDisplaceEdits=new fg({maxEdits:A,maxSdfs:n}),this.updateGenerator()}if(this.rgbaDisplaceEdits){const A=this.rgbaDisplaceEdits.update(c);B||(B=A.updated),A.dynoUpdated&&this.updateGenerator()}B&&this.updateVersion(),null==(g=this.onFrame)||g.call(this,{mesh:this,time:n,deltaTime:i})}raycast(A,n){if(!this.packedSplats.packedArray||!this.packedSplats.numSplats)return;const{near:t,far:s,ray:g}=A,a=this.matrixWorld.clone().invert(),I=(new e.Matrix3).setFromMatrix4(a),r=g.origin.clone().applyMatrix4(a),B=g.direction.clone().applyMatrix3(I),o=new e.Vector3;a.decompose(new e.Vector3,new e.Quaternion,o),o.x,o.y,o.z;const Q=function(A,n,t,e,s,g,a,I,r,B,o){return i.raycast_splats(A,n,t,e,s,g,a,I,r,B,o)}(r.x,r.y,r.z,B.x,B.y,B.z,t,s,this.packedSplats.numSplats,this.packedSplats.packedArray,!0);for(const A of Q){const t=g.direction.clone().multiplyScalar(A).add(g.origin);n.push({distance:A,point:t,object:this})}}ensureShTextures(){if(!this.packedSplats.extra.sh1)return{};let A=this.packedSplats.extra.sh1Texture;if(!A){let n=this.packedSplats.extra.sh1;const{width:t,height:i,depth:s,maxSplats:g}=it(n.length/2);if(n.length<2*g){const A=new Uint32Array(2*g);A.set(n),this.packedSplats.extra.sh1=A,n=A}const a=new e.DataArrayTexture(n,t,i,s);a.format=e.RGIntegerFormat,a.type=e.UnsignedIntType,a.internalFormat="RG32UI",a.needsUpdate=!0,A=new tn({value:a,key:"sh1"}),this.packedSplats.extra.sh1Texture=A}if(!this.packedSplats.extra.sh2)return{sh1Texture:A};let n=this.packedSplats.extra.sh2Texture;if(!n){let A=this.packedSplats.extra.sh2;const{width:t,height:i,depth:s,maxSplats:g}=it(A.length/4);if(A.length<4*g){const n=new Uint32Array(4*g);n.set(A),this.packedSplats.extra.sh2=n,A=n}const a=new e.DataArrayTexture(A,t,i,s);a.format=e.RGBAIntegerFormat,a.type=e.UnsignedIntType,a.internalFormat="RGBA32UI",a.needsUpdate=!0,n=new tn({value:a,key:"sh2"}),this.packedSplats.extra.sh2Texture=n}if(!this.packedSplats.extra.sh3)return{sh1Texture:A,sh2Texture:n};let t=this.packedSplats.extra.sh3Texture;if(!t){let A=this.packedSplats.extra.sh3;const{width:n,height:i,depth:s,maxSplats:g}=it(A.length/4);if(A.length<4*g){const n=new Uint32Array(4*g);n.set(A),this.packedSplats.extra.sh3=n,A=n}const a=new e.DataArrayTexture(A,n,i,s);a.format=e.RGBAIntegerFormat,a.type=e.UnsignedIntType,a.internalFormat="RGBA32UI",a.needsUpdate=!0,t=new tn({value:a,key:"sh3"}),this.packedSplats.extra.sh3Texture=t}return{sh1Texture:A,sh2Texture:n,sh3Texture:t}}};Mg.staticInitialized=Mg.staticInitialize(),Mg.isStaticInitialized=!1,Mg.dynoTime=new FA({value:0});let Rg=Mg;const bg=V("\n  vec3 evaluateSH1(Gsplat gsplat, usampler2DArray sh1, vec3 viewDir) {\n    // Extract sint7 values packed into 2 x uint32\n    uvec2 packed = texelFetch(sh1, splatTexCoord(gsplat.index), 0).rg;\n    vec3 sh1_0 = vec3(ivec3(\n      int(packed.x << 25u) >> 25,\n      int(packed.x << 18u) >> 25,\n      int(packed.x << 11u) >> 25\n    )) / 63.0;\n    vec3 sh1_1 = vec3(ivec3(\n      int(packed.x << 4u) >> 25,\n      int((packed.x >> 3u) | (packed.y << 29u)) >> 25,\n      int(packed.y << 22u) >> 25\n    )) / 63.0;\n    vec3 sh1_2 = vec3(ivec3(\n      int(packed.y << 15u) >> 25,\n      int(packed.y << 8u) >> 25,\n      int(packed.y << 1u) >> 25\n    )) / 63.0;\n\n    return sh1_0 * (-0.4886025 * viewDir.y)\n      + sh1_1 * (0.4886025 * viewDir.z)\n      + sh1_2 * (-0.4886025 * viewDir.x);\n  }\n"),Ug=V("\n  vec3 evaluateSH2(Gsplat gsplat, usampler2DArray sh2, vec3 viewDir) {\n    // Extract sint8 values packed into 4 x uint32\n    uvec4 packed = texelFetch(sh2, splatTexCoord(gsplat.index), 0);\n    vec3 sh2_0 = vec3(ivec3(\n      int(packed.x << 24u) >> 24,\n      int(packed.x << 16u) >> 24,\n      int(packed.x << 8u) >> 24\n    )) / 127.0;\n    vec3 sh2_1 = vec3(ivec3(\n      int(packed.x) >> 24,\n      int(packed.y << 24u) >> 24,\n      int(packed.y << 16u) >> 24\n    )) / 127.0;\n    vec3 sh2_2 = vec3(ivec3(\n      int(packed.y << 8u) >> 24,\n      int(packed.y) >> 24,\n      int(packed.z << 24u) >> 24\n    )) / 127.0;\n    vec3 sh2_3 = vec3(ivec3(\n      int(packed.z << 16u) >> 24,\n      int(packed.z << 8u) >> 24,\n      int(packed.z) >> 24\n    )) / 127.0;\n    vec3 sh2_4 = vec3(ivec3(\n      int(packed.w << 24u) >> 24,\n      int(packed.w << 16u) >> 24,\n      int(packed.w << 8u) >> 24\n    )) / 127.0;\n\n    return sh2_0 * (1.0925484 * viewDir.x * viewDir.y)\n      + sh2_1 * (-1.0925484 * viewDir.y * viewDir.z)\n      + sh2_2 * (0.3153915 * (2.0 * viewDir.z * viewDir.z - viewDir.x * viewDir.x - viewDir.y * viewDir.y))\n      + sh2_3 * (-1.0925484 * viewDir.x * viewDir.z)\n      + sh2_4 * (0.5462742 * (viewDir.x * viewDir.x - viewDir.y * viewDir.y));\n  }\n"),vg=V("\n  vec3 evaluateSH3(Gsplat gsplat, usampler2DArray sh3, vec3 viewDir) {\n    // Extract sint6 values packed into 4 x uint32\n    uvec4 packed = texelFetch(sh3, splatTexCoord(gsplat.index), 0);\n    vec3 sh3_0 = vec3(ivec3(\n      int(packed.x << 26u) >> 26,\n      int(packed.x << 20u) >> 26,\n      int(packed.x << 14u) >> 26\n    )) / 31.0;\n    vec3 sh3_1 = vec3(ivec3(\n      int(packed.x << 8u) >> 26,\n      int(packed.x << 2u) >> 26,\n      int((packed.x >> 4u) | (packed.y << 28u)) >> 26\n    )) / 31.0;\n    vec3 sh3_2 = vec3(ivec3(\n      int(packed.y << 22u) >> 26,\n      int(packed.y << 16u) >> 26,\n      int(packed.y << 10u) >> 26\n    )) / 31.0;\n    vec3 sh3_3 = vec3(ivec3(\n      int(packed.y << 4u) >> 26,\n      int((packed.y >> 2u) | (packed.z << 30u)) >> 26,\n      int(packed.z << 24u) >> 26\n    )) / 31.0;\n    vec3 sh3_4 = vec3(ivec3(\n      int(packed.z << 18u) >> 26,\n      int(packed.z << 12u) >> 26,\n      int(packed.z << 6u) >> 26\n    )) / 31.0;\n    vec3 sh3_5 = vec3(ivec3(\n      int(packed.z) >> 26,\n      int(packed.w << 26u) >> 26,\n      int(packed.w << 20u) >> 26\n    )) / 31.0;\n    vec3 sh3_6 = vec3(ivec3(\n      int(packed.w << 14u) >> 26,\n      int(packed.w << 8u) >> 26,\n      int(packed.w << 2u) >> 26\n    )) / 31.0;\n\n    float xx = viewDir.x * viewDir.x;\n    float yy = viewDir.y * viewDir.y;\n    float zz = viewDir.z * viewDir.z;\n    float xy = viewDir.x * viewDir.y;\n    float yz = viewDir.y * viewDir.z;\n    float zx = viewDir.z * viewDir.x;\n\n    return sh3_0 * (-0.5900436 * viewDir.y * (3.0 * xx - yy))\n      + sh3_1 * (2.8906114 * xy * viewDir.z) +\n      + sh3_2 * (-0.4570458 * viewDir.y * (4.0 * zz - xx - yy))\n      + sh3_3 * (0.3731763 * viewDir.z * (2.0 * zz - 3.0 * xx - 3.0 * yy))\n      + sh3_4 * (-0.4570458 * viewDir.x * (4.0 * zz - xx - yy))\n      + sh3_5 * (1.4453057 * viewDir.z * (xx - yy))\n      + sh3_6 * (-0.5900436 * viewDir.x * (xx - 3.0 * yy));\n  }\n");const Lg=class A{constructor({fileBytes:A}){this.header="",this.littleEndian=!0,this.elements={},this.comments=[],this.data=null,this.numSplats=0,this.fileBytes=A instanceof ArrayBuffer?new Uint8Array(A):A}async parseHeader(){const A=new ReadableStream({start:A=>{A.enqueue(this.fileBytes.slice(0,65536)),A.close()}}).pipeThrough(new TextDecoderStream).getReader();this.header="";const n="end_header\n";for(;;){const{value:t,done:e}=await A.read();if(e)throw new Error("Failed to read header");this.header+=t;const i=this.header.indexOf(n);if(i>=0){this.header=this.header.slice(0,i+11);break}}const t=(new TextEncoder).encode(this.header).length;this.data=new DataView(this.fileBytes.buffer,t),this.elements={};let e=null;this.comments=[],this.header.trim().split("\n").forEach(((A,n)=>{const t=A.trim();if(0===n){if("ply"!==t)throw new Error("Invalid PLY header");return}if(0===t.length)return;const i=t.split(" ");switch(i[0]){case"format":if("binary_little_endian"===i[1])this.littleEndian=!0;else{if("binary_big_endian"!==i[1])throw new Error(`Unsupported PLY format: ${i[1]}`);this.littleEndian=!1}if("1.0"!==i[2])throw new Error(`Unsupported PLY version: ${i[2]}`);break;case"end_header":break;case"comment":this.comments.push(t.slice(8));break;case"element":{const A=i[1];e={name:A,count:Number.parseInt(i[2]),properties:{}},this.elements[A]=e;break}case"property":if(null==e)throw new Error("Property must be inside an element");"list"===i[1]?e.properties[i[4]]={isList:!0,type:i[3],countType:i[2]}:e.properties[i[2]]={isList:!1,type:i[1]}}})),this.elements.vertex&&(this.numSplats=this.elements.vertex.count)}parseData(A){let n=0;const t=this.data;if(null==t)throw new Error("No data to parse");for(const e in this.elements){const i=this.elements[e],{count:s,properties:g}=i,a={},I=[];for(const[A,e]of Object.entries(g))e.isList?(a[A]=[],I.push((()=>{const i=a[A];i.length=Hg[e.countType](t,n,this.littleEndian),n+=qg[e.countType];for(let A=0;A<i.length;A++)i[A]=Hg[e.type](t,n,this.littleEndian),n+=qg[e.type]}))):(a[A]=0,I.push((()=>{a[A]=Hg[e.type](t,n,this.littleEndian),n+=qg[e.type]})));const r=A(i)??(()=>{});for(let A=0;A<s;A++){for(const A of I)A();r(A,a)}}}parseSplats(n,t){if(null==this.elements.vertex)throw new Error("No vertex element found");let e=!1;const i=[];let s,g,a,I=0,r=[],B=[],o=[];function Q(){const A=zg[I];r=new Array(3).fill(null).flatMap(((n,t)=>[0,1,2].map(((n,e)=>`f_rest_${t+e*A/3}`)))),B=new Array(5).fill(null).flatMap(((n,t)=>[0,1,2].map(((n,e)=>`f_rest_${3+t+e*A/3}`)))),o=new Array(7).fill(null).flatMap(((n,t)=>[0,1,2].map(((n,e)=>`f_rest_${8+t+e*A/3}`)))),s=I>=1?new Float32Array(9):void 0,g=I>=2?new Float32Array(15):void 0,a=I>=3?new Float32Array(21):void 0}function C(A,n){if(!s)throw new Error("Missing sh1");for(const[A,t]of r.entries())s[A]=8*n[t]/255-4;if(g)for(const[A,t]of B.entries())g[A]=8*n[t]/255-4;if(a)for(const[A,t]of o.entries())a[A]=8*n[t]/255-4;null==t||t(A,s,g,a)}this.parseData((E=>{if("chunk"===E.name)return function(A){const{min_x:n,min_y:t,min_z:s,max_x:g,max_y:a,max_z:I,min_scale_x:r,min_scale_y:B,min_scale_z:o,max_scale_x:Q,max_scale_y:C,max_scale_z:E}=A.properties;if(!(n&&t&&s&&g&&a&&I&&r&&B&&o&&Q&&C&&E))throw new Error("Missing PLY chunk properties");return e=!0,(A,n)=>{const{min_x:t,min_y:e,min_z:s,max_x:g,max_y:a,max_z:I,min_scale_x:r,min_scale_y:B,min_scale_z:o,max_scale_x:Q,max_scale_y:C,max_scale_z:E,min_r:c,min_g:l,min_b:h,max_r:u,max_g:d,max_b:p}=n;i.push({min_x:t,min_y:e,min_z:s,max_x:g,max_y:a,max_z:I,min_scale_x:r,min_scale_y:B,min_scale_z:o,max_scale_x:Q,max_scale_y:C,max_scale_z:E,min_r:c,min_g:l,min_b:h,max_r:u,max_g:d,max_b:p})}}(E);if(e)return function(A){if(t&&"sh"===A.name)return I=Zg(A.properties),Q(),C;if("vertex"!==A.name)return null;const{packed_position:e,packed_rotation:s,packed_scale:g,packed_color:a}=A.properties;if(!(e&&s&&g&&a))throw new Error("Missing PLY properties: packed_position, packed_rotation, packed_scale, packed_color");const r=Math.sqrt(2);return(A,t)=>{const e=i[A>>>8];if(null==e)throw new Error("Missing PLY chunk");const{min_x:s,min_y:g,min_z:a,max_x:I,max_y:B,max_z:o,min_scale_x:Q,min_scale_y:C,min_scale_z:E,max_scale_x:c,max_scale_y:l,max_scale_z:h,min_r:u,min_g:d,min_b:p,max_r:y,max_g:D,max_b:w}=e,{packed_position:f,packed_rotation:m,packed_scale:S,packed_color:x}=t,F=(f>>>21&2047)/2047*(I-s)+s,G=(f>>>11&1023)/1023*(B-g)+g,k=(2047&f)/2047*(o-a)+a,N=((m>>>20&1023)/1023-.5)*r,M=((m>>>10&1023)/1023-.5)*r,R=((1023&m)/1023-.5)*r,b=Math.sqrt(Math.max(0,1-N*N-M*M-R*R)),U=m>>>30,v=0===U?N:1===U?b:M,L=U<=1?M:2===U?b:R,Y=U<=2?R:b,J=0===U?b:N,H=Math.exp((S>>>21&2047)/2047*(c-Q)+Q),T=Math.exp((S>>>11&1023)/1023*(l-C)+C),q=Math.exp((2047&S)/2047*(h-E)+E);n(A,F,G,k,H,T,q,v,L,Y,J,(255&x)/255,(x>>>24&255)/255*((y??1)-(u??0))+(u??0),(x>>>16&255)/255*((D??1)-(d??0))+(d??0),(x>>>8&255)/255*((w??1)-(p??0))+(p??0))}}(E);if("vertex"!==E.name)return null;const{x:c,y:l,z:h,scale_0:u,scale_1:d,scale_2:p,rot_0:y,rot_1:D,rot_2:w,rot_3:f,opacity:m,f_dc_0:S,f_dc_1:x,f_dc_2:F,red:G,green:k,blue:N,alpha:M}=E.properties;if(!c||!l||!h)throw new Error("Missing PLY properties: x, y, z");const R=u&&d&&p,b=y&&D&&w&&f,U=null!=M?Kg[M.type]:1,v=null!=G?Kg[G.type]:1,L=null!=k?Kg[k.type]:1,Y=null!=N?Kg[N.type]:1;return I=Zg(E.properties),Q(),(e,i)=>{const I=R?Math.exp(i.scale_0):A.defaultPointScale,Q=R?Math.exp(i.scale_1):A.defaultPointScale,C=R?Math.exp(i.scale_2):A.defaultPointScale,E=b?i.rot_1:0,c=b?i.rot_2:0,l=b?i.rot_3:0,h=b?i.rot_0:1,u=null!=m?1/(1+Math.exp(-i.opacity)):null!=M?i.alpha/U:1,d=null!=S?i.f_dc_0*Jg+.5:null!=G?i.red/v:1,p=null!=x?i.f_dc_1*Jg+.5:null!=k?i.green/L:1,y=null!=F?i.f_dc_2*Jg+.5:null!=N?i.blue/Y:1;if(n(e,i.x,i.y,i.z,I,Q,C,E,c,l,h,u,d,p,y),t&&s){if(s)for(const[A,n]of r.entries())s[A]=i[n];if(g)for(const[A,n]of B.entries())g[A]=i[n];if(a)for(const[A,n]of o.entries())a[A]=i[n];t(e,s,g,a)}}}))}injectRgba(A){let n=0;const t=this.data;if(null==t)throw new Error("No parsed data");if(A.length!==4*this.numSplats)throw new Error("Invalid RGBA array length");for(const e in this.elements){const i=this.elements[e],{count:s,properties:g}=i,a=[];let I=0;const r="vertex"===e;if(r)for(const A of["opacity","f_dc_0","f_dc_1","f_dc_2"])if(!g[A]||"float"!==g[A].type)throw new Error(`Can't injectRgba due to property: ${A}`);for(const[e,i]of Object.entries(g))if(i.isList)a.push((()=>{const A=Hg[i.countType](t,n,this.littleEndian);n+=qg[i.countType],n+=A*qg[i.type]}));else{if(r)if("f_dc_0"===e||"f_dc_1"===e||"f_dc_2"===e){const s=Number.parseInt(e.slice(5));a.push((()=>{const e=(A[I+s]/255-.5)/Jg;Tg[i.type](t,n,this.littleEndian,e)}))}else"opacity"===e&&a.push((()=>{const e=Math.max(-100,Math.min(100,-Math.log(1/(A[I+3]/255)-1)));Tg[i.type](t,n,this.littleEndian,e)}));a.push((()=>{n+=qg[i.type]}))}for(let A=0;A<s;A++){for(const A of a)A();r&&(I+=4)}}}};Lg.defaultPointScale=.001;let Yg=Lg;const Jg=.28209479177387814,Hg={char:(A,n,t)=>A.getInt8(n),uchar:(A,n,t)=>A.getUint8(n),short:(A,n,t)=>A.getInt16(n,t),ushort:(A,n,t)=>A.getUint16(n,t),int:(A,n,t)=>A.getInt32(n,t),uint:(A,n,t)=>A.getUint32(n,t),float:(A,n,t)=>A.getFloat32(n,t),double:(A,n,t)=>A.getFloat64(n,t)},Tg={char:(A,n,t,e)=>{A.setInt8(n,e)},uchar:(A,n,t,e)=>{A.setUint8(n,e)},short:(A,n,t,e)=>{A.setInt16(n,e,t)},ushort:(A,n,t,e)=>{A.setUint16(n,e,t)},int:(A,n,t,e)=>{A.setInt32(n,e,t)},uint:(A,n,t,e)=>{A.setUint32(n,e,t)},float:(A,n,t,e)=>{A.setFloat32(n,e,t)},double:(A,n,t,e)=>{A.setFloat64(n,e,t)}},qg={char:1,uchar:1,short:2,ushort:2,int:4,uint:4,float:4,double:8},Kg={char:127,uchar:255,short:32767,ushort:65535,int:2147483647,uint:4294967295,float:1,double:1},_g={0:0,9:1,24:2,45:3},zg={0:0,1:9,2:24,3:45};function Zg(A){let n=0;for(;A[`f_rest_${n}`];)n+=1;const t=_g[n];if(null==t)throw new Error(`Unsupported number of SH coefficients: ${n}`);return t}const Pg='(function() {\n  "use strict";\n  let wasm;\n  const cachedTextDecoder = typeof TextDecoder !== "undefined" ? new TextDecoder("utf-8", { ignoreBOM: true, fatal: true }) : { decode: () => {\n    throw Error("TextDecoder not available");\n  } };\n  if (typeof TextDecoder !== "undefined") {\n    cachedTextDecoder.decode();\n  }\n  let cachedUint8ArrayMemory0 = null;\n  function getUint8ArrayMemory0() {\n    if (cachedUint8ArrayMemory0 === null || cachedUint8ArrayMemory0.byteLength === 0) {\n      cachedUint8ArrayMemory0 = new Uint8Array(wasm.memory.buffer);\n    }\n    return cachedUint8ArrayMemory0;\n  }\n  function getStringFromWasm0(ptr, len) {\n    ptr = ptr >>> 0;\n    return cachedTextDecoder.decode(getUint8ArrayMemory0().subarray(ptr, ptr + len));\n  }\n  function sort_splats(num_splats, readback, ordering) {\n    const ret = wasm.sort_splats(num_splats, readback, ordering);\n    return ret >>> 0;\n  }\n  function raycast_splats(origin_x, origin_y, origin_z, dir_x, dir_y, dir_z, near, far, num_splats, packed_splats, raycast_ellipsoid) {\n    const ret = wasm.raycast_splats(origin_x, origin_y, origin_z, dir_x, dir_y, dir_z, near, far, num_splats, packed_splats, raycast_ellipsoid);\n    return ret;\n  }\n  async function __wbg_load(module, imports) {\n    if (typeof Response === "function" && module instanceof Response) {\n      if (typeof WebAssembly.instantiateStreaming === "function") {\n        try {\n          return await WebAssembly.instantiateStreaming(module, imports);\n        } catch (e) {\n          if (module.headers.get("Content-Type") != "application/wasm") {\n            console.warn("`WebAssembly.instantiateStreaming` failed because your server does not serve Wasm with `application/wasm` MIME type. Falling back to `WebAssembly.instantiate` which is slower. Original error:\\n", e);\n          } else {\n            throw e;\n          }\n        }\n      }\n      const bytes = await module.arrayBuffer();\n      return await WebAssembly.instantiate(bytes, imports);\n    } else {\n      const instance = await WebAssembly.instantiate(module, imports);\n      if (instance instanceof WebAssembly.Instance) {\n        return { instance, module };\n      } else {\n        return instance;\n      }\n    }\n  }\n  function __wbg_get_imports() {\n    const imports = {};\n    imports.wbg = {};\n    imports.wbg.__wbg_buffer_609cc3eee51ed158 = function(arg0) {\n      const ret = arg0.buffer;\n      return ret;\n    };\n    imports.wbg.__wbg_length_3b4f022188ae8db6 = function(arg0) {\n      const ret = arg0.length;\n      return ret;\n    };\n    imports.wbg.__wbg_length_6ca527665d89694d = function(arg0) {\n      const ret = arg0.length;\n      return ret;\n    };\n    imports.wbg.__wbg_length_8cfd2c6409af88ad = function(arg0) {\n      const ret = arg0.length;\n      return ret;\n    };\n    imports.wbg.__wbg_new_9fee97a409b32b68 = function(arg0) {\n      const ret = new Uint16Array(arg0);\n      return ret;\n    };\n    imports.wbg.__wbg_new_e3b321dcfef89fc7 = function(arg0) {\n      const ret = new Uint32Array(arg0);\n      return ret;\n    };\n    imports.wbg.__wbg_newwithbyteoffsetandlength_e6b7e69acd4c7354 = function(arg0, arg1, arg2) {\n      const ret = new Float32Array(arg0, arg1 >>> 0, arg2 >>> 0);\n      return ret;\n    };\n    imports.wbg.__wbg_newwithbyteoffsetandlength_f1dead44d1fc7212 = function(arg0, arg1, arg2) {\n      const ret = new Uint32Array(arg0, arg1 >>> 0, arg2 >>> 0);\n      return ret;\n    };\n    imports.wbg.__wbg_newwithlength_5a5efe313cfd59f1 = function(arg0) {\n      const ret = new Float32Array(arg0 >>> 0);\n      return ret;\n    };\n    imports.wbg.__wbg_set_10bad9bee0e9c58b = function(arg0, arg1, arg2) {\n      arg0.set(arg1, arg2 >>> 0);\n    };\n    imports.wbg.__wbg_set_d23661d19148b229 = function(arg0, arg1, arg2) {\n      arg0.set(arg1, arg2 >>> 0);\n    };\n    imports.wbg.__wbg_set_f4f1f0daa30696fc = function(arg0, arg1, arg2) {\n      arg0.set(arg1, arg2 >>> 0);\n    };\n    imports.wbg.__wbg_subarray_3aaeec89bb2544f0 = function(arg0, arg1, arg2) {\n      const ret = arg0.subarray(arg1 >>> 0, arg2 >>> 0);\n      return ret;\n    };\n    imports.wbg.__wbg_subarray_769e1e0f81bb259b = function(arg0, arg1, arg2) {\n      const ret = arg0.subarray(arg1 >>> 0, arg2 >>> 0);\n      return ret;\n    };\n    imports.wbg.__wbindgen_init_externref_table = function() {\n      const table = wasm.__wbindgen_export_0;\n      const offset = table.grow(4);\n      table.set(0, void 0);\n      table.set(offset + 0, void 0);\n      table.set(offset + 1, null);\n      table.set(offset + 2, true);\n      table.set(offset + 3, false);\n    };\n    imports.wbg.__wbindgen_memory = function() {\n      const ret = wasm.memory;\n      return ret;\n    };\n    imports.wbg.__wbindgen_throw = function(arg0, arg1) {\n      throw new Error(getStringFromWasm0(arg0, arg1));\n    };\n    return imports;\n  }\n  function __wbg_finalize_init(instance, module) {\n    wasm = instance.exports;\n    __wbg_init.__wbindgen_wasm_module = module;\n    cachedUint8ArrayMemory0 = null;\n    wasm.__wbindgen_start();\n    return wasm;\n  }\n  async function __wbg_init(module_or_path) {\n    if (wasm !== void 0) return wasm;\n    if (typeof module_or_path !== "undefined") {\n      if (Object.getPrototypeOf(module_or_path) === Object.prototype) {\n        ({ module_or_path } = module_or_path);\n      } else {\n        console.warn("using deprecated parameters for the initialization function; pass a single object instead");\n      }\n    }\n    if (typeof module_or_path === "undefined") {\n      module_or_path = new URL("data:application/wasm;base64,AGFzbQEAAAAB9wEkYAJ/fwF/YAN/f38Bf2ACf38AYAN/f38AYAF/AGABfwF/YAV/f39/fwBgA29/fwFvYAV/f39/fwF/YAR/f39/AGABbwFvYANvb38AYAFvAX9gAAF/YAAAYAd/f39/f39/AX9gAX0BfWAGf39/f39/AGAEf39/fwF/YAF/AW9gAAFvYAd/f39/f39/AGACf34Bf2ADf35+AGACf34AYAt9fX19fX19fX9vfwFvYAZ/f39/f38Bf2AFf398f38AYAR/fH9/AGAFf399f38AYAR/fX9/AGAFf39+f38AYAR/fn9/AGADf35+AX9gA39vbwF/YAJ9fQF9AvIEEQN3YmcdX193YmdfYnVmZmVyXzYwOWNjM2VlZTUxZWQxNTgACgN3YmcaX193YmdfbmV3XzlmZWU5N2E0MDliMzJiNjgACgN3YmcaX193Ymdfc2V0X2Y0ZjFmMGRhYTMwNjk2ZmMACwN3YmcdX193YmdfbGVuZ3RoXzhjZmQyYzY0MDlhZjg4YWQADAN3YmcxX193YmdfbmV3d2l0aGJ5dGVvZmZzZXRhbmRsZW5ndGhfZjFkZWFkNDRkMWZjNzIxMgAHA3diZxpfX3diZ19uZXdfZTNiMzIxZGNmZWY4OWZjNwAKA3diZxpfX3diZ19zZXRfZDIzNjYxZDE5MTQ4YjIyOQALA3diZx1fX3diZ19sZW5ndGhfNmNhNTI3NjY1ZDg5Njk0ZAAMA3diZzFfX3diZ19uZXd3aXRoYnl0ZW9mZnNldGFuZGxlbmd0aF9lNmI3ZTY5YWNkNGM3MzU0AAcDd2JnGl9fd2JnX3NldF8xMGJhZDliZWUwZTljNThiAAsDd2JnHV9fd2JnX2xlbmd0aF8zYjRmMDIyMTg4YWU4ZGI2AAwDd2JnH19fd2JnX3N1YmFycmF5Xzc2OWUxZTBmODFiYjI1OWIABwN3YmcfX193Ymdfc3ViYXJyYXlfM2FhZWVjODliYjI1NDRmMAAHA3diZyRfX3diZ19uZXd3aXRobGVuZ3RoXzVhNWVmZTMxM2NmZDU5ZjEAEwN3YmcQX193YmluZGdlbl90aHJvdwACA3diZxFfX3diaW5kZ2VuX21lbW9yeQAUA3diZx9fX3diaW5kZ2VuX2luaXRfZXh0ZXJucmVmX3RhYmxlAA4DwAG+AQUAAAYPAAUF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BSADOgAcIAUgAjYCGCAFIAUpAwA3AhBBlM/AACgCACAFQRBqQZjPwAAoAgAoAhQRAgBBkM/AACgCAEEBawUgBgs2AgBB6NLAAEEAOgAAIANFDQAACwALsgEBBn8CQAJAIABBhAFJDQAgANBvJgEQRSIBKAIMIQUgASgCECECIAFCADcCDCABKAIIIQMgASgCBCEEIAFCBDcCBCABKAIAIQYgAUEANgIAIAAgAkkNASAAIAJrIgAgA08NASAEIABBAnRqIAU2AgAgASACNgIQIAEgADYCDCABIAM2AgggASgCBCABIAQ2AgQgASgCACEAIAEgBjYCACAARQ0AIABBAnRBBBCwAQsPCwALqQEBAX8jAEEQayIGJAACQCABBEAgBkEEaiABIAMgBCAFIAIoAhARBgACQCAGKAIEIgIgBigCDCIBTQRAIAYoAgghBQwBCyACQQJ0IQIgBigCCCEDIAFFBEBBBCEFIAMgAkEEELABDAELIAMgAkEEIAFBAnQiAhCXASIFRQ0CCyAAIAE2AgQgACAFNgIAIAZBEGokAA8LQZiPwABBMhC5AQALQQQgAhCUAQALowEBAn8jAEEgayIDJAACQCABRQRAQQFBACACEMYBIQAMAQsgAyABNgIMIAMgADYCCCADQRBqIANBCGoQLSADKAIQIgEEQANAIAMoAhQhBCADKAIcRQRAIAEgBCACEMYBIQAMAwtBASEAIAIgASAEEJkBDQIgAkH9/wMQnAENAiADQRBqIANBCGoQLSADKAIQIgENAAsLQQAhAAsgA0EgaiQAIAALiwEBAX8CQCACQQBOBEACfyADKAIEBEACQCADKAIIIgRFBEAMAQsgAygCACAEIAEgAhCXAQwCCwsgASACRQ0AGkH9zsAALQAAGiACIAEQpgELIgMEQCAAIAI2AgggACADNgIEIABBADYCAA8LIAAgAjYCCCAAIAE2AgQMAQsgAEEANgIECyAAQQE2AgALqwEBAn8jAEEgayIBJAACQCAAKAIEIgJBA0YgAkECSXINAAJAAkAgAC0AGEEBaw4CAgABCyABQQE2AgggAUGshcAANgIEIAFCADcCECABIAFBHGo2AgwgAUEEakGQhsAAEIQBAAsgAEEIahBOIAAoAggiAkUNACAAKAIMIAJBDGxBBBCwAQsgACgCHCICBEAgACgCICACQQEQsAELIABBKEEEELABIAFBIGokAAuaAQECfyMAQSBrIgEkAAJAIAAoAgRBAkcNAAJAAkAgAC0AGEEBaw4CAgABCyABQQE2AgggAUGshcAANgIEIAFCADcCECABIAFBHGo2AgwgAUEEakGQhsAAEIQBAAsgAEEIahBOIAAoAggiAkUNACAAKAIMIAJBDGxBBBCwAQsgACgCHCICBEAgACgCICACQQEQsAELIAFBIGokAAuSAQEEfyMAQRBrIgIkAEEBIQQCQCABKAIUIgNBJyABKAIYIgUoAhAiAREAAA0AIAJBBGogACgCAEGBAhAiAkAgAi0ABEGAAUYEQCADIAIoAgggAREAAEUNAQwCCyADIAItAA4iACACQQRqaiACLQAPIABrIAUoAgwRAQANAQsgA0EnIAERAAAhBAsgAkEQaiQAIAQLlQEBAn8jAEEgayIDJAACQCAAKAIEIgRBA0YgBEECSXINAAJAAkAgAC0AGEEBaw4CAgABCyADQQE2AgggA0GshcAANgIEIANCADcCECADIANBHGo2AgwgA0EEakGQhsAAEIQBAAsgAEEIahBOIAAoAggiBEUNACAAKAIMIARBDGxBBBCwAQsgAEEoQQQQsAEgA0EgaiQAC4QBAQN/An8CQCAAKAIAIgFFDQADQAJAIAAoAggiAyAAKAIETw0AIAEgA2otAABBxQBHDQAgACADQQFqNgIIDAILAkAgAkUNACAAKAIQIgFFDQBB+aTAAEECIAEQxgFFDQBBAQ8LQQEgAEEBEBMNAhogAkEBayECIAAoAgAiAQ0ACwtBAAsLegEBfyMAQSBrIgIkAAJ/IAAoAgBBgICAgHhHBEAgASAAKAIEIAAoAggQmQEMAQsgAkEQaiAAKAIMKAIAIgBBCGopAgA3AwAgAkEYaiAAQRBqKQIANwMAIAIgACkCADcDCCABKAIUIAEoAhggAkEIahApCyACQSBqJAALSQEDfiAAIAFC/////w+DIgJCPn4iA0IAIgIgAUIgiEI+fnwiAUIghnwiBDcDACAAIAMgBFatIAEgAlStQiCGIAFCIIiEfDcDCAt8AQF/IwBBQGoiBSQAIAUgATYCDCAFIAA2AgggBSADNgIUIAUgAjYCECAFQQI2AhwgBUG8rsAANgIYIAVCAjcCJCAFIAVBEGqtQoCAgICADIQ3AzggBSAFQQhqrUKAgICAkAyENwMwIAUgBUEwajYCICAFQRhqIAQQhAEAC3gBA38CQCAAKAIAIgFBgICAgHhHBEAgAUUNASAAKAIEIAFBARCwAQ8LIAAtAARBA0cNACAAKAIIIgAoAgAhASAAQQRqKAIAIgMoAgAiAgRAIAEgAhEEAAsgAygCBCICBEAgASACIAMoAggQsAELIABBDEEEELABCwvzAwIIfwF+IwBBEGsiAyQAIAAoAgQhBSAAKAIAIQAgASgCFEG4rMAAQQEgASgCGCgCDBEBACEEIANBBGoiAkEAOgAFIAIgBDoABCACIAE2AgAgBQRAA0AgAyAANgIMIANBDGohCCMAQUBqIgEkAEEBIQYCQCADQQRqIgQtAAQNACAELQAFIQkCQCAEKAIAIgIoAhwiB0EEcUUEQCAJQQFxRQ0BIAIoAhRB667AAEECIAIoAhgoAgwRAQBFDQEMAgsgCUEBcUUEQCACKAIUQfWuwABBASACKAIYKAIMEQEADQIgAigCHCEHCyABQQE6ABsgASACKQIUNwIMIAFBzK7AADYCNCABIAFBG2o2AhQgASACKQIINwIkIAIpAgAhCiABIAc2AjggASACKAIQNgIsIAEgAi0AIDoAPCABIAo3AhwgASABQQxqNgIwIAggAUEcakGAmcAAKAIAEQAADQEgASgCMEHwrsAAQQIgASgCNCgCDBEBACEGDAELIAggAkGAmcAAKAIAEQAAIQYLIARBAToABSAEIAY6AAQgAUFAayQAIABBAWohACAFQQFrIgUNAAsLQQEhACADQQRqIgEtAARFBEAgASgCACIAKAIUQfauwABBASAAKAIYKAIMEQEAIQALIAEgADoABCADQRBqJAAgAAtqAgF/AX4jAEEwayIDJAAgAyAANgIAIAMgATYCBCADQQI2AgwgA0HYscAANgIIIANCAjcCFCADQoCAgIDwAiIEIANBBGqthDcDKCADIAQgA62ENwMgIAMgA0EgajYCECADQQhqIAIQhAEAC2oCAX8BfiMAQTBrIgMkACADIAE2AgQgAyAANgIAIANBAjYCDCADQZitwAA2AgggA0ICNwIUIANCgICAgPACIgQgA62ENwMoIAMgBCADQQRqrYQ3AyAgAyADQSBqNgIQIANBCGogAhCEAQALagIBfwF+IwBBMGsiAyQAIAMgADYCACADIAE2AgQgA0ECNgIM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AgwgASAENwIEIwBBEGsiACQAIAFBBGoiASgCACICKAIMIQMCQAJAAkACQCACKAIEDgIAAQILIAMNAUEBIQJBACEDDAILIAMNACACKAIAIgIoAgQhAyACKAIAIQIMAQsgAEGAgICAeDYCACAAIAE2AgwgAEHglsAAIAEoAgQgASgCCCIALQAIIAAtAAkQWQALIAAgAzYCBCAAIAI2AgAgAEHElsAAIAEoAgQgASgCCCIALQAIIAAtAAkQWQALJQAgAEUEQEGYj8AAQTIQuQEACyAAIAIgAyAEIAUgASgCEBEIAAsoACABIAAoAgAtAABBAnQiAEHkp8AAaigCACAAQdCnwABqKAIAEJkBCyMAIABFBEBBmI/AAEEyELkBAAsgACACIAMgBCABKAIQEQkACyMAIABFBEBBmI/AAEEyELkBAAsgACACIAMgBCABKAIQERIACyMAIABFBEBBmI/AAEEyELkBAAsgACACIAMgBCABKAIQERwACyMAIABFBEBBmI/AAEEyELkBAAsgACACIAMgBCABKAIQER4ACyMAIABFBEBBmI/AAEEyELkBAAsgACACIAMgBCABKAIQESAACygBAX8gACgCACIBQYCAgIB4ckGAgICAeEcEQCAAKAIEIAFBARCwAQsLJwAgAEEcakEAIAJC2KGkg7Hi0d18URtBACABQpXX3ZjDl4qMC1EbCyEAIABFBEBBmI/AAEEyELkBAAsgACACIAMgASgCEBEDAAsfACAARQRAQZiPwABBMhC5AQALIAAgAiABKAIQEQAAC+MVAQx/EDMiBCABJgECfyAAIQYQMyIAIAImASMAQdAAayIIJAAgCCAANgIYIAggBDYCFCAIQRRqKAIAEMoBIQtBvM7AACgCAEUEQEHkzsAAQQA2AgBB2M7AAEEANgIAQczOwABBADYCAEHAzsAAQQA2AgBB4M7AACgCACEFQeDOwABBBDYCAEHczsAAKAIAIQ1B3M7AAEEANgIAQdTOwAAoAgAhA0HUzsAAQQQ2AgBB0M7AACgCACEJQdDOwABBADYCAEHIzsAAKAIAIQRByM7AAEECNgIAQcTOwAAoAgAhB0HEzsAAQQA2AgBBvM7AACgCACEAQbzOwABBATYCAAJAIABFDQAgBwRAIAQgB0EBdEECELABCyAJBEAgAyAJQQJ0QQQQsAELIA1FDQAgBSANQQJ0QQQQsAELCwJAAkACQAJAAkBBwM7AACgCAEUEQEHAzsAAQX82AgBBzM7AACgCACIEIAtJBEAgCyAEIgBrIgVBxM7AACgCACAAa0sEQEHEzsAAIAAgBUECQQIQTEHMzsAAKAIAIQALQcjOwAAoAgAiAyAAQQF0aiEHIAVBAk8EQCAHIARBf3MgC2pBAXQQVxogACALakEBdCAEQQF0ayADakECayEHIAAgBWpBAWshAAsgB0EAOwEAQczOwAAgAEEBajYCAAtB2M7AACgCACIEIAtJBEAgCyAEIgBrIgVB0M7AACgCACAAa0sEQEHQzsAAIAAgBUEEQQQQTEHYzsAAKAIAIQALQdTOwAAoAgAiAyAAQQJ0aiEHIAVBAk8EQCAHIARBf3MgC2pBAnQQVxogACALakECdCAEQQJ0ayADakEEayEHIAAgBWpBAWshAAsgB0EANgIAQdjOwAAgAEEBajYCAAtB5M7AACgCACIEQYD4AU0EQEGB+AEgBCIAayIDQdzOwAAoAgAgAGtLBEBB3M7AACAAIANBBEEEEExB5M7AACgCACEAC0HgzsAAKAIAIgcgAEECdCIFaiEDIARBgPgBRwR/IANBgOAHIARBAnQiA2sQVxogACAEa0GA+AFqIQAgBSADayAHakGA4AdqBSADC0EANgIAQeTOwAAgAEEBajYCAAsgCEEUaigCACUBQQAgBhALIQEQMyIAIAEmASAIIAA2AhxBzM7AACgCACIAIAZJDQFByM7AACgCACEFIwBBIGsiACQAIAAgCEEcaiIDKAIAEMoBIgQ2AgAgACAGNgIEIAQgBkcNBRCeASIHEJUBIgQlARABIQEQMyIJIAEmASAEQYQBTwRAIAQQWgsgCSUBIAMoAgAlASAFQQF2EAIgCUGEAU8EQCAJEFoLIAdBhAFPBEAgBxBaCyAAQSBqJAAgCEEIaiEJQQAhACMAQUBqIgokAAJAAkACfwJAIAZBzM7AACgCACIETQRAQcjOwAAoAgAhBEHkzsAAQQA2AgBB3M7AACgCAEGA+AFNBEBB3M7AAEEAQYH4AUEEQQQQTEHkzsAAKAIAIQALQeDOwAAoAgAiCyAAQQJ0IgVqQYDgBxBXQeTOwAAgAEGB+AFqIg02AgBBgOAHakEANgIAAkAgBgRAIAZBAXQhDiAEIQADQCAALwEAIgNBgPgBSQRAIAMgDU8NAyALIANBAnRqIgMgAygCAEEBajYCAAsgAEECaiEAIA5BAmsiDg0ACwsgCkEANgIIAkAgDUECSQ0AIAsgDUECdGpBCGsiACgCACEMIABBADYCACAKIAw2AgggACALRg0AIAVB+N8HaiIFQQJ2QQFqQQNxIgMEQCADQQJ0IQ4DQCAAQQRrIgAoAgAhAyAAIAw2AgAgCiADIAxqIgw2AgggDkEEayIODQALCyAFQQxJDQAgAEEQayEAA0AgAEEMaiIFKAIAIQMgBSAMNgIAIAogAyAMaiIHNgIIIABBCGoiBSgCACEDIAUgBzYCACAKIAMgB2oiBzYCCCAAQQRqIgUoAgAhAyAFIAc2AgAgCiADIAdqIgU2AgggACgCACEDIAAgBTYCACAKIAMgBWoiDDYCCCAAIAtGIABBEGshAEUNAAsLAkAgBgRAIAZBAXQhDkHUzsAAKAIAIQZB2M7AACgCACEHQQAhAANAIAQvAQAiA0GA+AFJBEAgAyANTw0DIAcgCyADQQJ0aiIFKAIAIgNNBEAgAyAHQbyCwAAQaQALIAYgA0ECdGogADYCACAFIAUoAgBBAWo2AgALIARBAmohBCAAQQFqIQAgDkECayIODQALCyANRQ0FIAsoAgAgDEcNA0EADAQLIAMgDUGsgsAAEGkACyADIA1BzILAABBpAAsgBiAEQdyBwAAQagALIApBAjYCHCAKQZyCwAA2AhggCkICNwIkIAogC61CgICAgPAChDcDOCAKIApBCGqtQoCAgIDwAoQ3AzAgCiAKQTBqNgIgIApBDGoiBiAKQRhqEDcjAEEgayIEJAAgBEEIaiEDIwBBIGsiBSQAAkACQAJAAkACQAJAQYjPwAAtAAAOAgABAgtBiM/AAEEBOgAACyADQQE2AgAMAQtBic/AAC0AACEAQYnPwABBAToAACAFIAA6AAcgAEEBRg0BIANBADoAFCADQQA2AgBBic/AAEEAOgAACyAFQSBqJAAMAQsgBUIANwIUIAVCgYCAgMAANwIMIAVB4JTAADYCCCAFQQdqIAVBCGoQfwALAn9B/c7AAC0AABpBKEEEEKYBIgAEQCAAQaCBwAA2AgAgACADKQIANwIEIAAgBikCADcCHCAAQQxqIANBCGopAgA3AgAgAEEUaiADQRBqKQIANwIAIABBJGogBkEIaigCADYCACAADAELQQRBKBDEAQALIQwgBEEgaiQAQQELIQAgCSAMNgIEIAkgADYCACAKQUBrJAAMAQtBAEEAQeyBwAAQaQALIAgoAgwhCSAIKAIIDQIgCUUNBEHYzsAAKAIAIgAgCUkNA0HUzsAAKAIAIQYgCCAIQRhqQQAgCRCxASIHNgIwIwBBIGsiACQAIAhBMGooAgAiBBDLASEDIAAgCTYCBCAAIAM2AgACQCADIAlGBEAQngEiBRCVASIDJQEgBiAJEAQhARAzIgYgASYBIAVBhAFPBEAgBRBaCyADQYQBTwRAIAMQWgsgBCAGQQAQrwEgBkGEAU8EQCAGEFoLIABBIGokAAwBCwwGCyAHQYQBSQ0EIAcQWgwECxBwAAsgBiAAQbyGwAAQagALIAggCTYCICAIQQE2AjQgCEHchsAANgIwIAhCATcCPCAIIAhBIGqtQoCAgICAA4Q3A0ggCCAIQcgAajYCOCAIQSRqIQNBACEAIAhBMGoiBigCDCEEAkACQAJAAkACQAJAAkAgBigCBA4CAAECCyAEDQFBASEHQQAhBkEBIQQMAwsgBEUNAQsgAyAGEDcMAwsgBigCACIEKAIEIgZBAEgNASAEKAIAIQcgBkUEQEEBIQRBACEGDAELQf3OwAAtAAAaQQEhACAGQQEQpgEiBEUNAQsgBCAHIAYQPCEAIAMgBjYCCCADIAA2AgQgAyAGNgIADAELIAAgBhCUAQALIAgoAiggCCgCLBC5AQALIAkgAEHMhsAAEGoACyAIKAIcIgBBhAFPBEAgABBaC0HAzsAAQcDOwAAoAgBBAWo2AgAgCCgCGCIAQYQBTwRAIAAQWgsgCCgCFCIAQYQBTwRAIAAQWgsgCEHQAGokACAJDAELIABBADYCCCAAIABBBGogAEEIahB+AAsLGgEBfyAAKAIAIgEEQCAAKAIEIAFBARCwAQsLFAAgASABIAAgACABXRsgACAAXBsLHAAgAEEANgIQIABCADcCCCAAQoCAgIDAADcCAAtGACAARQRAIwBBIGsiACQAIABBADYCGCAAQQE2AgwgAEH8qcAANgIIIABCBDcCECAAQQhqQZiqwAAQhAEACyAAIAEQxAEACxYBAW8gACUBEAAhARAzIgAgASYBIAALFgAgAEG4gMAANgIEIAAgAUEcajYCAAvWBgEGfwJ/AkACQAJAAkACQCAAQQRrIgUoAgAiBkF4cSIEQQRBCCAGQQNxIgcbIAFqTwRAIAdBACABQSdqIgkgBEkbDQECQAJAIAJBCU8EQCACIAMQNSIIDQFBAAwJCyADQcz/e0sNAUEQIANBC2pBeHEgA0ELSRshAQJAIAdFBEAgAUGAAkkgBCABQQRySXIgBCABa0GBgAhPcg0BDAkLIABBCGsiAiAEaiEHAkACQAJAAkAgASAESwRAIAdBzNLAACgCAEYNBCAHQcjSwAAoAgBGDQIgBygCBCIGQQJxDQUgBkF4cSIGIARqIgQgAUkNBSAHIAYQOyAEIAFrIgNBEEkNASAFIAEgBSgCAEEBcXJBAnI2AgAgASACaiIBIANBA3I2AgQgAiAEaiICIAIoAgRBAXI2AgQgASADEDAMDQsgBCABayIDQQ9LDQIMDAsgBSAEIAUoAgBBAXFyQQJyNgIAIAIgBGoiASABKAIEQQFyNgIEDAsLQcDSwAAoAgAgBGoiBCABSQ0CAkAgBCABayIDQQ9NBEAgBSAGQQFxIARyQQJyNgIAIAIgBGoiASABKAIEQQFyNgIEQQAhA0EAIQEMAQsgBSABIAZBAXFyQQJyNgIAIAEgAmoiASADQQFyNgIEIAIgBGoiAiADNgIAIAIgAigCBEF+cTYCBAtByNLAACABNgIAQcDSwAAgAzYCAAwKCyAFIAEgBkEBcXJBAnI2AgAgASACaiIBIANBA3I2AgQgByAHKAIEQQFyNgIEIAEgAxAwDAkLQcTSwAAoAgAgBGoiBCABSw0HCyADEBEiAUUNASABIABBfEF4IAUoAgAiAUEDcRsgAUF4cWoiASADIAEgA0kbEDwgABAlDAgLIAggACABIAMgASADSRsQPBogBSgCACICQXhxIgMgAUEEQQggAkEDcSICG2pJDQMgAkEAIAMgCUsbDQQgABAlCyAIDAYLQe2RwABBLkGcksAAEHgAC0GsksAAQS5B3JLAABB4AAtB7ZHAAEEuQZySwAAQeAALQaySwABBLkHcksAAEHgACyAFIAEgBkEBcXJBAnI2AgAgASACaiICIAQgAWsiAUEBcjYCBEHE0sAAIAE2AgBBzNLAACACNgIAIAAMAQsgAAsLGQAgASgCFEGGrMAAQQ4gASgCGCgCDBEBAAsWACAAKAIUIAEgAiAAKAIYKAIMEQEACxQAIAAoAgAgASAAKAIEKAIQEQAACxQAIAAoAgAgASAAKAIEKAIMEQAACxQAIAAoAhQgASAAKAIYKAIQEQAAC84IAQV/IwBB8ABrIgUkACAFIAM2AgwgBSACNgIIAkACQAJAAkACQAJAAn8gAAJ/AkAgAUGBAk8EQEEDIAAsAIACQb9/Sg0CGiAALAD/AUG/f0wNAUECDAILIAUgATYCFCAFIAA2AhBBAQwCCyAALAD+AUG/f0oLQf0BaiIGaiwAAEG/f0wNASAFIAY2AhQgBSAANgIQQQUhB0HJtsAACyEGIAUgBzYCHCAFIAY2AhggASACSSIHIAEgA0lyRQRAIAIgA0sNAiACRSABIAJNckUEQCAFQQxqIAVBCGogACACaiwAAEG/f0obKAIAIQMLIAUgAzYCICADIAEiAkkEQCADQQFqIgggA0EDayICQQAgAiADTRsiAkkNBAJAIAIgCEYNACAIIAJrIQcgACADaiwAAEG/f0oEQCAHQQFrIQYMAQsgAiADRg0AIAAgCGoiA0ECayIJLAAAQb9/SgRAIAdBAmshBgwBCyAJIAAgAmoiCEYNACADQQNrIgksAABBv39KBEAgB0EDayEGDAELIAggCUYNACADQQRrIgMsAABBv39KBEAgB0EEayEGDAELIAMgCEYNACAHQQVrIQYLIAIgBmohAgsCQCACRQ0AIAEgAksEQCAAIAJqLAAAQb9/Sg0BDAcLIAEgAkcNBgsgASACRg0EAn8CQAJAIAAgAmoiASwAACIAQQBIBEAgAS0AAUE/cSEGIABBH3EhAyAAQV9LDQEgA0EGdCAGciEADAILIAUgAEH/AXE2AiRBAQwCCyABLQACQT9xIAZBBnRyIQYgAEFwSQRAIAYgA0EMdHIhAAwBCyADQRJ0QYCA8ABxIAEtAANBP3EgBkEGdHJyIgBBgIDEAEYNBgsgBSAANgIkQQEgAEGAAUkNABpBAiAAQYAQSQ0AGkEDQQQgAEGAgARJGwshACAFIAI2AiggBSAAIAJqNgIsIAVBBTYCNCAFQdS3wAA2AjAgBUIFNwI8IAUgBUEYaq1CgICAgJAMhDcDaCAFIAVBEGqtQoCAgICQDIQ3A2AgBSAFQShqrUKAgICAsAyENwNYIAUgBUEkaq1CgICAgMAMhDcDUCAFIAVBIGqtQoCAgIDwAoQ3A0gMBgsgBSACIAMgBxs2AiggBUEDNgI0IAVBlLjAADYCMCAFQgM3AjwgBSAFQRhqrUKAgICAkAyENwNYIAUgBUEQaq1CgICAgJAMhDcDUCAFIAVBKGqtQoCAgIDwAoQ3A0gMBQsgACABQQAgBiAEEJ0BAAsgBUEENgI0IAVB9LbAADYCMCAFQgQ3AjwgBSAFQRhqrUKAgICAkAyENwNgIAUgBUEQaq1CgICAgJAMhDcDWCAFIAVBDGqtQoCAgIDwAoQ3A1AgBSAFQQhqrUKAgICA8AKENwNIDAMLIAIgCEHAuMAAEGsACyAEELMBAAsgACABIAIgASAEEJ0BAAsgBSAFQcgAajYCOCAFQTBqIAQQhAEACxQCAW8BfxAPIQAQMyIBIAAmASABCxMAIABBKDYCBCAAQYCAwAA2AgALEwAgAEH0gMAANgIEIAAgATYCAAsTACAAQSg2AgQgAEGMhMAANgIACyEAIABCnJzu3svC7uAnNwMIIABCtJOr5e2OzP6efzcDAAsiACAAQvLlnerun8WVjn83AwggAEKIoIuQ+YC1oqF/NwMACxAAIAAoAgQgACgCCCABEBwLEQAgACgCBCAAKAIIIAEQxgELGQACfyABQQlPBEAgASAAEDUMAQsgABARCwsiACAAQu26rbbNhdT14wA3AwggAEL4gpm9le7Gxbl/NwMACyAAIABC2KGkg7Hi0d18NwMIIABCldfdmMOXiowLNwMACxEAIAAoAgAgACgCBCABEMYBCxMAIABBtJbAADYCBCAAIAE2AgALEQAgASAAKAIAIAAoAgQQmQELEAAgACgCACAAKAIEIAEQHAsQACABIAAoAgAgACgCBBAeCxAAIAEoAhQgASgCGCAAECkLDgAgACUBIAElASACEAYLXwEBfwJAAkAgAEEEaygCACICQXhxIgNBBEEIIAJBA3EiAhsgAWpPBEAgAkEAIAMgAUEnaksbDQEgABAlDAILQe2RwABBLkGcksAAEHgAC0GsksAAQS5B3JLAABB4AAsLHQEBbyAAKAIAJQEgASACEAwhAxAzIgAgAyYBIAALCwAgACgCACABEEILDgBBuazAAEErIAAQeAALyQICBH8CfiAAKQMAIQYjAEEgayIDJABBFCEAAkAgBkKQzgBUBEAgBiEHDAELA0AgA0EMaiAAaiICQQRrIAYgBkKQzgCAIgdCkM4Afn2nIgRB//8DcUHkAG4iBUEBdEGer8AAai8AADsAACACQQJrIAQgBUHkAGxrQf//A3FBAXRBnq/AAGovAAA7AAAgAEEEayEAIAZC/8HXL1YgByEGDQALCwJAIAdC4wBYBEAgB6chAgwBCyAAQQJrIgAgA0EMamogB6ciAiACQf//A3FB5ABuIgJB5ABsa0H//wNxQQF0QZ6vwABqLwAAOwAACwJAIAJBCk8EQCAAQQJrIgAgA0EMamogAkEBdEGer8AAai8AADsAAAwBCyAAQQFrIgAgA0EMamogAkEwcjoAAAsgAUEBQQAgA0EMaiAAakEUIABrECEgA0EgaiQACw0AIABB/IjAACABECkLDgAgAUGUicAAQQUQmQELpwMCB38BfiAAKAIAIQAjAEHQAGsiAiQAIAJBIGogACAAKAIAKAIEEQIAIAIgAkHIAGqtQoCAgICABIQ3AyhBASEDIAJBATYCNCACQcSLwAA2AjAgAkIBNwI8IAIgAikDIDcCSCACIAJBKGo2AjgCQCABKAIUIgcgASgCGCIIIAJBMGoQKQ0AIAEtABxBBHFFBEBBACEDDAELIAJBGGogACAAKAIAKAIEEQIAIAJBKGqtQoCAgICABIQhCSACKAIcIQQgAigCGCEFQQAhAEEBIQYDQAJAIABBAXEEQCAEIQEgBSEADAELIAUhACAEIQEDQCAARQRAQQAhAwwECyACQRBqIAAgASgCGBECACACKAIUIQEgAigCECEAIAZBAWsiBg0ACwsgAEEARyEDIABFDQEgAkEIaiAAIAEoAhgRAgAgAigCDCEEIAIoAgghBSACIAE2AiwgAiAANgIoQQEhACACQQE2AjQgAkHQi8AANgIwIAJCATcCPCACIAk3A0ggAiACQcgAajYCOEEAIQYgByAIIAJBMGoQKUUNAAsLIAJB0ABqJAAgAwsNACAAQeSNwAAgARApCwkAIAAgARAOAAspAAJ/IAAoAgAtAABFBEAgAUH5sMAAQQUQHgwBCyABQf6wwABBBBAeCwsNACAAQayRwAAgARApC+4BAQZ/An8gACgCACECIwBBgAFrIgQkACABKAIEIQcgASgCACEGIAEoAhwiBSEAAkAgBUEEcUUNACAFQQhyIQAgBg0AIAFCgYCAgKABNwIACyABIABBBHI2AhxBACEAA0AgACAEakH/AGogAkEPcSIDQTByIANB1wBqIANBCkkbOgAAIABBAWshACACQRBJIAJBBHYhAkUNAAsgAEGAAWoiAkGBAUkEQCABQZyvwABBAiAAIARqQYABakEAIABrECEgASAFNgIcIAEgBzYCBCABIAY2AgAgBEGAAWokAAwBCyACQYABQYyvwAAQaAALCwwAIAAgASkCADcDAAsNACABQfCYwABBAhAeCw0AIABBhJzAACABECkLDgAgAUGvm8AAQQUQmQELDgAgAUG8p8AAQRIQmQELDQAgAEHQqcAAIAEQKQsOACABQcipwABBBRCZAQsZACAAIAFBjM/AACgCACIAQTogABsRAgAACw0AIABBzK7AACABECkLCgAgAiAAIAEQHguQBQEHfwJAAn8CQCACIgUgACABa0sEQCABIAJqIQMgACACaiECIAAgBUEQSQ0CGiACQXxxIQRBACACQQNxIgZrIQcgBgRAIANBAWshAANAIAJBAWsiAiAALQAAOgAAIABBAWshACACIARLDQALCyAEIAUgBmsiBkF8cSIFayECIAMgB2oiA0EDcQRAIAVBAEwNAiADQQN0IgBBGHEhByADQXxxIghBBGshAUEAIABrQRhxIQkgCCgCACEAA0AgBEEEayIEIAAgCXQgASgCACIAIAd2cjYCACABQQRrIQEgAiAESQ0ACwwCCyAFQQBMDQEgASAGakEEayEBA0AgBEEEayIEIAEoAgA2AgAgAUEEayEBIAIgBEkNAAsMAQsCQCAFQRBJBEAgACECDAELIABBACAAa0EDcSIDaiEEIAMEQCAAIQIgASEAA0AgAiAALQAAOgAAIABBAWohACACQQFqIgIgBEkNAAsLIAQgBSADayIFQXxxIgZqIQICQCABIANqIgNBA3EEQCAGQQBMDQEgA0EDdCIAQRhxIQcgA0F8cSIIQQRqIQFBACAAa0EYcSEJIAgoAgAhAANAIAQgACAHdiABKAIAIgAgCXRyNgIAIAFBBGohASAEQQRqIgQgAkkNAAsMAQsgBkEATA0AIAMhAQNAIAQgASgCADYCACABQQRqIQEgBEEEaiIEIAJJDQALCyAFQQNxIQUgAyAGaiEBCyAFRQ0CIAIgBWohAANAIAIgAS0AADoAACABQQFqIQEgAkEBaiICIABJDQALDAILIAZBA3EiAEUNASADIAVrIQMgAiAAawshACADQQFrIQEDQCACQQFrIgIgAS0AADoA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YTBhYWYvbGlicmFyeS9jb3JlL3NyYy9zbGljZS9pbmRleC5ycwB0AxAATwAAAGgDAAA0AAAAdAMQAE8AAABvAwAAMgAAAGFzc2VydGlvbiBmYWlsZWQ6IHNlbGYuaXNfY2hhcl9ib3VuZGFyeShuKS9ydXN0Yy85MGIzNWE2MjM5YzNkOGJkYWJjNTMwYTZhMDgxNmY3ZmY4OWEwYWFmL2xpYnJhcnkvYWxsb2Mvc3JjL3N0cmluZy5ycwAAAA4EEABLAAAAxAcAAB0AAAAOBBAASwAAAMwHAAAdAAAAHAAAAAwAAAAEAAAAHQAAAB4AAAAfAAAARXJyb3Jhc3NlcnRpb24gZmFpbGVkOiBzZWxmLmlzX2NoYXJfYm91bmRhcnkobmV3X2xlbikvcnVzdGMvOTBiMzVhNjIzOWMzZDhiZGFiYzUzMGE2YTA4MTZmN2ZmODlhMGFhZi9saWJyYXJ5L2FsbG9jL3NyYy9zdHJpbmcucnPJBBAASwAAAMAFAAANAAAAAAAAABAAAAAEAAAAIgAAACMAAAAkAAAAYmFja3RyYWNlIGNhcHR1cmUgZmFpbGVkL1VzZXJzL2RtYXJjb3MvLmNhcmdvL3JlZ2lzdHJ5L3NyYy9pbmRleC5jcmF0ZXMuaW8tNmYxN2QyMmJiYTE1MDAxZi9hbnlob3ctMS4wLjk4L3NyYy9lcnJvci5ycwAAVAUQAF4AAABnBAAADgAAAAEAAAAAAAAAOiAAAMwFEAACAAAACgpDYXVzZWQgYnk6CgAAACUAAAAMAAAABAAAACYAAAAnAAAAHwAAAAoKc3RhY2sgYmFja3RyYWNlOlN0YWNrIGJhY2t0cmFjZToKABIGEAARAAAAUwBBuIzAAAvZBAEAAAAoAAAAYSBEaXNwbGF5IGltcGxlbWVudGF0aW9uIHJldHVybmVkIGFuIGVycm9yIHVuZXhwZWN0ZWRseQDJBBAASwAAAHsKAAAOAAAAL3J1c3RjLzkwYjM1YTYyMzljM2Q4YmRhYmM1MzBhNmEwODE2ZjdmZjg5YTBhYWYvbGlicmFyeS9hbGxvYy9zcmMvdmVjL21vZC5yc4gGEABMAAAALQoAACQAAAAAAAAAEAAAAAQAAAAiAAAAIwAAACQAAAAgICAgOiAAAAEAAAAAAAAAAAcQAAIAAAAgICAgICAgL1VzZXJzL2RtYXJjb3MvLmNhcmdvL3JlZ2lzdHJ5L3NyYy9pbmRleC5jcmF0ZXMuaW8tNmYxN2QyMmJiYTE1MDAxZi9qcy1zeXMtMC4zLjc3L3NyYy9saWIucnMAGwcQAFwAAAD7GAAAAQAAAAAAAAAEAAAABAAAADUAAABjbG9zdXJlIGludm9rZWQgcmVjdXJzaXZlbHkgb3IgYWZ0ZXIgYmVpbmcgZHJvcHBlZExhenkgaW5zdGFuY2UgaGFzIHByZXZpb3VzbHkgYmVlbiBwb2lzb25lZMoHEAAqAAAAL1VzZXJzL2RtYXJjb3MvLmNhcmdvL3JlZ2lzdHJ5L3NyYy9pbmRleC5jcmF0ZXMuaW8tNmYxN2QyMmJiYTE1MDAxZi9vbmNlX2NlbGwtMS4yMS4zL3NyYy9saWIucnMA/AcQAF8AAAAIAwAAGQAAAHJlZW50cmFudCBpbml0AABsCBAADgAAAPwHEABfAAAAegIAAA0AQZyRwAALlQ8EAAAABAAAADsAAAA6AAAAPAAAAAwAAAAEAAAAPQAAAD4AAAA/AAAAL3J1c3QvZGVwcy9kbG1hbGxvYy0wLjIuNi9zcmMvZGxtYWxsb2MucnNhc3NlcnRpb24gZmFpbGVkOiBwc2l6ZSA+PSBzaXplICsgbWluX292ZXJoZWFkAMQIEAApAAAAqAQAAAkAAABhc3NlcnRpb24gZmFpbGVkOiBwc2l6ZSA8PSBzaXplICsgbWF4X292ZXJoZWFkAADECBAAKQAAAK4EAAANAAAAc3RkL3NyYy9iYWNrdHJhY2UucnNvcGVyYXRpb24gbm90IHN1cHBvcnRlZCBvbiB0aGlzIHBsYXRmb3JtgAkQACgAAAAkAAAAAAAAAAIAAACoCRAAdW5zdXBwb3J0ZWQgYmFja3RyYWNlZGlzYWJsZWQgYmFja3RyYWNlAGwJEAAUAAAAigEAAB0AAABAAAAAEAAAAAQAAABBAAAAQgAAAAEAAAAAAAAAOiBzdGQvc3JjL3N5bmMvbGF6eV9sb2NrLnJzABYKEAAZAAAA0AAAABMAAABjYW5ub3QgcmVjdXJzaXZlbHkgYWNxdWlyZSBtdXRleEAKEAAgAAAAc3RkL3NyYy9zeXMvc3luYy9tdXRleC9ub190aHJlYWRzLnJzaAoQACQAAAAUAAAACQAAAHN0ZC9zcmMvc3luYy9v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Zm9ybWF0dGluZyB0cmFpdCBpbXBsZW1lbnRhdGlvbiByZXR1cm5lZCBhbiBlcnJvciB3aGVuIHRoZSB1bmRlcmx5aW5nIHN0cmVhbSBkaWQgbm90YWxsb2Mvc3JjL2ZtdC5ycwAAjhUQABAAAAB+AgAADgAAAGZyb21fc3RyX3JhZGl4X2ludDogbXVzdCBsaWUgaW4gdGhlIHJhbmdlIGBbMiwgMzZdYCAtIGZvdW5kILAVEAA8AAAALi4wMTIzNDU2Nzg5YWJjZGVmQm9ycm93TXV0RXJyb3JhbHJlYWR5IGJvcnJvd2VkOiAAABQWEAASAAAAAQAAAAAAAABbY2FsbGVkIGBPcHRpb246OnVud3JhcCgpYCBvbiBhIGBOb25lYCB2YWx1ZWluZGV4IG91dCBvZiBib3VuZHM6IHRoZSBsZW4gaXMgIGJ1dCB0aGUgaW5kZXggaXMgAABkFhAAIAAAAIQWEAASAAAAPT0hPW1hdGNoZXNhc3NlcnRpb24gYGxlZnQgIHJpZ2h0YCBmYWlsZWQKICBsZWZ0OiAKIHJpZ2h0OiAAsxYQABAAAADDFhAAFwAAANoWEAAJAAAAIHJpZ2h0YCBmYWlsZWQ6IAogIGxlZnQ6IAAAALMWEAAQAAAA/BYQABAAAAAMFxAACQAAANoWEAAJAAAAOiAAAAEAAAAAAAAAOBcQAAIAAAAAAAAADAAAAAQAAABlAAAAZgAAAGcAAAAgICAgIHsgLCAgewosCn0gfQpdY29yZS9zcmMvZm10L251bS5ycwAAdxcQABMAAABmAAAAFwAAADB4MDAwMTAyMDMwNDA1MDYwNzA4MDkxMDExMTIxMzE0MTUxNjE3MTgxOTIwMjEyMjIzMjQyNTI2MjcyODI5MzAzMTMyMzMzNDM1MzYzNzM4Mzk0MDQxNDI0MzQ0NDU0NjQ3NDg0OTUwNTE1MjUzNTQ1NTU2NTc1ODU5NjA2MTYyNjM2NDY1NjY2NzY4Njk3MDcxNzI3Mzc0NzU3Njc3Nzg3OTgwODE4MjgzODQ4NTg2ODc4ODg5OTA5MTkyOTM5NDk1OTY5Nzk4OTljb3JlL3NyYy9mbXQvbW9kLnJzZmFsc2V0cnVlAABmGBAAEwAAAKMJAAAmAAAAZhgQABMAAACsCQAAGgAAAHJhbmdlIHN0YXJ0IGluZGV4ICBvdXQgb2Yg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", self.location.href);\n    }\n    const imports = __wbg_get_imports();\n    if (typeof module_or_path === "string" || typeof Request === "function" && module_or_path instanceof Request || typeof URL === "function" && module_or_path instanceof URL) {\n      module_or_path = fetch(module_or_path);\n    }\n    const { instance, module } = await __wbg_load(await module_or_path, imports);\n    return __wbg_finalize_init(instance, module);\n  }\n  var u8 = Uint8Array, u16 = Uint16Array, i32 = Int32Array;\n  var fleb = new u8([\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    1,\n    1,\n    1,\n    1,\n    2,\n    2,\n    2,\n    2,\n    3,\n    3,\n    3,\n    3,\n    4,\n    4,\n    4,\n    4,\n    5,\n    5,\n    5,\n    5,\n    0,\n    /* unused */\n    0,\n    0,\n    /* impossible */\n    0\n  ]);\n  var fdeb = new u8([\n    0,\n    0,\n    0,\n    0,\n    1,\n    1,\n    2,\n    2,\n    3,\n    3,\n    4,\n    4,\n    5,\n    5,\n    6,\n    6,\n    7,\n    7,\n    8,\n    8,\n    9,\n    9,\n    10,\n    10,\n    11,\n    11,\n    12,\n    12,\n    13,\n    13,\n    /* unused */\n    0,\n    0\n  ]);\n  var clim = new u8([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);\n  var freb = function(eb, start) {\n    var b = new u16(31);\n    for (var i2 = 0; i2 < 31; ++i2) {\n      b[i2] = start += 1 << eb[i2 - 1];\n    }\n    var r = new i32(b[30]);\n    for (var i2 = 1; i2 < 30; ++i2) {\n      for (var j = b[i2]; j < b[i2 + 1]; ++j) {\n        r[j] = j - b[i2] << 5 | i2;\n      }\n    }\n    return { b, r };\n  };\n  var _a = freb(fleb, 2), fl = _a.b, revfl = _a.r;\n  fl[28] = 258, revfl[258] = 28;\n  var _b = freb(fdeb, 0), fd = _b.b;\n  var rev = new u16(32768);\n  for (var i = 0; i < 32768; ++i) {\n    var x = (i & 43690) >> 1 | (i & 21845) << 1;\n    x = (x & 52428) >> 2 | (x & 13107) << 2;\n    x = (x & 61680) >> 4 | (x & 3855) << 4;\n    rev[i] = ((x & 65280) >> 8 | (x & 255) << 8) >> 1;\n  }\n  var hMap = function(cd, mb, r) {\n    var s = cd.length;\n    var i2 = 0;\n    var l = new u16(mb);\n    for (; i2 < s; ++i2) {\n      if (cd[i2])\n        ++l[cd[i2] - 1];\n    }\n    var le = new u16(mb);\n    for (i2 = 1; i2 < mb; ++i2) {\n      le[i2] = le[i2 - 1] + l[i2 - 1] << 1;\n    }\n    var co;\n    if (r) {\n      co = new u16(1 << mb);\n      var rvb = 15 - mb;\n      for (i2 = 0; i2 < s; ++i2) {\n        if (cd[i2]) {\n          var sv = i2 << 4 | cd[i2];\n          var r_1 = mb - cd[i2];\n          var v = le[cd[i2] - 1]++ << r_1;\n          for (var m = v | (1 << r_1) - 1; v <= m; ++v) {\n            co[rev[v] >> rvb] = sv;\n          }\n        }\n      }\n    } else {\n      co = new u16(s);\n      for (i2 = 0; i2 < s; ++i2) {\n        if (cd[i2]) {\n          co[i2] = rev[le[cd[i2] - 1]++] >> 15 - cd[i2];\n        }\n      }\n    }\n    return co;\n  };\n  var flt = new u8(288);\n  for (var i = 0; i < 144; ++i)\n    flt[i] = 8;\n  for (var i = 144; i < 256; ++i)\n    flt[i] = 9;\n  for (var i = 256; i < 280; ++i)\n    flt[i] = 7;\n  for (var i = 280; i < 288; ++i)\n    flt[i] = 8;\n  var fdt = new u8(32);\n  for (var i = 0; i < 32; ++i)\n    fdt[i] = 5;\n  var flrm = /* @__PURE__ */ hMap(flt, 9, 1);\n  var fdrm = /* @__PURE__ */ hMap(fdt, 5, 1);\n  var max = function(a) {\n    var m = a[0];\n    for (var i2 = 1; i2 < a.length; ++i2) {\n      if (a[i2] > m)\n        m = a[i2];\n    }\n    return m;\n  };\n  var bits = function(d, p, m) {\n    var o = p / 8 | 0;\n    return (d[o] | d[o + 1] << 8) >> (p & 7) & m;\n  };\n  var bits16 = function(d, p) {\n    var o = p / 8 | 0;\n    return (d[o] | d[o + 1] << 8 | d[o + 2] << 16) >> (p & 7);\n  };\n  var shft = function(p) {\n    return (p + 7) / 8 | 0;\n  };\n  var slc = function(v, s, e) {\n    if (s == null || s < 0)\n      s = 0;\n    if (e == null || e > v.length)\n      e = v.length;\n    return new u8(v.subarray(s, e));\n  };\n  var ec = [\n    "unexpected EOF",\n    "invalid block type",\n    "invalid length/literal",\n    "invalid distance",\n    "stream finished",\n    "no stream handler",\n    ,\n    "no callback",\n    "invalid UTF-8 data",\n    "extra field too long",\n    "date not in range 1980-2099",\n    "filename too long",\n    "stream finishing",\n    "invalid zip data"\n    // determined by unknown compression method\n  ];\n  var err = function(ind, msg, nt) {\n    var e = new Error(msg || ec[ind]);\n    e.code = ind;\n    if (Error.captureStackTrace)\n      Error.captureStackTrace(e, err);\n    if (!nt)\n      throw e;\n    return e;\n  };\n  var inflt = function(dat, st, buf, dict) {\n    var sl = dat.length, dl = 0;\n    if (!sl || st.f && !st.l)\n      return buf || new u8(0);\n    var noBuf = !buf;\n    var resize = noBuf || st.i != 2;\n    var noSt = st.i;\n    if (noBuf)\n      buf = new u8(sl * 3);\n    var cbuf = function(l2) {\n      var bl = buf.length;\n      if (l2 > bl) {\n        var nbuf = new u8(Math.max(bl * 2, l2));\n        nbuf.set(buf);\n        buf = nbuf;\n      }\n    };\n    var final = st.f || 0, pos = st.p || 0, bt = st.b || 0, lm = st.l, dm = st.d, lbt = st.m, dbt = st.n;\n    var tbts = sl * 8;\n    do {\n      if (!lm) {\n        final = bits(dat, pos, 1);\n        var type = bits(dat, pos + 1, 3);\n        pos += 3;\n        if (!type) {\n          var s = shft(pos) + 4, l = dat[s - 4] | dat[s - 3] << 8, t = s + l;\n          if (t > sl) {\n            if (noSt)\n              err(0);\n            break;\n          }\n          if (resize)\n            cbuf(bt + l);\n          buf.set(dat.subarray(s, t), bt);\n          st.b = bt += l, st.p = pos = t * 8, st.f = final;\n          continue;\n        } else if (type == 1)\n          lm = flrm, dm = fdrm, lbt = 9, dbt = 5;\n        else if (type == 2) {\n          var hLit = bits(dat, pos, 31) + 257, hcLen = bits(dat, pos + 10, 15) + 4;\n          var tl = hLit + bits(dat, pos + 5, 31) + 1;\n          pos += 14;\n          var ldt = new u8(tl);\n          var clt = new u8(19);\n          for (var i2 = 0; i2 < hcLen; ++i2) {\n            clt[clim[i2]] = bits(dat, pos + i2 * 3, 7);\n          }\n          pos += hcLen * 3;\n          var clb = max(clt), clbmsk = (1 << clb) - 1;\n          var clm = hMap(clt, clb, 1);\n          for (var i2 = 0; i2 < tl; ) {\n            var r = clm[bits(dat, pos, clbmsk)];\n            pos += r & 15;\n            var s = r >> 4;\n            if (s < 16) {\n              ldt[i2++] = s;\n            } else {\n              var c = 0, n = 0;\n              if (s == 16)\n                n = 3 + bits(dat, pos, 3), pos += 2, c = ldt[i2 - 1];\n              else if (s == 17)\n                n = 3 + bits(dat, pos, 7), pos += 3;\n              else if (s == 18)\n                n = 11 + bits(dat, pos, 127), pos += 7;\n              while (n--)\n                ldt[i2++] = c;\n            }\n          }\n          var lt = ldt.subarray(0, hLit), dt = ldt.subarray(hLit);\n          lbt = max(lt);\n          dbt = max(dt);\n          lm = hMap(lt, lbt, 1);\n          dm = hMap(dt, dbt, 1);\n        } else\n          err(1);\n        if (pos > tbts) {\n          if (noSt)\n            err(0);\n          break;\n        }\n      }\n      if (resize)\n        cbuf(bt + 131072);\n      var lms = (1 << lbt) - 1, dms = (1 << dbt) - 1;\n      var lpos = pos;\n      for (; ; lpos = pos) {\n        var c = lm[bits16(dat, pos) & lms], sym = c >> 4;\n        pos += c & 15;\n        if (pos > tbts) {\n          if (noSt)\n            err(0);\n          break;\n        }\n        if (!c)\n          err(2);\n        if (sym < 256)\n          buf[bt++] = sym;\n        else if (sym == 256) {\n          lpos = pos, lm = null;\n          break;\n        } else {\n          var add2 = sym - 254;\n          if (sym > 264) {\n            var i2 = sym - 257, b = fleb[i2];\n            add2 = bits(dat, pos, (1 << b) - 1) + fl[i2];\n            pos += b;\n          }\n          var d = dm[bits16(dat, pos) & dms], dsym = d >> 4;\n          if (!d)\n            err(3);\n          pos += d & 15;\n          var dt = fd[dsym];\n          if (dsym > 3) {\n            var b = fdeb[dsym];\n            dt += bits16(dat, pos) & (1 << b) - 1, pos += b;\n          }\n          if (pos > tbts) {\n            if (noSt)\n              err(0);\n            break;\n          }\n          if (resize)\n            cbuf(bt + 131072);\n          var end = bt + add2;\n          if (bt < dt) {\n            var shift = dl - dt, dend = Math.min(dt, end);\n            if (shift + bt < 0)\n              err(3);\n            for (; bt < dend; ++bt)\n              buf[bt] = dict[shift + bt];\n          }\n          for (; bt < end; ++bt)\n            buf[bt] = buf[bt - dt];\n        }\n      }\n      st.l = lm, st.p = lpos, st.b = bt, st.f = final;\n      if (lm)\n        final = 1, st.m = lbt, st.d = dm, st.n = dbt;\n    } while (!final);\n    return bt != buf.length && noBuf ? slc(buf, 0, bt) : buf.subarray(0, bt);\n  };\n  var et = /* @__PURE__ */ new u8(0);\n  var gzs = function(d) {\n    if (d[0] != 31 || d[1] != 139 || d[2] != 8)\n      err(6, "invalid gzip data");\n    var flg = d[3];\n    var st = 10;\n    if (flg & 4)\n      st += (d[10] | d[11] << 8) + 2;\n    for (var zs = (flg >> 3 & 1) + (flg >> 4 & 1); zs > 0; zs -= !d[st++])\n      ;\n    return st + (flg & 2);\n  };\n  var Inflate = /* @__PURE__ */ function() {\n    function Inflate2(opts, cb) {\n      if (typeof opts == "function")\n        cb = opts, opts = {};\n      this.ondata = cb;\n      var dict = opts && opts.dictionary && opts.dictionary.subarray(-32768);\n      this.s = { i: 0, b: dict ? dict.length : 0 };\n      this.o = new u8(32768);\n      this.p = new u8(0);\n      if (dict)\n        this.o.set(dict);\n    }\n    Inflate2.prototype.e = function(c) {\n      if (!this.ondata)\n        err(5);\n      if (this.d)\n        err(4);\n      if (!this.p.length)\n        this.p = c;\n      else if (c.length) {\n        var n = new u8(this.p.length + c.length);\n        n.set(this.p), n.set(c, this.p.length), this.p = n;\n      }\n    };\n    Inflate2.prototype.c = function(final) {\n      this.s.i = +(this.d = final || false);\n      var bts = this.s.b;\n      var dt = inflt(this.p, this.s, this.o);\n      this.ondata(slc(dt, bts, this.s.b), this.d);\n      this.o = slc(dt, this.s.b - 32768), this.s.b = this.o.length;\n      this.p = slc(this.p, this.s.p / 8 | 0), this.s.p &= 7;\n    };\n    Inflate2.prototype.push = function(chunk, final) {\n      this.e(chunk), this.c(final);\n    };\n    return Inflate2;\n  }();\n  var Gunzip = /* @__PURE__ */ function() {\n    function Gunzip2(opts, cb) {\n      this.v = 1;\n      this.r = 0;\n      Inflate.call(this, opts, cb);\n    }\n    Gunzip2.prototype.push = function(chunk, final) {\n      Inflate.prototype.e.call(this, chunk);\n      this.r += chunk.length;\n      if (this.v) {\n        var p = this.p.subarray(this.v - 1);\n        var s = p.length > 3 ? gzs(p) : 4;\n        if (s > p.length) {\n          if (!final)\n            return;\n        } else if (this.v > 1 && this.onmember) {\n          this.onmember(this.r - p.length);\n        }\n        this.p = p.subarray(s), this.v = 0;\n      }\n      Inflate.prototype.c.call(this, final);\n      if (this.s.f && !this.s.l && !final) {\n        this.v = shft(this.s.p) + 9;\n        this.s = { i: 0 };\n        this.o = new u8(0);\n        this.push(new u8(0), final);\n      }\n    };\n    return Gunzip2;\n  }();\n  var td = typeof TextDecoder != "undefined" && /* @__PURE__ */ new TextDecoder();\n  var tds = 0;\n  try {\n    td.decode(et, { stream: true });\n    tds = 1;\n  } catch (e) {\n  }\n  /**\n   * @license\n   * Copyright 2010-2024 Three.js Authors\n   * SPDX-License-Identifier: MIT\n   */\n  const REVISION = "172";\n  const FrontSide = 0;\n  const BackSide = 1;\n  const NormalBlending = 1;\n  const AddEquation = 100;\n  const SrcAlphaFactor = 204;\n  const OneMinusSrcAlphaFactor = 205;\n  const LessEqualDepth = 3;\n  const MultiplyOperation = 0;\n  const UVMapping = 300;\n  const RepeatWrapping = 1e3;\n  const ClampToEdgeWrapping = 1001;\n  const MirroredRepeatWrapping = 1002;\n  const NearestFilter = 1003;\n  const LinearFilter = 1006;\n  const LinearMipmapLinearFilter = 1008;\n  const UnsignedByteType = 1009;\n  const UnsignedIntType = 1014;\n  const FloatType = 1015;\n  const RGBAFormat = 1023;\n  const RGIntegerFormat = 1031;\n  const RGBAIntegerFormat = 1033;\n  const NoColorSpace = "";\n  const SRGBColorSpace = "srgb";\n  const LinearSRGBColorSpace = "srgb-linear";\n  const LinearTransfer = "linear";\n  const SRGBTransfer = "srgb";\n  const KeepStencilOp = 7680;\n  const AlwaysStencilFunc = 519;\n  const StaticDrawUsage = 35044;\n  const GLSL3 = "300 es";\n  const WebGLCoordinateSystem = 2e3;\n  const WebGPUCoordinateSystem = 2001;\n  class EventDispatcher {\n    addEventListener(type, listener) {\n      if (this._listeners === void 0) this._listeners = {};\n      const listeners = this._listeners;\n      if (listeners[type] === void 0) {\n        listeners[type] = [];\n      }\n      if (listeners[type].indexOf(listener) === -1) {\n        listeners[type].push(listener);\n      }\n    }\n    hasEventListener(type, listener) {\n      if (this._listeners === void 0) return false;\n      const listeners = this._listeners;\n      return listeners[type] !== void 0 && listeners[type].indexOf(listener) !== -1;\n    }\n    removeEventListener(type, listener) {\n      if (this._listeners === void 0) return;\n      const listeners = this._listeners;\n      const listenerArray = listeners[type];\n      if (listenerArray !== void 0) {\n        const index = listenerArray.indexOf(listener);\n        if (index !== -1) {\n          listenerArray.splice(index, 1);\n        }\n      }\n    }\n    dispatchEvent(event) {\n      if (this._listeners === void 0) return;\n      const listeners = this._listeners;\n      const listenerArray = listeners[event.type];\n      if (listenerArray !== void 0) {\n        event.target = this;\n        const array = listenerArray.slice(0);\n        for (let i2 = 0, l = array.length; i2 < l; i2++) {\n          array[i2].call(this, event);\n        }\n        event.target = null;\n      }\n    }\n  }\n  const _lut = ["00", "01", "02", "03", "04", "05", "06", "07", "08", "09", "0a", "0b", "0c", "0d", "0e", "0f", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "1a", "1b", "1c", "1d", "1e", "1f", "20", "21", "22", "23", "24", "25", "26", "27", "28", "29", "2a", "2b", "2c", "2d", "2e", "2f", "30", "31", "32", "33", "34", "35", "36", "37", "38", "39", "3a", "3b", "3c", "3d", "3e", "3f", "40", "41", "42", "43", "44", "45", "46", "47", "48", "49", "4a", "4b", "4c", "4d", "4e", "4f", "50", "51", "52", "53", "54", "55", "56", "57", "58", "59", "5a", "5b", "5c", "5d", "5e", "5f", "60", "61", "62", "63", "64", "65", "66", "67", "68", "69", "6a", "6b", "6c", "6d", "6e", "6f", "70", "71", "72", "73", "74", "75", "76", "77", "78", "79", "7a", "7b", "7c", "7d", "7e", "7f", "80", "81", "82", "83", "84", "85", "86", "87", "88", "89", "8a", "8b", "8c", "8d", "8e", "8f", "90", "91", "92", "93", "94", "95", "96", "97", "98", "99", "9a", "9b", "9c", "9d", "9e", "9f", "a0", "a1", "a2", "a3", "a4", "a5", "a6", "a7", "a8", "a9", "aa", "ab", "ac", "ad", "ae", "af", "b0", "b1", "b2", "b3", "b4", "b5", "b6", "b7", "b8", "b9", "ba", "bb", "bc", "bd", "be", "bf", "c0", "c1", "c2", "c3", "c4", "c5", "c6", "c7", "c8", "c9", "ca", "cb", "cc", "cd", "ce", "cf", "d0", "d1", "d2", "d3", "d4", "d5", "d6", "d7", "d8", "d9", "da", "db", "dc", "dd", "de", "df", "e0", "e1", "e2", "e3", "e4", "e5", "e6", "e7", "e8", "e9", "ea", "eb", "ec", "ed", "ee", "ef", "f0", "f1", "f2", "f3", "f4", "f5", "f6", "f7", "f8", "f9", "fa", "fb", "fc", "fd", "fe", "ff"];\n  function generateUUID() {\n    const d0 = Math.random() * 4294967295 | 0;\n    const d1 = Math.random() * 4294967295 | 0;\n    const d2 = Math.random() * 4294967295 | 0;\n    const d3 = Math.random() * 4294967295 | 0;\n    const uuid = _lut[d0 & 255] + _lut[d0 >> 8 & 255] + _lut[d0 >> 16 & 255] + _lut[d0 >> 24 & 255] + "-" + _lut[d1 & 255] + _lut[d1 >> 8 & 255] + "-" + _lut[d1 >> 16 & 15 | 64] + _lut[d1 >> 24 & 255] + "-" + _lut[d2 & 63 | 128] + _lut[d2 >> 8 & 255] + "-" + _lut[d2 >> 16 & 255] + _lut[d2 >> 24 & 255] + _lut[d3 & 255] + _lut[d3 >> 8 & 255] + _lut[d3 >> 16 & 255] + _lut[d3 >> 24 & 255];\n    return uuid.toLowerCase();\n  }\n  function clamp(value, min, max2) {\n    return Math.max(min, Math.min(max2, value));\n  }\n  function euclideanModulo(n, m) {\n    return (n % m + m) % m;\n  }\n  function lerp(x2, y, t) {\n    return (1 - t) * x2 + t * y;\n  }\n  function denormalize(value, array) {\n    switch (array.constructor) {\n      case Float32Array:\n        return value;\n      case Uint32Array:\n        return value / 4294967295;\n      case Uint16Array:\n        return value / 65535;\n      case Uint8Array:\n        return value / 255;\n      case Int32Array:\n        return Math.max(value / 2147483647, -1);\n      case Int16Array:\n        return Math.max(value / 32767, -1);\n      case Int8Array:\n        return Math.max(value / 127, -1);\n      default:\n        throw new Error("Invalid component type.");\n    }\n  }\n  function normalize$1(value, array) {\n    switch (array.constructor) {\n      case Float32Array:\n        return value;\n      case Uint32Array:\n        return Math.round(value * 4294967295);\n      case Uint16Array:\n        return Math.round(value * 65535);\n      case Uint8Array:\n        return Math.round(value * 255);\n      case Int32Array:\n        return Math.round(value * 2147483647);\n      case Int16Array:\n        return Math.round(value * 32767);\n      case Int8Array:\n        return Math.round(value * 127);\n      default:\n        throw new Error("Invalid component type.");\n    }\n  }\n  class Vector2 {\n    constructor(x2 = 0, y = 0) {\n      Vector2.prototype.isVector2 = true;\n      this.x = x2;\n      this.y = y;\n    }\n    get width() {\n      return this.x;\n    }\n    set width(value) {\n      this.x = value;\n    }\n    get height() {\n      return this.y;\n    }\n    set height(value) {\n      this.y = value;\n    }\n    set(x2, y) {\n      this.x = x2;\n      this.y = y;\n      return this;\n    }\n    setScalar(scalar) {\n      this.x = scalar;\n      this.y = scalar;\n      return this;\n    }\n    setX(x2) {\n      this.x = x2;\n      return this;\n    }\n    setY(y) {\n      this.y = y;\n      return this;\n    }\n    setComponent(index, value) {\n      switch (index) {\n        case 0:\n          this.x = value;\n          break;\n        case 1:\n          this.y = value;\n          break;\n        default:\n          throw new Error("index is out of range: " + index);\n      }\n      return this;\n    }\n    getComponent(index) {\n      switch (index) {\n        case 0:\n          return this.x;\n        case 1:\n          return this.y;\n        default:\n          throw new Error("index is out of range: " + index);\n      }\n    }\n    clone() {\n      return new this.constructor(this.x, this.y);\n    }\n    copy(v) {\n      this.x = v.x;\n      this.y = v.y;\n      return this;\n    }\n    add(v) {\n      this.x += v.x;\n      this.y += v.y;\n      return this;\n    }\n    addScalar(s) {\n      this.x += s;\n      this.y += s;\n      return this;\n    }\n    addVectors(a, b) {\n      this.x = a.x + b.x;\n      this.y = a.y + b.y;\n      return this;\n    }\n    addScaledVector(v, s) {\n      this.x += v.x * s;\n      this.y += v.y * s;\n      return this;\n    }\n    sub(v) {\n      this.x -= v.x;\n      this.y -= v.y;\n      return this;\n    }\n    subScalar(s) {\n      this.x -= s;\n      this.y -= s;\n      return this;\n    }\n    subVectors(a, b) {\n      this.x = a.x - b.x;\n      this.y = a.y - b.y;\n      return this;\n    }\n    multiply(v) {\n      this.x *= v.x;\n      this.y *= v.y;\n      return this;\n    }\n    multiplyScalar(scalar) {\n      this.x *= scalar;\n      this.y *= scalar;\n      return this;\n    }\n    divide(v) {\n      this.x /= v.x;\n      this.y /= v.y;\n      return this;\n    }\n    divideScalar(scalar) {\n      return this.multiplyScalar(1 / scalar);\n    }\n    applyMatrix3(m) {\n      const x2 = this.x, y = this.y;\n      const e = m.elements;\n      this.x = e[0] * x2 + e[3] * y + e[6];\n      this.y = e[1] * x2 + e[4] * y + e[7];\n      return this;\n    }\n    min(v) {\n      this.x = Math.min(this.x, v.x);\n      this.y = Math.min(this.y, v.y);\n      return this;\n    }\n    max(v) {\n      this.x = Math.max(this.x, v.x);\n      this.y = Math.max(this.y, v.y);\n      return this;\n    }\n    clamp(min, max2) {\n      this.x = clamp(this.x, min.x, max2.x);\n      this.y = clamp(this.y, min.y, max2.y);\n      return this;\n    }\n    clampScalar(minVal, maxVal) {\n      this.x = clamp(this.x, minVal, maxVal);\n      this.y = clamp(this.y, minVal, maxVal);\n      return this;\n    }\n    clampLength(min, max2) {\n      const length = this.length();\n      return this.divideScalar(length || 1).multiplyScalar(clamp(length, min, max2));\n    }\n    floor() {\n      this.x = Math.floor(this.x);\n      this.y = Math.floor(this.y);\n      return this;\n    }\n    ceil() {\n      this.x = Math.ceil(this.x);\n      this.y = Math.ceil(this.y);\n      return this;\n    }\n    round() {\n      this.x = Math.round(this.x);\n      this.y = Math.round(this.y);\n      return this;\n    }\n    roundToZero() {\n      this.x = Math.trunc(this.x);\n      this.y = Math.trunc(this.y);\n      return this;\n    }\n    negate() {\n      this.x = -this.x;\n      this.y = -this.y;\n      return this;\n    }\n    dot(v) {\n      return this.x * v.x + this.y * v.y;\n    }\n    cross(v) {\n      return this.x * v.y - this.y * v.x;\n    }\n    lengthSq() {\n      return this.x * this.x + this.y * this.y;\n    }\n    length() {\n      return Math.sqrt(this.x * this.x + this.y * this.y);\n    }\n    manhattanLength() {\n      return Math.abs(this.x) + Math.abs(this.y);\n    }\n    normalize() {\n      return this.divideScalar(this.length() || 1);\n    }\n    angle() {\n      const angle = Math.atan2(-this.y, -this.x) + Math.PI;\n      return angle;\n    }\n    angleTo(v) {\n      const denominator = Math.sqrt(this.lengthSq() * v.lengthSq());\n      if (denominator === 0) return Math.PI / 2;\n      const theta = this.dot(v) / denominator;\n      return Math.acos(clamp(theta, -1, 1));\n    }\n    distanceTo(v) {\n      return Math.sqrt(this.distanceToSquared(v));\n    }\n    distanceToSquared(v) {\n      const dx = this.x - v.x, dy = this.y - v.y;\n      return dx * dx + dy * dy;\n    }\n    manhattanDistanceTo(v) {\n      return Math.abs(this.x - v.x) + Math.abs(this.y - v.y);\n    }\n    setLength(length) {\n      return this.normalize().multiplyScalar(length);\n    }\n    lerp(v, alpha) {\n      this.x += (v.x - this.x) * alpha;\n      this.y += (v.y - this.y) * alpha;\n      return this;\n    }\n    lerpVectors(v1, v2, alpha) {\n      this.x = v1.x + (v2.x - v1.x) * alpha;\n      this.y = v1.y + (v2.y - v1.y) * alpha;\n      return this;\n    }\n    equals(v) {\n      return v.x === this.x && v.y === this.y;\n    }\n    fromArray(array, offset = 0) {\n      this.x = array[offset];\n      this.y = array[offset + 1];\n      return this;\n    }\n    toArray(array = [], offset = 0) {\n      array[offset] = this.x;\n      array[offset + 1] = this.y;\n      return array;\n    }\n    fromBufferAttribute(attribute, index) {\n      this.x = attribute.getX(index);\n      this.y = attribute.getY(index);\n      return this;\n    }\n    rotateAround(center, angle) {\n      const c = Math.cos(angle), s = Math.sin(angle);\n      const x2 = this.x - center.x;\n      const y = this.y - center.y;\n      this.x = x2 * c - y * s + center.x;\n      this.y = x2 * s + y * c + center.y;\n      return this;\n    }\n    random() {\n      this.x = Math.random();\n      this.y = Math.random();\n      return this;\n    }\n    *[Symbol.iterator]() {\n      yield this.x;\n      yield this.y;\n    }\n  }\n  class Matrix3 {\n    constructor(n11, n12, n13, n21, n22, n23, n31, n32, n33) {\n      Matrix3.prototype.isMatrix3 = true;\n      this.elements = [\n        1,\n        0,\n        0,\n        0,\n        1,\n        0,\n        0,\n        0,\n        1\n      ];\n      if (n11 !== void 0) {\n        this.set(n11, n12, n13, n21, n22, n23, n31, n32, n33);\n      }\n    }\n    set(n11, n12, n13, n21, n22, n23, n31, n32, n33) {\n      const te = this.elements;\n      te[0] = n11;\n      te[1] = n21;\n      te[2] = n31;\n      te[3] = n12;\n      te[4] = n22;\n      te[5] = n32;\n      te[6] = n13;\n      te[7] = n23;\n      te[8] = n33;\n      return this;\n    }\n    identity() {\n      this.set(\n        1,\n        0,\n        0,\n        0,\n        1,\n        0,\n        0,\n        0,\n        1\n      );\n      return this;\n    }\n    copy(m) {\n      const te = this.elements;\n      const me = m.elements;\n      te[0] = me[0];\n      te[1] = me[1];\n      te[2] = me[2];\n      te[3] = me[3];\n      te[4] = me[4];\n      te[5] = me[5];\n      te[6] = me[6];\n      te[7] = me[7];\n      te[8] = me[8];\n      return this;\n    }\n    extractBasis(xAxis, yAxis, zAxis) {\n      xAxis.setFromMatrix3Column(this, 0);\n      yAxis.setFromMatrix3Column(this, 1);\n      zAxis.setFromMatrix3Column(this, 2);\n      return this;\n    }\n    setFromMatrix4(m) {\n      const me = m.elements;\n      this.set(\n        me[0],\n        me[4],\n        me[8],\n        me[1],\n        me[5],\n        me[9],\n        me[2],\n        me[6],\n        me[10]\n      );\n      return this;\n    }\n    multiply(m) {\n      return this.multiplyMatrices(this, m);\n    }\n    premultiply(m) {\n      return this.multiplyMatrices(m, this);\n    }\n    multiplyMatrices(a, b) {\n      const ae = a.elements;\n      const be = b.elements;\n      const te = this.elements;\n      const a11 = ae[0], a12 = ae[3], a13 = ae[6];\n      const a21 = ae[1], a22 = ae[4], a23 = ae[7];\n      const a31 = ae[2], a32 = ae[5], a33 = ae[8];\n      const b11 = be[0], b12 = be[3], b13 = be[6];\n      const b21 = be[1], b22 = be[4], b23 = be[7];\n      const b31 = be[2], b32 = be[5], b33 = be[8];\n      te[0] = a11 * b11 + a12 * b21 + a13 * b31;\n      te[3] = a11 * b12 + a12 * b22 + a13 * b32;\n      te[6] = a11 * b13 + a12 * b23 + a13 * b33;\n      te[1] = a21 * b11 + a22 * b21 + a23 * b31;\n      te[4] = a21 * b12 + a22 * b22 + a23 * b32;\n      te[7] = a21 * b13 + a22 * b23 + a23 * b33;\n      te[2] = a31 * b11 + a32 * b21 + a33 * b31;\n      te[5] = a31 * b12 + a32 * b22 + a33 * b32;\n      te[8] = a31 * b13 + a32 * b23 + a33 * b33;\n      return this;\n    }\n    multiplyScalar(s) {\n      const te = this.elements;\n      te[0] *= s;\n      te[3] *= s;\n      te[6] *= s;\n      te[1] *= s;\n      te[4] *= s;\n      te[7] *= s;\n      te[2] *= s;\n      te[5] *= s;\n      te[8] *= s;\n      return this;\n    }\n    determinant() {\n      const te = this.elements;\n      const a = te[0], b = te[1], c = te[2], d = te[3], e = te[4], f = te[5], g = te[6], h = te[7], i2 = te[8];\n      return a * e * i2 - a * f * h - b * d * i2 + b * f * g + c * d * h - c * e * g;\n    }\n    invert() {\n      const te = this.elements, n11 = te[0], n21 = te[1], n31 = te[2], n12 = te[3], n22 = te[4], n32 = te[5], n13 = te[6], n23 = te[7], n33 = te[8], t11 = n33 * n22 - n32 * n23, t12 = n32 * n13 - n33 * n12, t13 = n23 * n12 - n22 * n13, det = n11 * t11 + n21 * t12 + n31 * t13;\n      if (det === 0) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);\n      const detInv = 1 / det;\n      te[0] = t11 * detInv;\n      te[1] = (n31 * n23 - n33 * n21) * detInv;\n      te[2] = (n32 * n21 - n31 * n22) * detInv;\n      te[3] = t12 * detInv;\n      te[4] = (n33 * n11 - n31 * n13) * detInv;\n      te[5] = (n31 * n12 - n32 * n11) * detInv;\n      te[6] = t13 * detInv;\n      te[7] = (n21 * n13 - n23 * n11) * detInv;\n      te[8] = (n22 * n11 - n21 * n12) * detInv;\n      return this;\n    }\n    transpose() {\n      let tmp;\n      const m = this.elements;\n      tmp = m[1];\n      m[1] = m[3];\n      m[3] = tmp;\n      tmp = m[2];\n      m[2] = m[6];\n      m[6] = tmp;\n      tmp = m[5];\n      m[5] = m[7];\n      m[7] = tmp;\n      return this;\n    }\n    getNormalMatrix(matrix4) {\n      return this.setFromMatrix4(matrix4).invert().transpose();\n    }\n    transposeIntoArray(r) {\n      const m = this.elements;\n      r[0] = m[0];\n      r[1] = m[3];\n      r[2] = m[6];\n      r[3] = m[1];\n      r[4] = m[4];\n      r[5] = m[7];\n      r[6] = m[2];\n      r[7] = m[5];\n      r[8] = m[8];\n      return this;\n    }\n    setUvTransform(tx, ty, sx, sy, rotation, cx, cy) {\n      const c = Math.cos(rotation);\n      const s = Math.sin(rotation);\n      this.set(\n        sx * c,\n        sx * s,\n        -sx * (c * cx + s * cy) + cx + tx,\n        -sy * s,\n        sy * c,\n        -sy * (-s * cx + c * cy) + cy + ty,\n        0,\n        0,\n        1\n      );\n      return this;\n    }\n    //\n    scale(sx, sy) {\n      this.premultiply(_m3.makeScale(sx, sy));\n      return this;\n    }\n    rotate(theta) {\n      this.premultiply(_m3.makeRotation(-theta));\n      return this;\n    }\n    translate(tx, ty) {\n      this.premultiply(_m3.makeTranslation(tx, ty));\n      return this;\n    }\n    // for 2D Transforms\n    makeTranslation(x2, y) {\n      if (x2.isVector2) {\n        this.set(\n          1,\n          0,\n          x2.x,\n          0,\n          1,\n          x2.y,\n          0,\n          0,\n          1\n        );\n      } else {\n        this.set(\n          1,\n          0,\n          x2,\n          0,\n          1,\n          y,\n          0,\n          0,\n          1\n        );\n      }\n      return this;\n    }\n    makeRotation(theta) {\n      const c = Math.cos(theta);\n      const s = Math.sin(theta);\n      this.set(\n        c,\n        -s,\n        0,\n        s,\n        c,\n        0,\n        0,\n        0,\n        1\n      );\n      return this;\n    }\n    makeScale(x2, y) {\n      this.set(\n        x2,\n        0,\n        0,\n        0,\n        y,\n        0,\n        0,\n        0,\n        1\n      );\n      return this;\n    }\n    //\n    equals(matrix) {\n      const te = this.elements;\n      const me = matrix.elements;\n      for (let i2 = 0; i2 < 9; i2++) {\n        if (te[i2] !== me[i2]) return false;\n      }\n      return true;\n    }\n    fromArray(array, offset = 0) {\n      for (let i2 = 0; i2 < 9; i2++) {\n        this.elements[i2] = array[i2 + offset];\n      }\n      return this;\n    }\n    toArray(array = [], offset = 0) {\n      const te = this.elements;\n      array[offset] = te[0];\n      array[offset + 1] = te[1];\n      array[offset + 2] = te[2];\n      array[offset + 3] = te[3];\n      array[offset + 4] = te[4];\n      array[offset + 5] = te[5];\n      array[offset + 6] = te[6];\n      array[offset + 7] = te[7];\n      array[offset + 8] = te[8];\n      return array;\n    }\n    clone() {\n      return new this.constructor().fromArray(this.elements);\n    }\n  }\n  const _m3 = /* @__PURE__ */ new Matrix3();\n  function arrayNeedsUint32(array) {\n    for (let i2 = array.length - 1; i2 >= 0; --i2) {\n      if (array[i2] >= 65535) return true;\n    }\n    return false;\n  }\n  function createElementNS(name) {\n    return document.createElementNS("http://www.w3.org/1999/xhtml", name);\n  }\n  const LINEAR_REC709_TO_XYZ = /* @__PURE__ */ new Matrix3().set(\n    0.4123908,\n    0.3575843,\n    0.1804808,\n    0.212639,\n    0.7151687,\n    0.0721923,\n    0.0193308,\n    0.1191948,\n    0.9505322\n  );\n  const XYZ_TO_LINEAR_REC709 = /* @__PURE__ */ new Matrix3().set(\n    3.2409699,\n    -1.5373832,\n    -0.4986108,\n    -0.9692436,\n    1.8759675,\n    0.0415551,\n    0.0556301,\n    -0.203977,\n    1.0569715\n  );\n  function createColorManagement() {\n    const ColorManagement2 = {\n      enabled: true,\n      workingColorSpace: LinearSRGBColorSpace,\n      /**\n       * Implementations of supported color spaces.\n       *\n       * Required:\n       *\t- primaries: chromaticity coordinates [ rx ry gx gy bx by ]\n       *\t- whitePoint: reference white [ x y ]\n       *\t- transfer: transfer function (pre-defined)\n       *\t- toXYZ: Matrix3 RGB to XYZ transform\n       *\t- fromXYZ: Matrix3 XYZ to RGB transform\n       *\t- luminanceCoefficients: RGB luminance coefficients\n       *\n       * Optional:\n       *  - outputColorSpaceConfig: { drawingBufferColorSpace: ColorSpace }\n       *  - workingColorSpaceConfig: { unpackColorSpace: ColorSpace }\n       *\n       * Reference:\n       * - https://www.russellcottrell.com/photo/matrixCalculator.htm\n       */\n      spaces: {},\n      convert: function(color, sourceColorSpace, targetColorSpace) {\n        if (this.enabled === false || sourceColorSpace === targetColorSpace || !sourceColorSpace || !targetColorSpace) {\n          return color;\n        }\n        if (this.spaces[sourceColorSpace].transfer === SRGBTransfer) {\n          color.r = SRGBToLinear(color.r);\n          color.g = SRGBToLinear(color.g);\n          color.b = SRGBToLinear(color.b);\n        }\n        if (this.spaces[sourceColorSpace].primaries !== this.spaces[targetColorSpace].primaries) {\n          color.applyMatrix3(this.spaces[sourceColorSpace].toXYZ);\n          color.applyMatrix3(this.spaces[targetColorSpace].fromXYZ);\n        }\n        if (this.spaces[targetColorSpace].transfer === SRGBTransfer) {\n          color.r = LinearToSRGB(color.r);\n          color.g = LinearToSRGB(color.g);\n          color.b = LinearToSRGB(color.b);\n        }\n        return color;\n      },\n      fromWorkingColorSpace: function(color, targetColorSpace) {\n        return this.convert(color, this.workingColorSpace, targetColorSpace);\n      },\n      toWorkingColorSpace: function(color, sourceColorSpace) {\n        return this.convert(color, sourceColorSpace, this.workingColorSpace);\n      },\n      getPrimaries: function(colorSpace) {\n        return this.spaces[colorSpace].primaries;\n      },\n      getTransfer: function(colorSpace) {\n        if (colorSpace === NoColorSpace) return LinearTransfer;\n        return this.spaces[colorSpace].transfer;\n      },\n      getLuminanceCoefficients: function(target, colorSpace = this.workingColorSpace) {\n        return target.fromArray(this.spaces[colorSpace].luminanceCoefficients);\n      },\n      define: function(colorSpaces) {\n        Object.assign(this.spaces, colorSpaces);\n      },\n      // Internal APIs\n      _getMatrix: function(targetMatrix, sourceColorSpace, targetColorSpace) {\n        return targetMatrix.copy(this.spaces[sourceColorSpace].toXYZ).multiply(this.spaces[targetColorSpace].fromXYZ);\n      },\n      _getDrawingBufferColorSpace: function(colorSpace) {\n        return this.spaces[colorSpace].outputColorSpaceConfig.drawingBufferColorSpace;\n      },\n      _getUnpackColorSpace: function(colorSpace = this.workingColorSpace) {\n        return this.spaces[colorSpace].workingColorSpaceConfig.unpackColorSpace;\n      }\n    };\n    const REC709_PRIMARIES = [0.64, 0.33, 0.3, 0.6, 0.15, 0.06];\n    const REC709_LUMINANCE_COEFFICIENTS = [0.2126, 0.7152, 0.0722];\n    const D65 = [0.3127, 0.329];\n    ColorManagement2.define({\n      [LinearSRGBColorSpace]: {\n        primaries: REC709_PRIMARIES,\n        whitePoint: D65,\n        transfer: LinearTransfer,\n        toXYZ: LINEAR_REC709_TO_XYZ,\n        fromXYZ: XYZ_TO_LINEAR_REC709,\n        luminanceCoefficients: REC709_LUMINANCE_COEFFICIENTS,\n        workingColorSpaceConfig: { unpackColorSpace: SRGBColorSpace },\n        outputColorSpaceConfig: { drawingBufferColorSpace: SRGBColorSpace }\n      },\n      [SRGBColorSpace]: {\n        primaries: REC709_PRIMARIES,\n        whitePoint: D65,\n        transfer: SRGBTransfer,\n        toXYZ: LINEAR_REC709_TO_XYZ,\n        fromXYZ: XYZ_TO_LINEAR_REC709,\n        luminanceCoefficients: REC709_LUMINANCE_COEFFICIENTS,\n        outputColorSpaceConfig: { drawingBufferColorSpace: SRGBColorSpace }\n      }\n    });\n    return ColorManagement2;\n  }\n  const ColorManagement = /* @__PURE__ */ createColorManagement();\n  function SRGBToLinear(c) {\n    return c < 0.04045 ? c * 0.0773993808 : Math.pow(c * 0.9478672986 + 0.0521327014, 2.4);\n  }\n  function LinearToSRGB(c) {\n    return c < 31308e-7 ? c * 12.92 : 1.055 * Math.pow(c, 0.41666) - 0.055;\n  }\n  let _canvas;\n  class ImageUtils {\n    static getDataURL(image) {\n      if (/^data:/i.test(image.src)) {\n        return image.src;\n      }\n      if (typeof HTMLCanvasElement === "undefined") {\n        return image.src;\n      }\n      let canvas;\n      if (image instanceof HTMLCanvasElement) {\n        canvas = image;\n      } else {\n        if (_canvas === void 0) _canvas = createElementNS("canvas");\n        _canvas.width = image.width;\n        _canvas.height = image.height;\n        const context = _canvas.getContext("2d");\n        if (image instanceof ImageData) {\n          context.putImageData(image, 0, 0);\n        } else {\n          context.drawImage(image, 0, 0, image.width, image.height);\n        }\n        canvas = _canvas;\n      }\n      if (canvas.width > 2048 || canvas.height > 2048) {\n        console.warn("THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons", image);\n        return canvas.toDataURL("image/jpeg", 0.6);\n      } else {\n        return canvas.toDataURL("image/png");\n      }\n    }\n    static sRGBToLinear(image) {\n      if (typeof HTMLImageElement !== "undefined" && image instanceof HTMLImageElement || typeof HTMLCanvasElement !== "undefined" && image instanceof HTMLCanvasElement || typeof ImageBitmap !== "undefined" && image instanceof ImageBitmap) {\n        const canvas = createElementNS("canvas");\n        canvas.width = image.width;\n        canvas.height = image.height;\n        const context = canvas.getContext("2d");\n        context.drawImage(image, 0, 0, image.width, image.height);\n        const imageData = context.getImageData(0, 0, image.width, image.height);\n        const data = imageData.data;\n        for (let i2 = 0; i2 < data.length; i2++) {\n          data[i2] = SRGBToLinear(data[i2] / 255) * 255;\n        }\n        context.putImageData(imageData, 0, 0);\n        return canvas;\n      } else if (image.data) {\n        const data = image.data.slice(0);\n        for (let i2 = 0; i2 < data.length; i2++) {\n          if (data instanceof Uint8Array || data instanceof Uint8ClampedArray) {\n            data[i2] = Math.floor(SRGBToLinear(data[i2] / 255) * 255);\n          } else {\n            data[i2] = SRGBToLinear(data[i2]);\n          }\n        }\n        return {\n          data,\n          width: image.width,\n          height: image.height\n        };\n      } else {\n        console.warn("THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied.");\n        return image;\n      }\n    }\n  }\n  let _sourceId = 0;\n  class Source {\n    constructor(data = null) {\n      this.isSource = true;\n      Object.defineProperty(this, "id", { value: _sourceId++ });\n      this.uuid = generateUUID();\n      this.data = data;\n      this.dataReady = true;\n      this.version = 0;\n    }\n    set needsUpdate(value) {\n      if (value === true) this.version++;\n    }\n    toJSON(meta) {\n      const isRootObject = meta === void 0 || typeof meta === "string";\n      if (!isRootObject && meta.images[this.uuid] !== void 0) {\n        return meta.images[this.uuid];\n      }\n      const output = {\n        uuid: this.uuid,\n        url: ""\n      };\n      const data = this.data;\n      if (data !== null) {\n        let url;\n        if (Array.isArray(data)) {\n          url = [];\n          for (let i2 = 0, l = data.length; i2 < l; i2++) {\n            if (data[i2].isDataTexture) {\n              url.push(serializeImage(data[i2].image));\n            } else {\n              url.push(serializeImage(data[i2]));\n            }\n          }\n        } else {\n          url = serializeImage(data);\n        }\n        output.url = url;\n      }\n      if (!isRootObject) {\n        meta.images[this.uuid] = output;\n      }\n      return output;\n    }\n  }\n  function serializeImage(image) {\n    if (typeof HTMLImageElement !== "undefined" && image instanceof HTMLImageElement || typeof HTMLCanvasElement !== "undefined" && image instanceof HTMLCanvasElement || typeof ImageBitmap !== "undefined" && image instanceof ImageBitmap) {\n      return ImageUtils.getDataURL(image);\n    } else {\n      if (image.data) {\n        return {\n          data: Array.from(image.data),\n          width: image.width,\n          height: image.height,\n          type: image.data.constructor.name\n        };\n      } else {\n        console.warn("THREE.Texture: Unable to serialize Texture.");\n        return {};\n      }\n    }\n  }\n  let _textureId = 0;\n  class Texture extends EventDispatcher {\n    constructor(image = Texture.DEFAULT_IMAGE, mapping = Texture.DEFAULT_MAPPING, wrapS = ClampToEdgeWrapping, wrapT = ClampToEdgeWrapping, magFilter = LinearFilter, minFilter = LinearMipmapLinearFilter, format = RGBAFormat, type = UnsignedByteType, anisotropy = Texture.DEFAULT_ANISOTROPY, colorSpace = NoColorSpace) {\n      super();\n      this.isTexture = true;\n      Object.defineProperty(this, "id", { value: _textureId++ });\n      this.uuid = generateUUID();\n      this.name = "";\n      this.source = new Source(image);\n      this.mipmaps = [];\n      this.mapping = mapping;\n      this.channel = 0;\n      this.wrapS = wrapS;\n      this.wrapT = wrapT;\n      this.magFilter = magFilter;\n      this.minFilter = minFilter;\n      this.anisotropy = anisotropy;\n      this.format = format;\n      this.internalFormat = null;\n      this.type = type;\n      this.offset = new Vector2(0, 0);\n      this.repeat = new Vector2(1, 1);\n      this.center = new Vector2(0, 0);\n      this.rotation = 0;\n      this.matrixAutoUpdate = true;\n      this.matrix = new Matrix3();\n      this.generateMipmaps = true;\n      this.premultiplyAlpha = false;\n      this.flipY = true;\n      this.unpackAlignment = 4;\n      this.colorSpace = colorSpace;\n      this.userData = {};\n      this.version = 0;\n      this.onUpdate = null;\n      this.renderTarget = null;\n      this.isRenderTargetTexture = false;\n      this.pmremVersion = 0;\n    }\n    get image() {\n      return this.source.data;\n    }\n    set image(value = null) {\n      this.source.data = value;\n    }\n    updateMatrix() {\n      this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y);\n    }\n    clone() {\n      return new this.constructor().copy(this);\n    }\n    copy(source) {\n      this.name = source.name;\n      this.source = source.source;\n      this.mipmaps = source.mipmaps.slice(0);\n      this.mapping = source.mapping;\n      this.channel = source.channel;\n      this.wrapS = source.wrapS;\n      this.wrapT = source.wrapT;\n      this.magFilter = source.magFilter;\n      this.minFilter = source.minFilter;\n      this.anisotropy = source.anisotropy;\n      this.format = source.format;\n      this.internalFormat = source.internalFormat;\n      this.type = source.type;\n      this.offset.copy(source.offset);\n      this.repeat.copy(source.repeat);\n      this.center.copy(source.center);\n      this.rotation = source.rotation;\n      this.matrixAutoUpdate = source.matrixAutoUpdate;\n      this.matrix.copy(source.matrix);\n      this.generateMipmaps = source.generateMipmaps;\n      this.premultiplyAlpha = source.premultiplyAlpha;\n      this.flipY = source.flipY;\n      this.unpackAlignment = source.unpackAlignment;\n      this.colorSpace = source.colorSpace;\n      this.renderTarget = source.renderTarget;\n      this.isRenderTargetTexture = source.isRenderTargetTexture;\n      this.userData = JSON.parse(JSON.stringify(source.userData));\n      this.needsUpdate = true;\n      return this;\n    }\n    toJSON(meta) {\n      const isRootObject = meta === void 0 || typeof meta === "string";\n      if (!isRootObject && meta.textures[this.uuid] !== void 0) {\n        return meta.textures[this.uuid];\n      }\n      const output = {\n        metadata: {\n          version: 4.6,\n          type: "Texture",\n          generator: "Texture.toJSON"\n        },\n        uuid: this.uuid,\n        name: this.name,\n        image: this.source.toJSON(meta).uuid,\n        mapping: this.mapping,\n        channel: this.channel,\n        repeat: [this.repeat.x, this.repeat.y],\n        offset: [this.offset.x, this.offset.y],\n        center: [this.center.x, this.center.y],\n        rotation: this.rotation,\n        wrap: [this.wrapS, this.wrapT],\n        format: this.format,\n        internalFormat: this.internalFormat,\n        type: this.type,\n        colorSpace: this.colorSpace,\n        minFilter: this.minFilter,\n        magFilter: this.magFilter,\n        anisotropy: this.anisotropy,\n        flipY: this.flipY,\n        generateMipmaps: this.generateMipmaps,\n        premultiplyAlpha: this.premultiplyAlpha,\n        unpackAlignment: this.unpackAlignment\n      };\n      if (Object.keys(this.userData).length > 0) output.userData = this.userData;\n      if (!isRootObject) {\n        meta.textures[this.uuid] = output;\n      }\n      return output;\n    }\n    dispose() {\n      this.dispatchEvent({ type: "dispose" });\n    }\n    transformUv(uv) {\n      if (this.mapping !== UVMapping) return uv;\n      uv.applyMatrix3(this.matrix);\n      if (uv.x < 0 || uv.x > 1) {\n        switch (this.wrapS) {\n          case RepeatWrapping:\n            uv.x = uv.x - Math.floor(uv.x);\n            break;\n          case ClampToEdgeWrapping:\n            uv.x = uv.x < 0 ? 0 : 1;\n            break;\n          case MirroredRepeatWrapping:\n            if (Math.abs(Math.floor(uv.x) % 2) === 1) {\n              uv.x = Math.ceil(uv.x) - uv.x;\n            } else {\n              uv.x = uv.x - Math.floor(uv.x);\n            }\n            break;\n        }\n      }\n      if (uv.y < 0 || uv.y > 1) {\n        switch (this.wrapT) {\n          case RepeatWrapping:\n            uv.y = uv.y - Math.floor(uv.y);\n            break;\n          case ClampToEdgeWrapping:\n            uv.y = uv.y < 0 ? 0 : 1;\n            break;\n          case MirroredRepeatWrapping:\n            if (Math.abs(Math.floor(uv.y) % 2) === 1) {\n              uv.y = Math.ceil(uv.y) - uv.y;\n            } else {\n              uv.y = uv.y - Math.floor(uv.y);\n            }\n            break;\n        }\n      }\n      if (this.flipY) {\n        uv.y = 1 - uv.y;\n      }\n      return uv;\n    }\n    set needsUpdate(value) {\n      if (value === true) {\n        this.version++;\n        this.source.needsUpdate = true;\n      }\n    }\n    set needsPMREMUpdate(value) {\n      if (value === true) {\n        this.pmremVersion++;\n      }\n    }\n  }\n  Texture.DEFAULT_IMAGE = null;\n  Texture.DEFAULT_MAPPING = UVMapping;\n  Texture.DEFAULT_ANISOTROPY = 1;\n  class Vector4 {\n    constructor(x2 = 0, y = 0, z = 0, w = 1) {\n      Vector4.prototype.isVector4 = true;\n      this.x = x2;\n      this.y = y;\n      this.z = z;\n      this.w = w;\n    }\n    get width() {\n      return this.z;\n    }\n    set width(value) {\n      this.z = value;\n    }\n    get height() {\n      return this.w;\n    }\n    set height(value) {\n      this.w = value;\n    }\n    set(x2, y, z, w) {\n      this.x = x2;\n      this.y = y;\n      this.z = z;\n      this.w = w;\n      return this;\n    }\n    setScalar(scalar) {\n      this.x = scalar;\n      this.y = scalar;\n      this.z = scalar;\n      this.w = scalar;\n      return this;\n    }\n    setX(x2) {\n      this.x = x2;\n      return this;\n    }\n    setY(y) {\n      this.y = y;\n      return this;\n    }\n    setZ(z) {\n      this.z = z;\n      return this;\n    }\n    setW(w) {\n      this.w = w;\n      return this;\n    }\n    setComponent(index, value) {\n      switch (index) {\n        case 0:\n          this.x = value;\n          break;\n        case 1:\n          this.y = value;\n          break;\n        case 2:\n          this.z = value;\n          break;\n        case 3:\n          this.w = value;\n          break;\n        default:\n          throw new Error("index is out of range: " + index);\n      }\n      return this;\n    }\n    getComponent(index) {\n      switch (index) {\n        case 0:\n          return this.x;\n        case 1:\n          return this.y;\n        case 2:\n          return this.z;\n        case 3:\n          return this.w;\n        default:\n          throw new Error("index is out of range: " + index);\n      }\n    }\n    clone() {\n      return new this.constructor(this.x, this.y, this.z, this.w);\n    }\n    copy(v) {\n      this.x = v.x;\n      this.y = v.y;\n      this.z = v.z;\n      this.w = v.w !== void 0 ? v.w : 1;\n      return this;\n    }\n    add(v) {\n      this.x += v.x;\n      this.y += v.y;\n      this.z += v.z;\n      this.w += v.w;\n      return this;\n    }\n    addScalar(s) {\n      this.x += s;\n      this.y += s;\n      this.z += s;\n      this.w += s;\n      return this;\n    }\n    addVectors(a, b) {\n      this.x = a.x + b.x;\n      this.y = a.y + b.y;\n      this.z = a.z + b.z;\n      this.w = a.w + b.w;\n      return this;\n    }\n    addScaledVector(v, s) {\n      this.x += v.x * s;\n      this.y += v.y * s;\n      this.z += v.z * s;\n      this.w += v.w * s;\n      return this;\n    }\n    sub(v) {\n      this.x -= v.x;\n      this.y -= v.y;\n      this.z -= v.z;\n      this.w -= v.w;\n      return this;\n    }\n    subScalar(s) {\n      this.x -= s;\n      this.y -= s;\n      this.z -= s;\n      this.w -= s;\n      return this;\n    }\n    subVectors(a, b) {\n      this.x = a.x - b.x;\n      this.y = a.y - b.y;\n      this.z = a.z - b.z;\n      this.w = a.w - b.w;\n      return this;\n    }\n    multiply(v) {\n      this.x *= v.x;\n      this.y *= v.y;\n      this.z *= v.z;\n      this.w *= v.w;\n      return this;\n    }\n    multiplyScalar(scalar) {\n      this.x *= scalar;\n      this.y *= scalar;\n      this.z *= scalar;\n      this.w *= scalar;\n      return this;\n    }\n    applyMatrix4(m) {\n      const x2 = this.x, y = this.y, z = this.z, w = this.w;\n      const e = m.elements;\n      this.x = e[0] * x2 + e[4] * y + e[8] * z + e[12] * w;\n      this.y = e[1] * x2 + e[5] * y + e[9] * z + e[13] * w;\n      this.z = e[2] * x2 + e[6] * y + e[10] * z + e[14] * w;\n      this.w = e[3] * x2 + e[7] * y + e[11] * z + e[15] * w;\n      return this;\n    }\n    divide(v) {\n      this.x /= v.x;\n      this.y /= v.y;\n      this.z /= v.z;\n      this.w /= v.w;\n      return this;\n    }\n    divideScalar(scalar) {\n      return this.multiplyScalar(1 / scalar);\n    }\n    setAxisAngleFromQuaternion(q) {\n      this.w = 2 * Math.acos(q.w);\n      const s = Math.sqrt(1 - q.w * q.w);\n      if (s < 1e-4) {\n        this.x = 1;\n        this.y = 0;\n        this.z = 0;\n      } else {\n        this.x = q.x / s;\n        this.y = q.y / s;\n        this.z = q.z / s;\n      }\n      return this;\n    }\n    setAxisAngleFromRotationMatrix(m) {\n      let angle, x2, y, z;\n      const epsilon = 0.01, epsilon2 = 0.1, te = m.elements, m11 = te[0], m12 = te[4], m13 = te[8], m21 = te[1], m22 = te[5], m23 = te[9], m31 = te[2], m32 = te[6], m33 = te[10];\n      if (Math.abs(m12 - m21) < epsilon && Math.abs(m13 - m31) < epsilon && Math.abs(m23 - m32) < epsilon) {\n        if (Math.abs(m12 + m21) < epsilon2 && Math.abs(m13 + m31) < epsilon2 && Math.abs(m23 + m32) < epsilon2 && Math.abs(m11 + m22 + m33 - 3) < epsilon2) {\n          this.set(1, 0, 0, 0);\n          return this;\n        }\n        angle = Math.PI;\n        const xx = (m11 + 1) / 2;\n        const yy = (m22 + 1) / 2;\n        const zz = (m33 + 1) / 2;\n        const xy = (m12 + m21) / 4;\n        const xz = (m13 + m31) / 4;\n        const yz = (m23 + m32) / 4;\n        if (xx > yy && xx > zz) {\n          if (xx < epsilon) {\n            x2 = 0;\n            y = 0.707106781;\n            z = 0.707106781;\n          } else {\n            x2 = Math.sqrt(xx);\n            y = xy / x2;\n            z = xz / x2;\n          }\n        } else if (yy > zz) {\n          if (yy < epsilon) {\n            x2 = 0.707106781;\n            y = 0;\n            z = 0.707106781;\n          } else {\n            y = Math.sqrt(yy);\n            x2 = xy / y;\n            z = yz / y;\n          }\n        } else {\n          if (zz < epsilon) {\n            x2 = 0.707106781;\n            y = 0.707106781;\n            z = 0;\n          } else {\n            z = Math.sqrt(zz);\n            x2 = xz / z;\n            y = yz / z;\n          }\n        }\n        this.set(x2, y, z, angle);\n        return this;\n      }\n      let s = Math.sqrt((m32 - m23) * (m32 - m23) + (m13 - m31) * (m13 - m31) + (m21 - m12) * (m21 - m12));\n      if (Math.abs(s) < 1e-3) s = 1;\n      this.x = (m32 - m23) / s;\n      this.y = (m13 - m31) / s;\n      this.z = (m21 - m12) / s;\n      this.w = Math.acos((m11 + m22 + m33 - 1) / 2);\n      return this;\n    }\n    setFromMatrixPosition(m) {\n      const e = m.elements;\n      this.x = e[12];\n      this.y = e[13];\n      this.z = e[14];\n      this.w = e[15];\n      return this;\n    }\n    min(v) {\n      this.x = Math.min(this.x, v.x);\n      this.y = Math.min(this.y, v.y);\n      this.z = Math.min(this.z, v.z);\n      this.w = Math.min(this.w, v.w);\n      return this;\n    }\n    max(v) {\n      this.x = Math.max(this.x, v.x);\n      this.y = Math.max(this.y, v.y);\n      this.z = Math.max(this.z, v.z);\n      this.w = Math.max(this.w, v.w);\n      return this;\n    }\n    clamp(min, max2) {\n      this.x = clamp(this.x, min.x, max2.x);\n      this.y = clamp(this.y, min.y, max2.y);\n      this.z = clamp(this.z, min.z, max2.z);\n      this.w = clamp(this.w, min.w, max2.w);\n      return this;\n    }\n    clampScalar(minVal, maxVal) {\n      this.x = clamp(this.x, minVal, maxVal);\n      this.y = clamp(this.y, minVal, maxVal);\n      this.z = clamp(this.z, minVal, maxVal);\n      this.w = clamp(this.w, minVal, maxVal);\n      return this;\n    }\n    clampLength(min, max2) {\n      const length = this.length();\n      return this.divideScalar(length || 1).multiplyScalar(clamp(length, min, max2));\n    }\n    floor() {\n      this.x = Math.floor(this.x);\n      this.y = Math.floor(this.y);\n      this.z = Math.floor(this.z);\n      this.w = Math.floor(this.w);\n      return this;\n    }\n    ceil() {\n      this.x = Math.ceil(this.x);\n      this.y = Math.ceil(this.y);\n      this.z = Math.ceil(this.z);\n      this.w = Math.ceil(this.w);\n      return this;\n    }\n    round() {\n      this.x = Math.round(this.x);\n      this.y = Math.round(this.y);\n      this.z = Math.round(this.z);\n      this.w = Math.round(this.w);\n      return this;\n    }\n    roundToZero() {\n      this.x = Math.trunc(this.x);\n      this.y = Math.trunc(this.y);\n      this.z = Math.trunc(this.z);\n      this.w = Math.trunc(this.w);\n      return this;\n    }\n    negate() {\n      this.x = -this.x;\n      this.y = -this.y;\n      this.z = -this.z;\n      this.w = -this.w;\n      return this;\n    }\n    dot(v) {\n      return this.x * v.x + this.y * v.y + this.z * v.z + this.w * v.w;\n    }\n    lengthSq() {\n      return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;\n    }\n    length() {\n      return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);\n    }\n    manhattanLength() {\n      return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w);\n    }\n    normalize() {\n      return this.divideScalar(this.length() || 1);\n    }\n    setLength(length) {\n      return this.normalize().multiplyScalar(length);\n    }\n    lerp(v, alpha) {\n      this.x += (v.x - this.x) * alpha;\n      this.y += (v.y - this.y) * alpha;\n      this.z += (v.z - this.z) * alpha;\n      this.w += (v.w - this.w) * alpha;\n      return this;\n    }\n    lerpVectors(v1, v2, alpha) {\n      this.x = v1.x + (v2.x - v1.x) * alpha;\n      this.y = v1.y + (v2.y - v1.y) * alpha;\n      this.z = v1.z + (v2.z - v1.z) * alpha;\n      this.w = v1.w + (v2.w - v1.w) * alpha;\n      return this;\n    }\n    equals(v) {\n      return v.x === this.x && v.y === this.y && v.z === this.z && v.w === this.w;\n    }\n    fromArray(array, offset = 0) {\n      this.x = array[offset];\n      this.y = array[offset + 1];\n      this.z = array[offset + 2];\n      this.w = array[offset + 3];\n      return this;\n    }\n    toArray(array = [], offset = 0) {\n      array[offset] = this.x;\n      array[offset + 1] = this.y;\n      array[offset + 2] = this.z;\n      array[offset + 3] = this.w;\n      return array;\n    }\n    fromBufferAttribute(attribute, index) {\n      this.x = attribute.getX(index);\n      this.y = attribute.getY(index);\n      this.z = attribute.getZ(index);\n      this.w = attribute.getW(index);\n      return this;\n    }\n    random() {\n      this.x = Math.random();\n      this.y = Math.random();\n      this.z = Math.random();\n      this.w = Math.random();\n      return this;\n    }\n    *[Symbol.iterator]() {\n      yield this.x;\n      yield this.y;\n      yield this.z;\n      yield this.w;\n    }\n  }\n  class RenderTarget extends EventDispatcher {\n    constructor(width = 1, height = 1, options = {}) {\n      super();\n      this.isRenderTarget = true;\n      this.width = width;\n      this.height = height;\n      this.depth = 1;\n      this.scissor = new Vector4(0, 0, width, height);\n      this.scissorTest = false;\n      this.viewport = new Vector4(0, 0, width, height);\n      const image = { width, height, depth: 1 };\n      options = Object.assign({\n        generateMipmaps: false,\n        internalFormat: null,\n        minFilter: LinearFilter,\n        depthBuffer: true,\n        stencilBuffer: false,\n        resolveDepthBuffer: true,\n        resolveStencilBuffer: true,\n        depthTexture: null,\n        samples: 0,\n        count: 1\n      }, options);\n      const texture = new Texture(image, options.mapping, options.wrapS, options.wrapT, options.magFilter, options.minFilter, options.format, options.type, options.anisotropy, options.colorSpace);\n      texture.flipY = false;\n      texture.generateMipmaps = options.generateMipmaps;\n      texture.internalFormat = options.internalFormat;\n      this.textures = [];\n      const count = options.count;\n      for (let i2 = 0; i2 < count; i2++) {\n        this.textures[i2] = texture.clone();\n        this.textures[i2].isRenderTargetTexture = true;\n        this.textures[i2].renderTarget = this;\n      }\n      this.depthBuffer = options.depthBuffer;\n      this.stencilBuffer = options.stencilBuffer;\n      this.resolveDepthBuffer = options.resolveDepthBuffer;\n      this.resolveStencilBuffer = options.resolveStencilBuffer;\n      this._depthTexture = null;\n      this.depthTexture = options.depthTexture;\n      this.samples = options.samples;\n    }\n    get texture() {\n      return this.textures[0];\n    }\n    set texture(value) {\n      this.textures[0] = value;\n    }\n    set depthTexture(current) {\n      if (this._depthTexture !== null) this._depthTexture.renderTarget = null;\n      if (current !== null) current.renderTarget = this;\n      this._depthTexture = current;\n    }\n    get depthTexture() {\n      return this._depthTexture;\n    }\n    setSize(width, height, depth = 1) {\n      if (this.width !== width || this.height !== height || this.depth !== depth) {\n        this.width = width;\n        this.height = height;\n        this.depth = depth;\n        for (let i2 = 0, il = this.textures.length; i2 < il; i2++) {\n          this.textures[i2].image.width = width;\n          this.textures[i2].image.height = height;\n          this.textures[i2].image.depth = depth;\n        }\n        this.dispose();\n      }\n      this.viewport.set(0, 0, width, height);\n      this.scissor.set(0, 0, width, height);\n    }\n    clone() {\n      return new this.constructor().copy(this);\n    }\n    copy(source) {\n      this.width = source.width;\n      this.height = source.height;\n      this.depth = source.depth;\n      this.scissor.copy(source.scissor);\n      this.scissorTest = source.scissorTest;\n      this.viewport.copy(source.viewport);\n      this.textures.length = 0;\n      for (let i2 = 0, il = source.textures.length; i2 < il; i2++) {\n        this.textures[i2] = source.textures[i2].clone();\n        this.textures[i2].isRenderTargetTexture = true;\n        this.textures[i2].renderTarget = this;\n      }\n      const image = Object.assign({}, source.texture.image);\n      this.texture.source = new Source(image);\n      this.depthBuffer = source.depthBuffer;\n      this.stencilBuffer = source.stencilBuffer;\n      this.resolveDepthBuffer = source.resolveDepthBuffer;\n      this.resolveStencilBuffer = source.resolveStencilBuffer;\n      if (source.depthTexture !== null) this.depthTexture = source.depthTexture.clone();\n      this.samples = source.samples;\n      return this;\n    }\n    dispose() {\n      this.dispatchEvent({ type: "dispose" });\n    }\n  }\n  class WebGLRenderTarget extends RenderTarget {\n    constructor(width = 1, height = 1, options = {}) {\n      super(width, height, options);\n      this.isWebGLRenderTarget = true;\n    }\n  }\n  class DataArrayTexture extends Texture {\n    constructor(data = null, width = 1, height = 1, depth = 1) {\n      super(null);\n      this.isDataArrayTexture = true;\n      this.image = { data, width, height, depth };\n      this.magFilter = NearestFilter;\n      this.minFilter = NearestFilter;\n      this.wrapR = ClampToEdgeWrapping;\n      this.generateMipmaps = false;\n      this.flipY = false;\n      this.unpackAlignment = 1;\n      this.layerUpdates = /* @__PURE__ */ new Set();\n    }\n    addLayerUpdate(layerIndex) {\n      this.layerUpdates.add(layerIndex);\n    }\n    clearLayerUpdates() {\n      this.layerUpdates.clear();\n    }\n  }\n  class WebGLArrayRenderTarget extends WebGLRenderTarget {\n    constructor(width = 1, height = 1, depth = 1, options = {}) {\n      super(width, height, options);\n      this.isWebGLArrayRenderTarget = true;\n      this.depth = depth;\n      this.texture = new DataArrayTexture(null, width, height, depth);\n      this.texture.isRenderTargetTexture = true;\n    }\n  }\n  class Quaternion {\n    constructor(x2 = 0, y = 0, z = 0, w = 1) {\n      this.isQuaternion = true;\n      this._x = x2;\n      this._y = y;\n      this._z = z;\n      this._w = w;\n    }\n    static slerpFlat(dst, dstOffset, src0, srcOffset0, src1, srcOffset1, t) {\n      let x0 = src0[srcOffset0 + 0], y0 = src0[srcOffset0 + 1], z0 = src0[srcOffset0 + 2], w0 = src0[srcOffset0 + 3];\n      const x1 = src1[srcOffset1 + 0], y1 = src1[srcOffset1 + 1], z1 = src1[srcOffset1 + 2], w1 = src1[srcOffset1 + 3];\n      if (t === 0) {\n        dst[dstOffset + 0] = x0;\n        dst[dstOffset + 1] = y0;\n        dst[dstOffset + 2] = z0;\n        dst[dstOffset + 3] = w0;\n        return;\n      }\n      if (t === 1) {\n        dst[dstOffset + 0] = x1;\n        dst[dstOffset + 1] = y1;\n        dst[dstOffset + 2] = z1;\n        dst[dstOffset + 3] = w1;\n        return;\n      }\n      if (w0 !== w1 || x0 !== x1 || y0 !== y1 || z0 !== z1) {\n        let s = 1 - t;\n        const cos = x0 * x1 + y0 * y1 + z0 * z1 + w0 * w1, dir = cos >= 0 ? 1 : -1, sqrSin = 1 - cos * cos;\n        if (sqrSin > Number.EPSILON) {\n          const sin = Math.sqrt(sqrSin), len = Math.atan2(sin, cos * dir);\n          s = Math.sin(s * len) / sin;\n          t = Math.sin(t * len) / sin;\n        }\n        const tDir = t * dir;\n        x0 = x0 * s + x1 * tDir;\n        y0 = y0 * s + y1 * tDir;\n        z0 = z0 * s + z1 * tDir;\n        w0 = w0 * s + w1 * tDir;\n        if (s === 1 - t) {\n          const f = 1 / Math.sqrt(x0 * x0 + y0 * y0 + z0 * z0 + w0 * w0);\n          x0 *= f;\n          y0 *= f;\n          z0 *= f;\n          w0 *= f;\n        }\n      }\n      dst[dstOffset] = x0;\n      dst[dstOffset + 1] = y0;\n      dst[dstOffset + 2] = z0;\n      dst[dstOffset + 3] = w0;\n    }\n    static multiplyQuaternionsFlat(dst, dstOffset, src0, srcOffset0, src1, srcOffset1) {\n      const x0 = src0[srcOffset0];\n      const y0 = src0[srcOffset0 + 1];\n      const z0 = src0[srcOffset0 + 2];\n      const w0 = src0[srcOffset0 + 3];\n      const x1 = src1[srcOffset1];\n      const y1 = src1[srcOffset1 + 1];\n      const z1 = src1[srcOffset1 + 2];\n      const w1 = src1[srcOffset1 + 3];\n      dst[dstOffset] = x0 * w1 + w0 * x1 + y0 * z1 - z0 * y1;\n      dst[dstOffset + 1] = y0 * w1 + w0 * y1 + z0 * x1 - x0 * z1;\n      dst[dstOffset + 2] = z0 * w1 + w0 * z1 + x0 * y1 - y0 * x1;\n      dst[dstOffset + 3] = w0 * w1 - x0 * x1 - y0 * y1 - z0 * z1;\n      return dst;\n    }\n    get x() {\n      return this._x;\n    }\n    set x(value) {\n      this._x = value;\n      this._onChangeCallback();\n    }\n    get y() {\n      return this._y;\n    }\n    set y(value) {\n      this._y = value;\n      this._onChangeCallback();\n    }\n    get z() {\n      return this._z;\n    }\n    set z(value) {\n      this._z = value;\n      this._onChangeCallback();\n    }\n    get w() {\n      return this._w;\n    }\n    set w(value) {\n      this._w = value;\n      this._onChangeCallback();\n    }\n    set(x2, y, z, w) {\n      this._x = x2;\n      this._y = y;\n      this._z = z;\n      this._w = w;\n      this._onChangeCallback();\n      return this;\n    }\n    clone() {\n      return new this.constructor(this._x, this._y, this._z, this._w);\n    }\n    copy(quaternion) {\n      this._x = quaternion.x;\n      this._y = quaternion.y;\n      this._z = quaternion.z;\n      this._w = quaternion.w;\n      this._onChangeCallback();\n      return this;\n    }\n    setFromEuler(euler, update = true) {\n      const x2 = euler._x, y = euler._y, z = euler._z, order = euler._order;\n      const cos = Math.cos;\n      const sin = Math.sin;\n      const c1 = cos(x2 / 2);\n      const c2 = cos(y / 2);\n      const c3 = cos(z / 2);\n      const s1 = sin(x2 / 2);\n      const s2 = sin(y / 2);\n      const s3 = sin(z / 2);\n      switch (order) {\n        case "XYZ":\n          this._x = s1 * c2 * c3 + c1 * s2 * s3;\n          this._y = c1 * s2 * c3 - s1 * c2 * s3;\n          this._z = c1 * c2 * s3 + s1 * s2 * c3;\n          this._w = c1 * c2 * c3 - s1 * s2 * s3;\n          break;\n        case "YXZ":\n          this._x = s1 * c2 * c3 + c1 * s2 * s3;\n          this._y = c1 * s2 * c3 - s1 * c2 * s3;\n          this._z = c1 * c2 * s3 - s1 * s2 * c3;\n          this._w = c1 * c2 * c3 + s1 * s2 * s3;\n          break;\n        case "ZXY":\n          this._x = s1 * c2 * c3 - c1 * s2 * s3;\n          this._y = c1 * s2 * c3 + s1 * c2 * s3;\n          this._z = c1 * c2 * s3 + s1 * s2 * c3;\n          this._w = c1 * c2 * c3 - s1 * s2 * s3;\n          break;\n        case "ZYX":\n          this._x = s1 * c2 * c3 - c1 * s2 * s3;\n          this._y = c1 * s2 * c3 + s1 * c2 * s3;\n          this._z = c1 * c2 * s3 - s1 * s2 * c3;\n          this._w = c1 * c2 * c3 + s1 * s2 * s3;\n          break;\n        case "YZX":\n          this._x = s1 * c2 * c3 + c1 * s2 * s3;\n          this._y = c1 * s2 * c3 + s1 * c2 * s3;\n          this._z = c1 * c2 * s3 - s1 * s2 * c3;\n          this._w = c1 * c2 * c3 - s1 * s2 * s3;\n          break;\n        case "XZY":\n          this._x = s1 * c2 * c3 - c1 * s2 * s3;\n          this._y = c1 * s2 * c3 - s1 * c2 * s3;\n          this._z = c1 * c2 * s3 + s1 * s2 * c3;\n          this._w = c1 * c2 * c3 + s1 * s2 * s3;\n          break;\n        default:\n          console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: " + order);\n      }\n      if (update === true) this._onChangeCallback();\n      return this;\n    }\n    setFromAxisAngle(axis, angle) {\n      const halfAngle = angle / 2, s = Math.sin(halfAngle);\n      this._x = axis.x * s;\n      this._y = axis.y * s;\n      this._z = axis.z * s;\n      this._w = Math.cos(halfAngle);\n      this._onChangeCallback();\n      return this;\n    }\n    setFromRotationMatrix(m) {\n      const te = m.elements, m11 = te[0], m12 = te[4], m13 = te[8], m21 = te[1], m22 = te[5], m23 = te[9], m31 = te[2], m32 = te[6], m33 = te[10], trace = m11 + m22 + m33;\n      if (trace > 0) {\n        const s = 0.5 / Math.sqrt(trace + 1);\n        this._w = 0.25 / s;\n        this._x = (m32 - m23) * s;\n        this._y = (m13 - m31) * s;\n        this._z = (m21 - m12) * s;\n      } else if (m11 > m22 && m11 > m33) {\n        const s = 2 * Math.sqrt(1 + m11 - m22 - m33);\n        this._w = (m32 - m23) / s;\n        this._x = 0.25 * s;\n        this._y = (m12 + m21) / s;\n        this._z = (m13 + m31) / s;\n      } else if (m22 > m33) {\n        const s = 2 * Math.sqrt(1 + m22 - m11 - m33);\n        this._w = (m13 - m31) / s;\n        this._x = (m12 + m21) / s;\n        this._y = 0.25 * s;\n        this._z = (m23 + m32) / s;\n      } else {\n        const s = 2 * Math.sqrt(1 + m33 - m11 - m22);\n        this._w = (m21 - m12) / s;\n        this._x = (m13 + m31) / s;\n        this._y = (m23 + m32) / s;\n        this._z = 0.25 * s;\n      }\n      this._onChangeCallback();\n      return this;\n    }\n    setFromUnitVectors(vFrom, vTo) {\n      let r = vFrom.dot(vTo) + 1;\n      if (r < Number.EPSILON) {\n        r = 0;\n        if (Math.abs(vFrom.x) > Math.abs(vFrom.z)) {\n          this._x = -vFrom.y;\n          this._y = vFrom.x;\n          this._z = 0;\n          this._w = r;\n        } else {\n          this._x = 0;\n          this._y = -vFrom.z;\n          this._z = vFrom.y;\n          this._w = r;\n        }\n      } else {\n        this._x = vFrom.y * vTo.z - vFrom.z * vTo.y;\n        this._y = vFrom.z * vTo.x - vFrom.x * vTo.z;\n        this._z = vFrom.x * vTo.y - vFrom.y * vTo.x;\n        this._w = r;\n      }\n      return this.normalize();\n    }\n    angleTo(q) {\n      return 2 * Math.acos(Math.abs(clamp(this.dot(q), -1, 1)));\n    }\n    rotateTowards(q, step) {\n      const angle = this.angleTo(q);\n      if (angle === 0) return this;\n      const t = Math.min(1, step / angle);\n      this.slerp(q, t);\n      return this;\n    }\n    identity() {\n      return this.set(0, 0, 0, 1);\n    }\n    invert() {\n      return this.conjugate();\n    }\n    conjugate() {\n      this._x *= -1;\n      this._y *= -1;\n      this._z *= -1;\n      this._onChangeCallback();\n      return this;\n    }\n    dot(v) {\n      return this._x * v._x + this._y * v._y + this._z * v._z + this._w * v._w;\n    }\n    lengthSq() {\n      return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;\n    }\n    length() {\n      return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w);\n    }\n    normalize() {\n      let l = this.length();\n      if (l === 0) {\n        this._x = 0;\n        this._y = 0;\n        this._z = 0;\n        this._w = 1;\n      } else {\n        l = 1 / l;\n        this._x = this._x * l;\n        this._y = this._y * l;\n        this._z = this._z * l;\n        this._w = this._w * l;\n      }\n      this._onChangeCallback();\n      return this;\n    }\n    multiply(q) {\n      return this.multiplyQuaternions(this, q);\n    }\n    premultiply(q) {\n      return this.multiplyQuaternions(q, this);\n    }\n    multiplyQuaternions(a, b) {\n      const qax = a._x, qay = a._y, qaz = a._z, qaw = a._w;\n      const qbx = b._x, qby = b._y, qbz = b._z, qbw = b._w;\n      this._x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;\n      this._y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;\n      this._z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;\n      this._w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;\n      this._onChangeCallback();\n      return this;\n    }\n    slerp(qb, t) {\n      if (t === 0) return this;\n      if (t === 1) return this.copy(qb);\n      const x2 = this._x, y = this._y, z = this._z, w = this._w;\n      let cosHalfTheta = w * qb._w + x2 * qb._x + y * qb._y + z * qb._z;\n      if (cosHalfTheta < 0) {\n        this._w = -qb._w;\n        this._x = -qb._x;\n        this._y = -qb._y;\n        this._z = -qb._z;\n        cosHalfTheta = -cosHalfTheta;\n      } else {\n        this.copy(qb);\n      }\n      if (cosHalfTheta >= 1) {\n        this._w = w;\n        this._x = x2;\n        this._y = y;\n        this._z = z;\n        return this;\n      }\n      const sqrSinHalfTheta = 1 - cosHalfTheta * cosHalfTheta;\n      if (sqrSinHalfTheta <= Number.EPSILON) {\n        const s = 1 - t;\n        this._w = s * w + t * this._w;\n        this._x = s * x2 + t * this._x;\n        this._y = s * y + t * this._y;\n        this._z = s * z + t * this._z;\n        this.normalize();\n        return this;\n      }\n      const sinHalfTheta = Math.sqrt(sqrSinHalfTheta);\n      const halfTheta = Math.atan2(sinHalfTheta, cosHalfTheta);\n      const ratioA = Math.sin((1 - t) * halfTheta) / sinHalfTheta, ratioB = Math.sin(t * halfTheta) / sinHalfTheta;\n      this._w = w * ratioA + this._w * ratioB;\n      this._x = x2 * ratioA + this._x * ratioB;\n      this._y = y * ratioA + this._y * ratioB;\n      this._z = z * ratioA + this._z * ratioB;\n      this._onChangeCallback();\n      return this;\n    }\n    slerpQuaternions(qa, qb, t) {\n      return this.copy(qa).slerp(qb, t);\n    }\n    random() {\n      const theta1 = 2 * Math.PI * Math.random();\n      const theta2 = 2 * Math.PI * Math.random();\n      const x0 = Math.random();\n      const r1 = Math.sqrt(1 - x0);\n      const r2 = Math.sqrt(x0);\n      return this.set(\n        r1 * Math.sin(theta1),\n        r1 * Math.cos(theta1),\n        r2 * Math.sin(theta2),\n        r2 * Math.cos(theta2)\n      );\n    }\n    equals(quaternion) {\n      return quaternion._x === this._x && quaternion._y === this._y && quaternion._z === this._z && quaternion._w === this._w;\n    }\n    fromArray(array, offset = 0) {\n      this._x = array[offset];\n      this._y = array[offset + 1];\n      this._z = array[offset + 2];\n      this._w = array[offset + 3];\n      this._onChangeCallback();\n      return this;\n    }\n    toArray(array = [], offset = 0) {\n      array[offset] = this._x;\n      array[offset + 1] = this._y;\n      array[offset + 2] = this._z;\n      array[offset + 3] = this._w;\n      return array;\n    }\n    fromBufferAttribute(attribute, index) {\n      this._x = attribute.getX(index);\n      this._y = attribute.getY(index);\n      this._z = attribute.getZ(index);\n      this._w = attribute.getW(index);\n      this._onChangeCallback();\n      return this;\n    }\n    toJSON() {\n      return this.toArray();\n    }\n    _onChange(callback) {\n      this._onChangeCallback = callback;\n      return this;\n    }\n    _onChangeCallback() {\n    }\n    *[Symbol.iterator]() {\n      yield this._x;\n      yield this._y;\n      yield this._z;\n      yield this._w;\n    }\n  }\n  class Vector3 {\n    constructor(x2 = 0, y = 0, z = 0) {\n      Vector3.prototype.isVector3 = true;\n      this.x = x2;\n      this.y = y;\n      this.z = z;\n    }\n    set(x2, y, z) {\n      if (z === void 0) z = this.z;\n      this.x = x2;\n      this.y = y;\n      this.z = z;\n      return this;\n    }\n    setScalar(scalar) {\n      this.x = scalar;\n      this.y = scalar;\n      this.z = scalar;\n      return this;\n    }\n    setX(x2) {\n      this.x = x2;\n      return this;\n    }\n    setY(y) {\n      this.y = y;\n      return this;\n    }\n    setZ(z) {\n      this.z = z;\n      return this;\n    }\n    setComponent(index, value) {\n      switch (index) {\n        case 0:\n          this.x = value;\n          break;\n        case 1:\n          this.y = value;\n          break;\n        case 2:\n          this.z = value;\n          break;\n        default:\n          throw new Error("index is out of range: " + index);\n      }\n      return this;\n    }\n    getComponent(index) {\n      switch (index) {\n        case 0:\n          return this.x;\n        case 1:\n          return this.y;\n        case 2:\n          return this.z;\n        default:\n          throw new Error("index is out of range: " + index);\n      }\n    }\n    clone() {\n      return new this.constructor(this.x, this.y, this.z);\n    }\n    copy(v) {\n      this.x = v.x;\n      this.y = v.y;\n      this.z = v.z;\n      return this;\n    }\n    add(v) {\n      this.x += v.x;\n      this.y += v.y;\n      this.z += v.z;\n      return this;\n    }\n    addScalar(s) {\n      this.x += s;\n      this.y += s;\n      this.z += s;\n      return this;\n    }\n    addVectors(a, b) {\n      this.x = a.x + b.x;\n      this.y = a.y + b.y;\n      this.z = a.z + b.z;\n      return this;\n    }\n    addScaledVector(v, s) {\n      this.x += v.x * s;\n      this.y += v.y * s;\n      this.z += v.z * s;\n      return this;\n    }\n    sub(v) {\n      this.x -= v.x;\n      this.y -= v.y;\n      this.z -= v.z;\n      return this;\n    }\n    subScalar(s) {\n      this.x -= s;\n      this.y -= s;\n      this.z -= s;\n      return this;\n    }\n    subVectors(a, b) {\n      this.x = a.x - b.x;\n      this.y = a.y - b.y;\n      this.z = a.z - b.z;\n      return this;\n    }\n    multiply(v) {\n      this.x *= v.x;\n      this.y *= v.y;\n      this.z *= v.z;\n      return this;\n    }\n    multiplyScalar(scalar) {\n      this.x *= scalar;\n      this.y *= scalar;\n      this.z *= scalar;\n      return this;\n    }\n    multiplyVectors(a, b) {\n      this.x = a.x * b.x;\n      this.y = a.y * b.y;\n      this.z = a.z * b.z;\n      return this;\n    }\n    applyEuler(euler) {\n      return this.applyQuaternion(_quaternion$4.setFromEuler(euler));\n    }\n    applyAxisAngle(axis, angle) {\n      return this.applyQuaternion(_quaternion$4.setFromAxisAngle(axis, angle));\n    }\n    applyMatrix3(m) {\n      const x2 = this.x, y = this.y, z = this.z;\n      const e = m.elements;\n      this.x = e[0] * x2 + e[3] * y + e[6] * z;\n      this.y = e[1] * x2 + e[4] * y + e[7] * z;\n      this.z = e[2] * x2 + e[5] * y + e[8] * z;\n      return this;\n    }\n    applyNormalMatrix(m) {\n      return this.applyMatrix3(m).normalize();\n    }\n    applyMatrix4(m) {\n      const x2 = this.x, y = this.y, z = this.z;\n      const e = m.elements;\n      const w = 1 / (e[3] * x2 + e[7] * y + e[11] * z + e[15]);\n      this.x = (e[0] * x2 + e[4] * y + e[8] * z + e[12]) * w;\n      this.y = (e[1] * x2 + e[5] * y + e[9] * z + e[13]) * w;\n      this.z = (e[2] * x2 + e[6] * y + e[10] * z + e[14]) * w;\n      return this;\n    }\n    applyQuaternion(q) {\n      const vx = this.x, vy = this.y, vz = this.z;\n      const qx = q.x, qy = q.y, qz = q.z, qw = q.w;\n      const tx = 2 * (qy * vz - qz * vy);\n      const ty = 2 * (qz * vx - qx * vz);\n      const tz = 2 * (qx * vy - qy * vx);\n      this.x = vx + qw * tx + qy * tz - qz * ty;\n      this.y = vy + qw * ty + qz * tx - qx * tz;\n      this.z = vz + qw * tz + qx * ty - qy * tx;\n      return this;\n    }\n    project(camera) {\n      return this.applyMatrix4(camera.matrixWorldInverse).applyMatrix4(camera.projectionMatrix);\n    }\n    unproject(camera) {\n      return this.applyMatrix4(camera.projectionMatrixInverse).applyMatrix4(camera.matrixWorld);\n    }\n    transformDirection(m) {\n      const x2 = this.x, y = this.y, z = this.z;\n      const e = m.elements;\n      this.x = e[0] * x2 + e[4] * y + e[8] * z;\n      this.y = e[1] * x2 + e[5] * y + e[9] * z;\n      this.z = e[2] * x2 + e[6] * y + e[10] * z;\n      return this.normalize();\n    }\n    divide(v) {\n      this.x /= v.x;\n      this.y /= v.y;\n      this.z /= v.z;\n      return this;\n    }\n    divideScalar(scalar) {\n      return this.multiplyScalar(1 / scalar);\n    }\n    min(v) {\n      this.x = Math.min(this.x, v.x);\n      this.y = Math.min(this.y, v.y);\n      this.z = Math.min(this.z, v.z);\n      return this;\n    }\n    max(v) {\n      this.x = Math.max(this.x, v.x);\n      this.y = Math.max(this.y, v.y);\n      this.z = Math.max(this.z, v.z);\n      return this;\n    }\n    clamp(min, max2) {\n      this.x = clamp(this.x, min.x, max2.x);\n      this.y = clamp(this.y, min.y, max2.y);\n      this.z = clamp(this.z, min.z, max2.z);\n      return this;\n    }\n    clampScalar(minVal, maxVal) {\n      this.x = clamp(this.x, minVal, maxVal);\n      this.y = clamp(this.y, minVal, maxVal);\n      this.z = clamp(this.z, minVal, maxVal);\n      return this;\n    }\n    clampLength(min, max2) {\n      const length = this.length();\n      return this.divideScalar(length || 1).multiplyScalar(clamp(length, min, max2));\n    }\n    floor() {\n      this.x = Math.floor(this.x);\n      this.y = Math.floor(this.y);\n      this.z = Math.floor(this.z);\n      return this;\n    }\n    ceil() {\n      this.x = Math.ceil(this.x);\n      this.y = Math.ceil(this.y);\n      this.z = Math.ceil(this.z);\n      return this;\n    }\n    round() {\n      this.x = Math.round(this.x);\n      this.y = Math.round(this.y);\n      this.z = Math.round(this.z);\n      return this;\n    }\n    roundToZero() {\n      this.x = Math.trunc(this.x);\n      this.y = Math.trunc(this.y);\n      this.z = Math.trunc(this.z);\n      return this;\n    }\n    negate() {\n      this.x = -this.x;\n      this.y = -this.y;\n      this.z = -this.z;\n      return this;\n    }\n    dot(v) {\n      return this.x * v.x + this.y * v.y + this.z * v.z;\n    }\n    // TODO lengthSquared?\n    lengthSq() {\n      return this.x * this.x + this.y * this.y + this.z * this.z;\n    }\n    length() {\n      return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);\n    }\n    manhattanLength() {\n      return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);\n    }\n    normalize() {\n      return this.divideScalar(this.length() || 1);\n    }\n    setLength(length) {\n      return this.normalize().multiplyScalar(length);\n    }\n    lerp(v, alpha) {\n      this.x += (v.x - this.x) * alpha;\n      this.y += (v.y - this.y) * alpha;\n      this.z += (v.z - this.z) * alpha;\n      return this;\n    }\n    lerpVectors(v1, v2, alpha) {\n      this.x = v1.x + (v2.x - v1.x) * alpha;\n      this.y = v1.y + (v2.y - v1.y) * alpha;\n      this.z = v1.z + (v2.z - v1.z) * alpha;\n      return this;\n    }\n    cross(v) {\n      return this.crossVectors(this, v);\n    }\n    crossVectors(a, b) {\n      const ax = a.x, ay = a.y, az = a.z;\n      const bx = b.x, by = b.y, bz = b.z;\n      this.x = ay * bz - az * by;\n      this.y = az * bx - ax * bz;\n      this.z = ax * by - ay * bx;\n      return this;\n    }\n    projectOnVector(v) {\n      const denominator = v.lengthSq();\n      if (denominator === 0) return this.set(0, 0, 0);\n      const scalar = v.dot(this) / denominator;\n      return this.copy(v).multiplyScalar(scalar);\n    }\n    projectOnPlane(planeNormal) {\n      _vector$c.copy(this).projectOnVector(planeNormal);\n      return this.sub(_vector$c);\n    }\n    reflect(normal) {\n      return this.sub(_vector$c.copy(normal).multiplyScalar(2 * this.dot(normal)));\n    }\n    angleTo(v) {\n      const denominator = Math.sqrt(this.lengthSq() * v.lengthSq());\n      if (denominator === 0) return Math.PI / 2;\n      const theta = this.dot(v) / denominator;\n      return Math.acos(clamp(theta, -1, 1));\n    }\n    distanceTo(v) {\n      return Math.sqrt(this.distanceToSquared(v));\n    }\n    distanceToSquared(v) {\n      const dx = this.x - v.x, dy = this.y - v.y, dz = this.z - v.z;\n      return dx * dx + dy * dy + dz * dz;\n    }\n    manhattanDistanceTo(v) {\n      return Math.abs(this.x - v.x) + Math.abs(this.y - v.y) + Math.abs(this.z - v.z);\n    }\n    setFromSpherical(s) {\n      return this.setFromSphericalCoords(s.radius, s.phi, s.theta);\n    }\n    setFromSphericalCoords(radius, phi, theta) {\n      const sinPhiRadius = Math.sin(phi) * radius;\n      this.x = sinPhiRadius * Math.sin(theta);\n      this.y = Math.cos(phi) * radius;\n      this.z = sinPhiRadius * Math.cos(theta);\n      return this;\n    }\n    setFromCylindrical(c) {\n      return this.setFromCylindricalCoords(c.radius, c.theta, c.y);\n    }\n    setFromCylindricalCoords(radius, theta, y) {\n      this.x = radius * Math.sin(theta);\n      this.y = y;\n      this.z = radius * Math.cos(theta);\n      return this;\n    }\n    setFromMatrixPosition(m) {\n      const e = m.elements;\n      this.x = e[12];\n      this.y = e[13];\n      this.z = e[14];\n      return this;\n    }\n    setFromMatrixScale(m) {\n      const sx = this.setFromMatrixColumn(m, 0).length();\n      const sy = this.setFromMatrixColumn(m, 1).length();\n      const sz = this.setFromMatrixColumn(m, 2).length();\n      this.x = sx;\n      this.y = sy;\n      this.z = sz;\n      return this;\n    }\n    setFromMatrixColumn(m, index) {\n      return this.fromArray(m.elements, index * 4);\n    }\n    setFromMatrix3Column(m, index) {\n      return this.fromArray(m.elements, index * 3);\n    }\n    setFromEuler(e) {\n      this.x = e._x;\n      this.y = e._y;\n      this.z = e._z;\n      return this;\n    }\n    setFromColor(c) {\n      this.x = c.r;\n      this.y = c.g;\n      this.z = c.b;\n      return this;\n    }\n    equals(v) {\n      return v.x === this.x && v.y === this.y && v.z === this.z;\n    }\n    fromArray(array, offset = 0) {\n      this.x = array[offset];\n      this.y = array[offset + 1];\n      this.z = array[offset + 2];\n      return this;\n    }\n    toArray(array = [], offset = 0) {\n      array[offset] = this.x;\n      array[offset + 1] = this.y;\n      array[offset + 2] = this.z;\n      return array;\n    }\n    fromBufferAttribute(attribute, index) {\n      this.x = attribute.getX(index);\n      this.y = attribute.getY(index);\n      this.z = attribute.getZ(index);\n      return this;\n    }\n    random() {\n      this.x = Math.random();\n      this.y = Math.random();\n      this.z = Math.random();\n      return this;\n    }\n    randomDirection() {\n      const theta = Math.random() * Math.PI * 2;\n      const u = Math.random() * 2 - 1;\n      const c = Math.sqrt(1 - u * u);\n      this.x = c * Math.cos(theta);\n      this.y = u;\n      this.z = c * Math.sin(theta);\n      return this;\n    }\n    *[Symbol.iterator]() {\n      yield this.x;\n      yield this.y;\n      yield this.z;\n    }\n  }\n  const _vector$c = /* @__PURE__ */ new Vector3();\n  const _quaternion$4 = /* @__PURE__ */ new Quaternion();\n  class Box3 {\n    constructor(min = new Vector3(Infinity, Infinity, Infinity), max2 = new Vector3(-Infinity, -Infinity, -Infinity)) {\n      this.isBox3 = true;\n      this.min = min;\n      this.max = max2;\n    }\n    set(min, max2) {\n      this.min.copy(min);\n      this.max.copy(max2);\n      return this;\n    }\n    setFromArray(array) {\n      this.makeEmpty();\n      for (let i2 = 0, il = array.length; i2 < il; i2 += 3) {\n        this.expandByPoint(_vector$b.fromArray(array, i2));\n      }\n      return this;\n    }\n    setFromBufferAttribute(attribute) {\n      this.makeEmpty();\n      for (let i2 = 0, il = attribute.count; i2 < il; i2++) {\n        this.expandByPoint(_vector$b.fromBufferAttribute(attribute, i2));\n      }\n      return this;\n    }\n    setFromPoints(points) {\n      this.makeEmpty();\n      for (let i2 = 0, il = points.length; i2 < il; i2++) {\n        this.expandByPoint(points[i2]);\n      }\n      return this;\n    }\n    setFromCenterAndSize(center, size) {\n      const halfSize = _vector$b.copy(size).multiplyScalar(0.5);\n      this.min.copy(center).sub(halfSize);\n      this.max.copy(center).add(halfSize);\n      return this;\n    }\n    setFromObject(object, precise = false) {\n      this.makeEmpty();\n      return this.expandByObject(object, precise);\n    }\n    clone() {\n      return new this.constructor().copy(this);\n    }\n    copy(box) {\n      this.min.copy(box.min);\n      this.max.copy(box.max);\n      return this;\n    }\n    makeEmpty() {\n      this.min.x = this.min.y = this.min.z = Infinity;\n      this.max.x = this.max.y = this.max.z = -Infinity;\n      return this;\n    }\n    isEmpty() {\n      return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z;\n    }\n    getCenter(target) {\n      return this.isEmpty() ? target.set(0, 0, 0) : target.addVectors(this.min, this.max).multiplyScalar(0.5);\n    }\n    getSize(target) {\n      return this.isEmpty() ? target.set(0, 0, 0) : target.subVectors(this.max, this.min);\n    }\n    expandByPoint(point) {\n      this.min.min(point);\n      this.max.max(point);\n      return this;\n    }\n    expandByVector(vector) {\n      this.min.sub(vector);\n      this.max.add(vector);\n      return this;\n    }\n    expandByScalar(scalar) {\n      this.min.addScalar(-scalar);\n      this.max.addScalar(scalar);\n      return this;\n    }\n    expandByObject(object, precise = false) {\n      object.updateWorldMatrix(false, false);\n      const geometry = object.geometry;\n      if (geometry !== void 0) {\n        const positionAttribute = geometry.getAttribute("position");\n        if (precise === true && positionAttribute !== void 0 && object.isInstancedMesh !== true) {\n          for (let i2 = 0, l = positionAttribute.count; i2 < l; i2++) {\n            if (object.isMesh === true) {\n              object.getVertexPosition(i2, _vector$b);\n            } else {\n              _vector$b.fromBufferAttribute(positionAttribute, i2);\n            }\n            _vector$b.applyMatrix4(object.matrixWorld);\n            this.expandByPoint(_vector$b);\n          }\n        } else {\n          if (object.boundingBox !== void 0) {\n            if (object.boundingBox === null) {\n              object.computeBoundingBox();\n            }\n            _box$4.copy(object.boundingBox);\n          } else {\n            if (geometry.boundingBox === null) {\n              geometry.computeBoundingBox();\n            }\n            _box$4.copy(geometry.boundingBox);\n          }\n          _box$4.applyMatrix4(object.matrixWorld);\n          this.union(_box$4);\n        }\n      }\n      const children = object.children;\n      for (let i2 = 0, l = children.length; i2 < l; i2++) {\n        this.expandByObject(children[i2], precise);\n      }\n      return this;\n    }\n    containsPoint(point) {\n      return point.x >= this.min.x && point.x <= this.max.x && point.y >= this.min.y && point.y <= this.max.y && point.z >= this.min.z && point.z <= this.max.z;\n    }\n    containsBox(box) {\n      return this.min.x <= box.min.x && box.max.x <= this.max.x && this.min.y <= box.min.y && box.max.y <= this.max.y && this.min.z <= box.min.z && box.max.z <= this.max.z;\n    }\n    getParameter(point, target) {\n      return target.set(\n        (point.x - this.min.x) / (this.max.x - this.min.x),\n        (point.y - this.min.y) / (this.max.y - this.min.y),\n        (point.z - this.min.z) / (this.max.z - this.min.z)\n      );\n    }\n    intersectsBox(box) {\n      return box.max.x >= this.min.x && box.min.x <= this.max.x && box.max.y >= this.min.y && box.min.y <= this.max.y && box.max.z >= this.min.z && box.min.z <= this.max.z;\n    }\n    intersectsSphere(sphere) {\n      this.clampPoint(sphere.center, _vector$b);\n      return _vector$b.distanceToSquared(sphere.center) <= sphere.radius * sphere.radius;\n    }\n    intersectsPlane(plane) {\n      let min, max2;\n      if (plane.normal.x > 0) {\n        min = plane.normal.x * this.min.x;\n        max2 = plane.normal.x * this.max.x;\n      } else {\n        min = plane.normal.x * this.max.x;\n        max2 = plane.normal.x * this.min.x;\n      }\n      if (plane.normal.y > 0) {\n        min += plane.normal.y * this.min.y;\n        max2 += plane.normal.y * this.max.y;\n      } else {\n        min += plane.normal.y * this.max.y;\n        max2 += plane.normal.y * this.min.y;\n      }\n      if (plane.normal.z > 0) {\n        min += plane.normal.z * this.min.z;\n        max2 += plane.normal.z * this.max.z;\n      } else {\n        min += plane.normal.z * this.max.z;\n        max2 += plane.normal.z * this.min.z;\n      }\n      return min <= -plane.constant && max2 >= -plane.constant;\n    }\n    intersectsTriangle(triangle) {\n      if (this.isEmpty()) {\n        return false;\n      }\n      this.getCenter(_center);\n      _extents.subVectors(this.max, _center);\n      _v0$2.subVectors(triangle.a, _center);\n      _v1$7.subVectors(triangle.b, _center);\n      _v2$4.subVectors(triangle.c, _center);\n      _f0.subVectors(_v1$7, _v0$2);\n      _f1.subVectors(_v2$4, _v1$7);\n      _f2.subVectors(_v0$2, _v2$4);\n      let axes = [\n        0,\n        -_f0.z,\n        _f0.y,\n        0,\n        -_f1.z,\n        _f1.y,\n        0,\n        -_f2.z,\n        _f2.y,\n        _f0.z,\n        0,\n        -_f0.x,\n        _f1.z,\n        0,\n        -_f1.x,\n        _f2.z,\n        0,\n        -_f2.x,\n        -_f0.y,\n        _f0.x,\n        0,\n        -_f1.y,\n        _f1.x,\n        0,\n        -_f2.y,\n        _f2.x,\n        0\n      ];\n      if (!satForAxes(axes, _v0$2, _v1$7, _v2$4, _extents)) {\n        return false;\n      }\n      axes = [1, 0, 0, 0, 1, 0, 0, 0, 1];\n      if (!satForAxes(axes, _v0$2, _v1$7, _v2$4, _extents)) {\n        return false;\n      }\n      _triangleNormal.crossVectors(_f0, _f1);\n      axes = [_triangleNormal.x, _triangleNormal.y, _triangleNormal.z];\n      return satForAxes(axes, _v0$2, _v1$7, _v2$4, _extents);\n    }\n    clampPoint(point, target) {\n      return target.copy(point).clamp(this.min, this.max);\n    }\n    distanceToPoint(point) {\n      return this.clampPoint(point, _vector$b).distanceTo(point);\n    }\n    getBoundingSphere(target) {\n      if (this.isEmpty()) {\n        target.makeEmpty();\n      } else {\n        this.getCenter(target.center);\n        target.radius = this.getSize(_vector$b).length() * 0.5;\n      }\n      return target;\n    }\n    intersect(box) {\n      this.min.max(box.min);\n      this.max.min(box.max);\n      if (this.isEmpty()) this.makeEmpty();\n      return this;\n    }\n    union(box) {\n      this.min.min(box.min);\n      this.max.max(box.max);\n      return this;\n    }\n    applyMatrix4(matrix) {\n      if (this.isEmpty()) return this;\n      _points[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(matrix);\n      _points[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(matrix);\n      _points[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(matrix);\n      _points[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(matrix);\n      _points[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(matrix);\n      _points[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(matrix);\n      _points[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(matrix);\n      _points[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(matrix);\n      this.setFromPoints(_points);\n      return this;\n    }\n    translate(offset) {\n      this.min.add(offset);\n      this.max.add(offset);\n      return this;\n    }\n    equals(box) {\n      return box.min.equals(this.min) && box.max.equals(this.max);\n    }\n  }\n  const _points = [\n    /* @__PURE__ */ new Vector3(),\n    /* @__PURE__ */ new Vector3(),\n    /* @__PURE__ */ new Vector3(),\n    /* @__PURE__ */ new Vector3(),\n    /* @__PURE__ */ new Vector3(),\n    /* @__PURE__ */ new Vector3(),\n    /* @__PURE__ */ new Vector3(),\n    /* @__PURE__ */ new Vector3()\n  ];\n  const _vector$b = /* @__PURE__ */ new Vector3();\n  const _box$4 = /* @__PURE__ */ new Box3();\n  const _v0$2 = /* @__PURE__ */ new Vector3();\n  const _v1$7 = /* @__PURE__ */ new Vector3();\n  const _v2$4 = /* @__PURE__ */ new Vector3();\n  const _f0 = /* @__PURE__ */ new Vector3();\n  const _f1 = /* @__PURE__ */ new Vector3();\n  const _f2 = /* @__PURE__ */ new Vector3();\n  const _center = /* @__PURE__ */ new Vector3();\n  const _extents = /* @__PURE__ */ new Vector3();\n  const _triangleNormal = /* @__PURE__ */ new Vector3();\n  const _testAxis = /* @__PURE__ */ new Vector3();\n  function satForAxes(axes, v0, v1, v2, extents) {\n    for (let i2 = 0, j = axes.length - 3; i2 <= j; i2 += 3) {\n      _testAxis.fromArray(axes, i2);\n      const r = extents.x * Math.abs(_testAxis.x) + extents.y * Math.abs(_testAxis.y) + extents.z * Math.abs(_testAxis.z);\n      const p0 = v0.dot(_testAxis);\n      const p1 = v1.dot(_testAxis);\n      const p2 = v2.dot(_testAxis);\n      if (Math.max(-Math.max(p0, p1, p2), Math.min(p0, p1, p2)) > r) {\n        return false;\n      }\n    }\n    return true;\n  }\n  const _box$3 = /* @__PURE__ */ new Box3();\n  const _v1$6 = /* @__PURE__ */ new Vector3();\n  const _v2$3 = /* @__PURE__ */ new Vector3();\n  class Sphere {\n    constructor(center = new Vector3(), radius = -1) {\n      this.isSphere = true;\n      this.center = center;\n      this.radius = radius;\n    }\n    set(center, radius) {\n      this.center.copy(center);\n      this.radius = radius;\n      return this;\n    }\n    setFromPoints(points, optionalCenter) {\n      const center = this.center;\n      if (optionalCenter !== void 0) {\n        center.copy(optionalCenter);\n      } else {\n        _box$3.setFromPoints(points).getCenter(center);\n      }\n      let maxRadiusSq = 0;\n      for (let i2 = 0, il = points.length; i2 < il; i2++) {\n        maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(points[i2]));\n      }\n      this.radius = Math.sqrt(maxRadiusSq);\n      return this;\n    }\n    copy(sphere) {\n      this.center.copy(sphere.center);\n      this.radius = sphere.radius;\n      return this;\n    }\n    isEmpty() {\n      return this.radius < 0;\n    }\n    makeEmpty() {\n      this.center.set(0, 0, 0);\n      this.radius = -1;\n      return this;\n    }\n    containsPoint(point) {\n      return point.distanceToSquared(this.center) <= this.radius * this.radius;\n    }\n    distanceToPoint(point) {\n      return point.distanceTo(this.center) - this.radius;\n    }\n    intersectsSphere(sphere) {\n      const radiusSum = this.radius + sphere.radius;\n      return sphere.center.distanceToSquared(this.center) <= radiusSum * radiusSum;\n    }\n    intersectsBox(box) {\n      return box.intersectsSphere(this);\n    }\n    intersectsPlane(plane) {\n      return Math.abs(plane.distanceToPoint(this.center)) <= this.radius;\n    }\n    clampPoint(point, target) {\n      const deltaLengthSq = this.center.distanceToSquared(point);\n      target.copy(point);\n      if (deltaLengthSq > this.radius * this.radius) {\n        target.sub(this.center).normalize();\n        target.multiplyScalar(this.radius).add(this.center);\n      }\n      return target;\n    }\n    getBoundingBox(target) {\n      if (this.isEmpty()) {\n        target.makeEmpty();\n        return target;\n      }\n      target.set(this.center, this.center);\n      target.expandByScalar(this.radius);\n      return target;\n    }\n    applyMatrix4(matrix) {\n      this.center.applyMatrix4(matrix);\n      this.radius = this.radius * matrix.getMaxScaleOnAxis();\n      return this;\n    }\n    translate(offset) {\n      this.center.add(offset);\n      return this;\n    }\n    expandByPoint(point) {\n      if (this.isEmpty()) {\n        this.center.copy(point);\n        this.radius = 0;\n        return this;\n      }\n      _v1$6.subVectors(point, this.center);\n      const lengthSq = _v1$6.lengthSq();\n      if (lengthSq > this.radius * this.radius) {\n        const length = Math.sqrt(lengthSq);\n        const delta = (length - this.radius) * 0.5;\n        this.center.addScaledVector(_v1$6, delta / length);\n        this.radius += delta;\n      }\n      return this;\n    }\n    union(sphere) {\n      if (sphere.isEmpty()) {\n        return this;\n      }\n      if (this.isEmpty()) {\n        this.copy(sphere);\n        return this;\n      }\n      if (this.center.equals(sphere.center) === true) {\n        this.radius = Math.max(this.radius, sphere.radius);\n      } else {\n        _v2$3.subVectors(sphere.center, this.center).setLength(sphere.radius);\n        this.expandByPoint(_v1$6.copy(sphere.center).add(_v2$3));\n        this.expandByPoint(_v1$6.copy(sphere.center).sub(_v2$3));\n      }\n      return this;\n    }\n    equals(sphere) {\n      return sphere.center.equals(this.center) && sphere.radius === this.radius;\n    }\n    clone() {\n      return new this.constructor().copy(this);\n    }\n  }\n  const _vector$a = /* @__PURE__ */ new Vector3();\n  const _segCenter = /* @__PURE__ */ new Vector3();\n  const _segDir = /* @__PURE__ */ new Vector3();\n  const _diff = /* @__PURE__ */ new Vector3();\n  const _edge1 = /* @__PURE__ */ new Vector3();\n  const _edge2 = /* @__PURE__ */ new Vector3();\n  const _normal$1 = /* @__PURE__ */ new Vector3();\n  class Ray {\n    constructor(origin = new Vector3(), direction = new Vector3(0, 0, -1)) {\n      this.origin = origin;\n      this.direction = direction;\n    }\n    set(origin, direction) {\n      this.origin.copy(origin);\n      this.direction.copy(direction);\n      return this;\n    }\n    copy(ray) {\n      this.origin.copy(ray.origin);\n      this.direction.copy(ray.direction);\n      return this;\n    }\n    at(t, target) {\n      return target.copy(this.origin).addScaledVector(this.direction, t);\n    }\n    lookAt(v) {\n      this.direction.copy(v).sub(this.origin).normalize();\n      return this;\n    }\n    recast(t) {\n      this.origin.copy(this.at(t, _vector$a));\n      return this;\n    }\n    closestPointToPoint(point, target) {\n      target.subVectors(point, this.origin);\n      const directionDistance = target.dot(this.direction);\n      if (directionDistance < 0) {\n        return target.copy(this.origin);\n      }\n      return target.copy(this.origin).addScaledVector(this.direction, directionDistance);\n    }\n    distanceToPoint(point) {\n      return Math.sqrt(this.distanceSqToPoint(point));\n    }\n    distanceSqToPoint(point) {\n      const directionDistance = _vector$a.subVectors(point, this.origin).dot(this.direction);\n      if (directionDistance < 0) {\n        return this.origin.distanceToSquared(point);\n      }\n      _vector$a.copy(this.origin).addScaledVector(this.direction, directionDistance);\n      return _vector$a.distanceToSquared(point);\n    }\n    distanceSqToSegment(v0, v1, optionalPointOnRay, optionalPointOnSegment) {\n      _segCenter.copy(v0).add(v1).multiplyScalar(0.5);\n      _segDir.copy(v1).sub(v0).normalize();\n      _diff.copy(this.origin).sub(_segCenter);\n      const segExtent = v0.distanceTo(v1) * 0.5;\n      const a01 = -this.direction.dot(_segDir);\n      const b0 = _diff.dot(this.direction);\n      const b1 = -_diff.dot(_segDir);\n      const c = _diff.lengthSq();\n      const det = Math.abs(1 - a01 * a01);\n      let s0, s1, sqrDist, extDet;\n      if (det > 0) {\n        s0 = a01 * b1 - b0;\n        s1 = a01 * b0 - b1;\n        extDet = segExtent * det;\n        if (s0 >= 0) {\n          if (s1 >= -extDet) {\n            if (s1 <= extDet) {\n              const invDet = 1 / det;\n              s0 *= invDet;\n              s1 *= invDet;\n              sqrDist = s0 * (s0 + a01 * s1 + 2 * b0) + s1 * (a01 * s0 + s1 + 2 * b1) + c;\n            } else {\n              s1 = segExtent;\n              s0 = Math.max(0, -(a01 * s1 + b0));\n              sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;\n            }\n          } else {\n            s1 = -segExtent;\n            s0 = Math.max(0, -(a01 * s1 + b0));\n            sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;\n          }\n        } else {\n          if (s1 <= -extDet) {\n            s0 = Math.max(0, -(-a01 * segExtent + b0));\n            s1 = s0 > 0 ? -segExtent : Math.min(Math.max(-segExtent, -b1), segExtent);\n            sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;\n          } else if (s1 <= extDet) {\n            s0 = 0;\n            s1 = Math.min(Math.max(-segExtent, -b1), segExtent);\n            sqrDist = s1 * (s1 + 2 * b1) + c;\n          } else {\n            s0 = Math.max(0, -(a01 * segExtent + b0));\n            s1 = s0 > 0 ? segExtent : Math.min(Math.max(-segExtent, -b1), segExtent);\n            sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;\n          }\n        }\n      } else {\n        s1 = a01 > 0 ? -segExtent : segExtent;\n        s0 = Math.max(0, -(a01 * s1 + b0));\n        sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;\n      }\n      if (optionalPointOnRay) {\n        optionalPointOnRay.copy(this.origin).addScaledVector(this.direction, s0);\n      }\n      if (optionalPointOnSegment) {\n        optionalPointOnSegment.copy(_segCenter).addScaledVector(_segDir, s1);\n      }\n      return sqrDist;\n    }\n    intersectSphere(sphere, target) {\n      _vector$a.subVectors(sphere.center, this.origin);\n      const tca = _vector$a.dot(this.direction);\n      const d2 = _vector$a.dot(_vector$a) - tca * tca;\n      const radius2 = sphere.radius * sphere.radius;\n      if (d2 > radius2) return null;\n      const thc = Math.sqrt(radius2 - d2);\n      const t0 = tca - thc;\n      const t1 = tca + thc;\n      if (t1 < 0) return null;\n      if (t0 < 0) return this.at(t1, target);\n      return this.at(t0, target);\n    }\n    intersectsSphere(sphere) {\n      return this.distanceSqToPoint(sphere.center) <= sphere.radius * sphere.radius;\n    }\n    distanceToPlane(plane) {\n      const denominator = plane.normal.dot(this.direction);\n      if (denominator === 0) {\n        if (plane.distanceToPoint(this.origin) === 0) {\n          return 0;\n        }\n        return null;\n      }\n      const t = -(this.origin.dot(plane.normal) + plane.constant) / denominator;\n      return t >= 0 ? t : null;\n    }\n    intersectPlane(plane, target) {\n      const t = this.distanceToPlane(plane);\n      if (t === null) {\n        return null;\n      }\n      return this.at(t, target);\n    }\n    intersectsPlane(plane) {\n      const distToPoint = plane.distanceToPoint(this.origin);\n      if (distToPoint === 0) {\n        return true;\n      }\n      const denominator = plane.normal.dot(this.direction);\n      if (denominator * distToPoint < 0) {\n        return true;\n      }\n      return false;\n    }\n    intersectBox(box, target) {\n      let tmin, tmax, tymin, tymax, tzmin, tzmax;\n      const invdirx = 1 / this.direction.x, invdiry = 1 / this.direction.y, invdirz = 1 / this.direction.z;\n      const origin = this.origin;\n      if (invdirx >= 0) {\n        tmin = (box.min.x - origin.x) * invdirx;\n        tmax = (box.max.x - origin.x) * invdirx;\n      } else {\n        tmin = (box.max.x - origin.x) * invdirx;\n        tmax = (box.min.x - origin.x) * invdirx;\n      }\n      if (invdiry >= 0) {\n        tymin = (box.min.y - origin.y) * invdiry;\n        tymax = (box.max.y - origin.y) * invdiry;\n      } else {\n        tymin = (box.max.y - origin.y) * invdiry;\n        tymax = (box.min.y - origin.y) * invdiry;\n      }\n      if (tmin > tymax || tymin > tmax) return null;\n      if (tymin > tmin || isNaN(tmin)) tmin = tymin;\n      if (tymax < tmax || isNaN(tmax)) tmax = tymax;\n      if (invdirz >= 0) {\n        tzmin = (box.min.z - origin.z) * invdirz;\n        tzmax = (box.max.z - origin.z) * invdirz;\n      } else {\n        tzmin = (box.max.z - origin.z) * invdirz;\n        tzmax = (box.min.z - origin.z) * invdirz;\n      }\n      if (tmin > tzmax || tzmin > tmax) return null;\n      if (tzmin > tmin || tmin !== tmin) tmin = tzmin;\n      if (tzmax < tmax || tmax !== tmax) tmax = tzmax;\n      if (tmax < 0) return null;\n      return this.at(tmin >= 0 ? tmin : tmax, target);\n    }\n    intersectsBox(box) {\n      return this.intersectBox(box, _vector$a) !== null;\n    }\n    intersectTriangle(a, b, c, backfaceCulling, target) {\n      _edge1.subVectors(b, a);\n      _edge2.subVectors(c, a);\n      _normal$1.crossVectors(_edge1, _edge2);\n      let DdN = this.direction.dot(_normal$1);\n      let sign;\n      if (DdN > 0) {\n        if (backfaceCulling) return null;\n        sign = 1;\n      } else if (DdN < 0) {\n        sign = -1;\n        DdN = -DdN;\n      } else {\n        return null;\n      }\n      _diff.subVectors(this.origin, a);\n      const DdQxE2 = sign * this.direction.dot(_edge2.crossVectors(_diff, _edge2));\n      if (DdQxE2 < 0) {\n        return null;\n      }\n      const DdE1xQ = sign * this.direction.dot(_edge1.cross(_diff));\n      if (DdE1xQ < 0) {\n        return null;\n      }\n      if (DdQxE2 + DdE1xQ > DdN) {\n        return null;\n      }\n      const QdN = -sign * _diff.dot(_normal$1);\n      if (QdN < 0) {\n        return null;\n      }\n      return this.at(QdN / DdN, target);\n    }\n    applyMatrix4(matrix4) {\n      this.origin.applyMatrix4(matrix4);\n      this.direction.transformDirection(matrix4);\n      return this;\n    }\n    equals(ray) {\n      return ray.origin.equals(this.origin) && ray.direction.equals(this.direction);\n    }\n    clone() {\n      return new this.constructor().copy(this);\n    }\n  }\n  class Matrix4 {\n    constructor(n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44) {\n      Matrix4.prototype.isMatrix4 = true;\n      this.elements = [\n        1,\n        0,\n        0,\n        0,\n        0,\n        1,\n        0,\n        0,\n        0,\n        0,\n        1,\n        0,\n        0,\n        0,\n        0,\n        1\n      ];\n      if (n11 !== void 0) {\n        this.set(n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44);\n      }\n    }\n    set(n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44) {\n      const te = this.elements;\n      te[0] = n11;\n      te[4] = n12;\n      te[8] = n13;\n      te[12] = n14;\n      te[1] = n21;\n      te[5] = n22;\n      te[9] = n23;\n      te[13] = n24;\n      te[2] = n31;\n      te[6] = n32;\n      te[10] = n33;\n      te[14] = n34;\n      te[3] = n41;\n      te[7] = n42;\n      te[11] = n43;\n      te[15] = n44;\n      return this;\n    }\n    identity() {\n      this.set(\n        1,\n        0,\n        0,\n        0,\n        0,\n        1,\n        0,\n        0,\n        0,\n        0,\n        1,\n        0,\n        0,\n        0,\n        0,\n        1\n      );\n      return this;\n    }\n    clone() {\n      return new Matrix4().fromArray(this.elements);\n    }\n    copy(m) {\n      const te = this.elements;\n      const me = m.elements;\n      te[0] = me[0];\n      te[1] = me[1];\n      te[2] = me[2];\n      te[3] = me[3];\n      te[4] = me[4];\n      te[5] = me[5];\n      te[6] = me[6];\n      te[7] = me[7];\n      te[8] = me[8];\n      te[9] = me[9];\n      te[10] = me[10];\n      te[11] = me[11];\n      te[12] = me[12];\n      te[13] = me[13];\n      te[14] = me[14];\n      te[15] = me[15];\n      return this;\n    }\n    copyPosition(m) {\n      const te = this.elements, me = m.elements;\n      te[12] = me[12];\n      te[13] = me[13];\n      te[14] = me[14];\n      return this;\n    }\n    setFromMatrix3(m) {\n      const me = m.elements;\n      this.set(\n        me[0],\n        me[3],\n        me[6],\n        0,\n        me[1],\n        me[4],\n        me[7],\n        0,\n        me[2],\n        me[5],\n        me[8],\n        0,\n        0,\n        0,\n        0,\n        1\n      );\n      return this;\n    }\n    extractBasis(xAxis, yAxis, zAxis) {\n      xAxis.setFromMatrixColumn(this, 0);\n      yAxis.setFromMatrixColumn(this, 1);\n      zAxis.setFromMatrixColumn(this, 2);\n      return this;\n    }\n    makeBasis(xAxis, yAxis, zAxis) {\n      this.set(\n        xAxis.x,\n        yAxis.x,\n        zAxis.x,\n        0,\n        xAxis.y,\n        yAxis.y,\n        zAxis.y,\n        0,\n        xAxis.z,\n        yAxis.z,\n        zAxis.z,\n        0,\n        0,\n        0,\n        0,\n        1\n      );\n      return this;\n    }\n    extractRotation(m) {\n      const te = this.elements;\n      const me = m.elements;\n      const scaleX = 1 / _v1$5.setFromMatrixColumn(m, 0).length();\n      const scaleY = 1 / _v1$5.setFromMatrixColumn(m, 1).length();\n      const scaleZ = 1 / _v1$5.setFromMatrixColumn(m, 2).length();\n      te[0] = me[0] * scaleX;\n      te[1] = me[1] * scaleX;\n      te[2] = me[2] * scaleX;\n      te[3] = 0;\n      te[4] = me[4] * scaleY;\n      te[5] = me[5] * scaleY;\n      te[6] = me[6] * scaleY;\n      te[7] = 0;\n      te[8] = me[8] * scaleZ;\n      te[9] = me[9] * scaleZ;\n      te[10] = me[10] * scaleZ;\n      te[11] = 0;\n      te[12] = 0;\n      te[13] = 0;\n      te[14] = 0;\n      te[15] = 1;\n      return this;\n    }\n    makeRotationFromEuler(euler) {\n      const te = this.elements;\n      const x2 = euler.x, y = euler.y, z = euler.z;\n      const a = Math.cos(x2), b = Math.sin(x2);\n      const c = Math.cos(y), d = Math.sin(y);\n      const e = Math.cos(z), f = Math.sin(z);\n      if (euler.order === "XYZ") {\n        const ae = a * e, af = a * f, be = b * e, bf = b * f;\n        te[0] = c * e;\n        te[4] = -c * f;\n        te[8] = d;\n        te[1] = af + be * d;\n        te[5] = ae - bf * d;\n        te[9] = -b * c;\n        te[2] = bf - ae * d;\n        te[6] = be + af * d;\n        te[10] = a * c;\n      } else if (euler.order === "YXZ") {\n        const ce = c * e, cf = c * f, de = d * e, df = d * f;\n        te[0] = ce + df * b;\n        te[4] = de * b - cf;\n        te[8] = a * d;\n        te[1] = a * f;\n        te[5] = a * e;\n        te[9] = -b;\n        te[2] = cf * b - de;\n        te[6] = df + ce * b;\n        te[10] = a * c;\n      } else if (euler.order === "ZXY") {\n        const ce = c * e, cf = c * f, de = d * e, df = d * f;\n        te[0] = ce - df * b;\n        te[4] = -a * f;\n        te[8] = de + cf * b;\n        te[1] = cf + de * b;\n        te[5] = a * e;\n        te[9] = df - ce * b;\n        te[2] = -a * d;\n        te[6] = b;\n        te[10] = a * c;\n      } else if (euler.order === "ZYX") {\n        const ae = a * e, af = a * f, be = b * e, bf = b * f;\n        te[0] = c * e;\n        te[4] = be * d - af;\n        te[8] = ae * d + bf;\n        te[1] = c * f;\n        te[5] = bf * d + ae;\n        te[9] = af * d - be;\n        te[2] = -d;\n        te[6] = b * c;\n        te[10] = a * c;\n      } else if (euler.order === "YZX") {\n        const ac = a * c, ad = a * d, bc = b * c, bd = b * d;\n        te[0] = c * e;\n        te[4] = bd - ac * f;\n        te[8] = bc * f + ad;\n        te[1] = f;\n        te[5] = a * e;\n        te[9] = -b * e;\n        te[2] = -d * e;\n        te[6] = ad * f + bc;\n        te[10] = ac - bd * f;\n      } else if (euler.order === "XZY") {\n        const ac = a * c, ad = a * d, bc = b * c, bd = b * d;\n        te[0] = c * e;\n        te[4] = -f;\n        te[8] = d * e;\n        te[1] = ac * f + bd;\n        te[5] = a * e;\n        te[9] = ad * f - bc;\n        te[2] = bc * f - ad;\n        te[6] = b * e;\n        te[10] = bd * f + ac;\n      }\n      te[3] = 0;\n      te[7] = 0;\n      te[11] = 0;\n      te[12] = 0;\n      te[13] = 0;\n      te[14] = 0;\n      te[15] = 1;\n      return this;\n    }\n    makeRotationFromQuaternion(q) {\n      return this.compose(_zero, q, _one);\n    }\n    lookAt(eye, target, up) {\n      const te = this.elements;\n      _z.subVectors(eye, target);\n      if (_z.lengthSq() === 0) {\n        _z.z = 1;\n      }\n      _z.normalize();\n      _x.crossVectors(up, _z);\n      if (_x.lengthSq() === 0) {\n        if (Math.abs(up.z) === 1) {\n          _z.x += 1e-4;\n        } else {\n          _z.z += 1e-4;\n        }\n        _z.normalize();\n        _x.crossVectors(up, _z);\n      }\n      _x.normalize();\n      _y.crossVectors(_z, _x);\n      te[0] = _x.x;\n      te[4] = _y.x;\n      te[8] = _z.x;\n      te[1] = _x.y;\n      te[5] = _y.y;\n      te[9] = _z.y;\n      te[2] = _x.z;\n      te[6] = _y.z;\n      te[10] = _z.z;\n      return this;\n    }\n    multiply(m) {\n      return this.multiplyMatrices(this, m);\n    }\n    premultiply(m) {\n      return this.multiplyMatrices(m, this);\n    }\n    multiplyMatrices(a, b) {\n      const ae = a.elements;\n      const be = b.elements;\n      const te = this.elements;\n      const a11 = ae[0], a12 = ae[4], a13 = ae[8], a14 = ae[12];\n      const a21 = ae[1], a22 = ae[5], a23 = ae[9], a24 = ae[13];\n      const a31 = ae[2], a32 = ae[6], a33 = ae[10], a34 = ae[14];\n      const a41 = ae[3], a42 = ae[7], a43 = ae[11], a44 = ae[15];\n      const b11 = be[0], b12 = be[4], b13 = be[8], b14 = be[12];\n      const b21 = be[1], b22 = be[5], b23 = be[9], b24 = be[13];\n      const b31 = be[2], b32 = be[6], b33 = be[10], b34 = be[14];\n      const b41 = be[3], b42 = be[7], b43 = be[11], b44 = be[15];\n      te[0] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;\n      te[4] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;\n      te[8] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;\n      te[12] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;\n      te[1] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;\n      te[5] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;\n      te[9] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;\n      te[13] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;\n      te[2] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;\n      te[6] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;\n      te[10] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;\n      te[14] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;\n      te[3] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;\n      te[7] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;\n      te[11] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;\n      te[15] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;\n      return this;\n    }\n    multiplyScalar(s) {\n      const te = this.elements;\n      te[0] *= s;\n      te[4] *= s;\n      te[8] *= s;\n      te[12] *= s;\n      te[1] *= s;\n      te[5] *= s;\n      te[9] *= s;\n      te[13] *= s;\n      te[2] *= s;\n      te[6] *= s;\n      te[10] *= s;\n      te[14] *= s;\n      te[3] *= s;\n      te[7] *= s;\n      te[11] *= s;\n      te[15] *= s;\n      return this;\n    }\n    determinant() {\n      const te = this.elements;\n      const n11 = te[0], n12 = te[4], n13 = te[8], n14 = te[12];\n      const n21 = te[1], n22 = te[5], n23 = te[9], n24 = te[13];\n      const n31 = te[2], n32 = te[6], n33 = te[10], n34 = te[14];\n      const n41 = te[3], n42 = te[7], n43 = te[11], n44 = te[15];\n      return n41 * (+n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34) + n42 * (+n11 * n23 * n34 - n11 * n24 * n33 + n14 * n21 * n33 - n13 * n21 * n34 + n13 * n24 * n31 - n14 * n23 * n31) + n43 * (+n11 * n24 * n32 - n11 * n22 * n34 - n14 * n21 * n32 + n12 * n21 * n34 + n14 * n22 * n31 - n12 * n24 * n31) + n44 * (-n13 * n22 * n31 - n11 * n23 * n32 + n11 * n22 * n33 + n13 * n21 * n32 - n12 * n21 * n33 + n12 * n23 * n31);\n    }\n    transpose() {\n      const te = this.elements;\n      let tmp;\n      tmp = te[1];\n      te[1] = te[4];\n      te[4] = tmp;\n      tmp = te[2];\n      te[2] = te[8];\n      te[8] = tmp;\n      tmp = te[6];\n      te[6] = te[9];\n      te[9] = tmp;\n      tmp = te[3];\n      te[3] = te[12];\n      te[12] = tmp;\n      tmp = te[7];\n      te[7] = te[13];\n      te[13] = tmp;\n      tmp = te[11];\n      te[11] = te[14];\n      te[14] = tmp;\n      return this;\n    }\n    setPosition(x2, y, z) {\n      const te = this.elements;\n      if (x2.isVector3) {\n        te[12] = x2.x;\n        te[13] = x2.y;\n        te[14] = x2.z;\n      } else {\n        te[12] = x2;\n        te[13] = y;\n        te[14] = z;\n      }\n      return this;\n    }\n    invert() {\n      const te = this.elements, n11 = te[0], n21 = te[1], n31 = te[2], n41 = te[3], n12 = te[4], n22 = te[5], n32 = te[6], n42 = te[7], n13 = te[8], n23 = te[9], n33 = te[10], n43 = te[11], n14 = te[12], n24 = te[13], n34 = te[14], n44 = te[15], t11 = n23 * n34 * n42 - n24 * n33 * n42 + n24 * n32 * n43 - n22 * n34 * n43 - n23 * n32 * n44 + n22 * n33 * n44, t12 = n14 * n33 * n42 - n13 * n34 * n42 - n14 * n32 * n43 + n12 * n34 * n43 + n13 * n32 * n44 - n12 * n33 * n44, t13 = n13 * n24 * n42 - n14 * n23 * n42 + n14 * n22 * n43 - n12 * n24 * n43 - n13 * n22 * n44 + n12 * n23 * n44, t14 = n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34;\n      const det = n11 * t11 + n21 * t12 + n31 * t13 + n41 * t14;\n      if (det === 0) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);\n      const detInv = 1 / det;\n      te[0] = t11 * detInv;\n      te[1] = (n24 * n33 * n41 - n23 * n34 * n41 - n24 * n31 * n43 + n21 * n34 * n43 + n23 * n31 * n44 - n21 * n33 * n44) * detInv;\n      te[2] = (n22 * n34 * n41 - n24 * n32 * n41 + n24 * n31 * n42 - n21 * n34 * n42 - n22 * n31 * n44 + n21 * n32 * n44) * detInv;\n      te[3] = (n23 * n32 * n41 - n22 * n33 * n41 - n23 * n31 * n42 + n21 * n33 * n42 + n22 * n31 * n43 - n21 * n32 * n43) * detInv;\n      te[4] = t12 * detInv;\n      te[5] = (n13 * n34 * n41 - n14 * n33 * n41 + n14 * n31 * n43 - n11 * n34 * n43 - n13 * n31 * n44 + n11 * n33 * n44) * detInv;\n      te[6] = (n14 * n32 * n41 - n12 * n34 * n41 - n14 * n31 * n42 + n11 * n34 * n42 + n12 * n31 * n44 - n11 * n32 * n44) * detInv;\n      te[7] = (n12 * n33 * n41 - n13 * n32 * n41 + n13 * n31 * n42 - n11 * n33 * n42 - n12 * n31 * n43 + n11 * n32 * n43) * detInv;\n      te[8] = t13 * detInv;\n      te[9] = (n14 * n23 * n41 - n13 * n24 * n41 - n14 * n21 * n43 + n11 * n24 * n43 + n13 * n21 * n44 - n11 * n23 * n44) * detInv;\n      te[10] = (n12 * n24 * n41 - n14 * n22 * n41 + n14 * n21 * n42 - n11 * n24 * n42 - n12 * n21 * n44 + n11 * n22 * n44) * detInv;\n      te[11] = (n13 * n22 * n41 - n12 * n23 * n41 - n13 * n21 * n42 + n11 * n23 * n42 + n12 * n21 * n43 - n11 * n22 * n43) * detInv;\n      te[12] = t14 * detInv;\n      te[13] = (n13 * n24 * n31 - n14 * n23 * n31 + n14 * n21 * n33 - n11 * n24 * n33 - n13 * n21 * n34 + n11 * n23 * n34) * detInv;\n      te[14] = (n14 * n22 * n31 - n12 * n24 * n31 - n14 * n21 * n32 + n11 * n24 * n32 + n12 * n21 * n34 - n11 * n22 * n34) * detInv;\n      te[15] = (n12 * n23 * n31 - n13 * n22 * n31 + n13 * n21 * n32 - n11 * n23 * n32 - n12 * n21 * n33 + n11 * n22 * n33) * detInv;\n      return this;\n    }\n    scale(v) {\n      const te = this.elements;\n      const x2 = v.x, y = v.y, z = v.z;\n      te[0] *= x2;\n      te[4] *= y;\n      te[8] *= z;\n      te[1] *= x2;\n      te[5] *= y;\n      te[9] *= z;\n      te[2] *= x2;\n      te[6] *= y;\n      te[10] *= z;\n      te[3] *= x2;\n      te[7] *= y;\n      te[11] *= z;\n      return this;\n    }\n    getMaxScaleOnAxis() {\n      const te = this.elements;\n      const scaleXSq = te[0] * te[0] + te[1] * te[1] + te[2] * te[2];\n      const scaleYSq = te[4] * te[4] + te[5] * te[5] + te[6] * te[6];\n      const scaleZSq = te[8] * te[8] + te[9] * te[9] + te[10] * te[10];\n      return Math.sqrt(Math.max(scaleXSq, scaleYSq, scaleZSq));\n    }\n    makeTranslation(x2, y, z) {\n      if (x2.isVector3) {\n        this.set(\n          1,\n          0,\n          0,\n          x2.x,\n          0,\n          1,\n          0,\n          x2.y,\n          0,\n          0,\n          1,\n          x2.z,\n          0,\n          0,\n          0,\n          1\n        );\n      } else {\n        this.set(\n          1,\n          0,\n          0,\n          x2,\n          0,\n          1,\n          0,\n          y,\n          0,\n          0,\n          1,\n          z,\n          0,\n          0,\n          0,\n          1\n        );\n      }\n      return this;\n    }\n    makeRotationX(theta) {\n      const c = Math.cos(theta), s = Math.sin(theta);\n      this.set(\n        1,\n        0,\n        0,\n        0,\n        0,\n        c,\n        -s,\n        0,\n        0,\n        s,\n        c,\n        0,\n        0,\n        0,\n        0,\n        1\n      );\n      return this;\n    }\n    makeRotationY(theta) {\n      const c = Math.cos(theta), s = Math.sin(theta);\n      this.set(\n        c,\n        0,\n        s,\n        0,\n        0,\n        1,\n        0,\n        0,\n        -s,\n        0,\n        c,\n        0,\n        0,\n        0,\n        0,\n        1\n      );\n      return this;\n    }\n    makeRotationZ(theta) {\n      const c = Math.cos(theta), s = Math.sin(theta);\n      this.set(\n        c,\n        -s,\n        0,\n        0,\n        s,\n        c,\n        0,\n        0,\n        0,\n        0,\n        1,\n        0,\n        0,\n        0,\n        0,\n        1\n      );\n      return this;\n    }\n    makeRotationAxis(axis, angle) {\n      const c = Math.cos(angle);\n      const s = Math.sin(angle);\n      const t = 1 - c;\n      const x2 = axis.x, y = axis.y, z = axis.z;\n      const tx = t * x2, ty = t * y;\n      this.set(\n        tx * x2 + c,\n        tx * y - s * z,\n        tx * z + s * y,\n        0,\n        tx * y + s * z,\n        ty * y + c,\n        ty * z - s * x2,\n        0,\n        tx * z - s * y,\n        ty * z + s * x2,\n        t * z * z + c,\n        0,\n        0,\n        0,\n        0,\n        1\n      );\n      return this;\n    }\n    makeScale(x2, y, z) {\n      this.set(\n        x2,\n        0,\n        0,\n        0,\n        0,\n        y,\n        0,\n        0,\n        0,\n        0,\n        z,\n        0,\n        0,\n        0,\n        0,\n        1\n      );\n      return this;\n    }\n    makeShear(xy, xz, yx, yz, zx, zy) {\n      this.set(\n        1,\n        yx,\n        zx,\n        0,\n        xy,\n        1,\n        zy,\n        0,\n        xz,\n        yz,\n        1,\n        0,\n        0,\n        0,\n        0,\n        1\n      );\n      return this;\n    }\n    compose(position, quaternion, scale) {\n      const te = this.elements;\n      const x2 = quaternion._x, y = quaternion._y, z = quaternion._z, w = quaternion._w;\n      const x22 = x2 + x2, y2 = y + y, z2 = z + z;\n      const xx = x2 * x22, xy = x2 * y2, xz = x2 * z2;\n      const yy = y * y2, yz = y * z2, zz = z * z2;\n      const wx = w * x22, wy = w * y2, wz = w * z2;\n      const sx = scale.x, sy = scale.y, sz = scale.z;\n      te[0] = (1 - (yy + zz)) * sx;\n      te[1] = (xy + wz) * sx;\n      te[2] = (xz - wy) * sx;\n      te[3] = 0;\n      te[4] = (xy - wz) * sy;\n      te[5] = (1 - (xx + zz)) * sy;\n      te[6] = (yz + wx) * sy;\n      te[7] = 0;\n      te[8] = (xz + wy) * sz;\n      te[9] = (yz - wx) * sz;\n      te[10] = (1 - (xx + yy)) * sz;\n      te[11] = 0;\n      te[12] = position.x;\n      te[13] = position.y;\n      te[14] = position.z;\n      te[15] = 1;\n      return this;\n    }\n    decompose(position, quaternion, scale) {\n      const te = this.elements;\n      let sx = _v1$5.set(te[0], te[1], te[2]).length();\n      const sy = _v1$5.set(te[4], te[5], te[6]).length();\n      const sz = _v1$5.set(te[8], te[9], te[10]).length();\n      const det = this.determinant();\n      if (det < 0) sx = -sx;\n      position.x = te[12];\n      position.y = te[13];\n      position.z = te[14];\n      _m1$2.copy(this);\n      const invSX = 1 / sx;\n      const invSY = 1 / sy;\n      const invSZ = 1 / sz;\n      _m1$2.elements[0] *= invSX;\n      _m1$2.elements[1] *= invSX;\n      _m1$2.elements[2] *= invSX;\n      _m1$2.elements[4] *= invSY;\n      _m1$2.elements[5] *= invSY;\n      _m1$2.elements[6] *= invSY;\n      _m1$2.elements[8] *= invSZ;\n      _m1$2.elements[9] *= invSZ;\n      _m1$2.elements[10] *= invSZ;\n      quaternion.setFromRotationMatrix(_m1$2);\n      scale.x = sx;\n      scale.y = sy;\n      scale.z = sz;\n      return this;\n    }\n    makePerspective(left, right, top, bottom, near, far, coordinateSystem = WebGLCoordinateSystem) {\n      const te = this.elements;\n      const x2 = 2 * near / (right - left);\n      const y = 2 * near / (top - bottom);\n      const a = (right + left) / (right - left);\n      const b = (top + bottom) / (top - bottom);\n      let c, d;\n      if (coordinateSystem === WebGLCoordinateSystem) {\n        c = -(far + near) / (far - near);\n        d = -2 * far * near / (far - near);\n      } else if (coordinateSystem === WebGPUCoordinateSystem) {\n        c = -far / (far - near);\n        d = -far * near / (far - near);\n      } else {\n        throw new Error("THREE.Matrix4.makePerspective(): Invalid coordinate system: " + coordinateSystem);\n      }\n      te[0] = x2;\n      te[4] = 0;\n      te[8] = a;\n      te[12] = 0;\n      te[1] = 0;\n      te[5] = y;\n      te[9] = b;\n      te[13] = 0;\n      te[2] = 0;\n      te[6] = 0;\n      te[10] = c;\n      te[14] = d;\n      te[3] = 0;\n      te[7] = 0;\n      te[11] = -1;\n      te[15] = 0;\n      return this;\n    }\n    makeOrthographic(left, right, top, bottom, near, far, coordinateSystem = WebGLCoordinateSystem) {\n      const te = this.elements;\n      const w = 1 / (right - left);\n      const h = 1 / (top - bottom);\n      const p = 1 / (far - near);\n      const x2 = (right + left) * w;\n      const y = (top + bottom) * h;\n      let z, zInv;\n      if (coordinateSystem === WebGLCoordinateSystem) {\n        z = (far + near) * p;\n        zInv = -2 * p;\n      } else if (coordinateSystem === WebGPUCoordinateSystem) {\n        z = near * p;\n        zInv = -1 * p;\n      } else {\n        throw new Error("THREE.Matrix4.makeOrthographic(): Invalid coordinate system: " + coordinateSystem);\n      }\n      te[0] = 2 * w;\n      te[4] = 0;\n      te[8] = 0;\n      te[12] = -x2;\n      te[1] = 0;\n      te[5] = 2 * h;\n      te[9] = 0;\n      te[13] = -y;\n      te[2] = 0;\n      te[6] = 0;\n      te[10] = zInv;\n      te[14] = -z;\n      te[3] = 0;\n      te[7] = 0;\n      te[11] = 0;\n      te[15] = 1;\n      return this;\n    }\n    equals(matrix) {\n      const te = this.elements;\n      const me = matrix.elements;\n      for (let i2 = 0; i2 < 16; i2++) {\n        if (te[i2] !== me[i2]) return false;\n      }\n      return true;\n    }\n    fromArray(array, offset = 0) {\n      for (let i2 = 0; i2 < 16; i2++) {\n        this.elements[i2] = array[i2 + offset];\n      }\n      return this;\n    }\n    toArray(array = [], offset = 0) {\n      const te = this.elements;\n      array[offset] = te[0];\n      array[offset + 1] = te[1];\n      array[offset + 2] = te[2];\n      array[offset + 3] = te[3];\n      array[offset + 4] = te[4];\n      array[offset + 5] = te[5];\n      array[offset + 6] = te[6];\n      array[offset + 7] = te[7];\n      array[offset + 8] = te[8];\n      array[offset + 9] = te[9];\n      array[offset + 10] = te[10];\n      array[offset + 11] = te[11];\n      array[offset + 12] = te[12];\n      array[offset + 13] = te[13];\n      array[offset + 14] = te[14];\n      array[offset + 15] = te[15];\n      return array;\n    }\n  }\n  const _v1$5 = /* @__PURE__ */ new Vector3();\n  const _m1$2 = /* @__PURE__ */ new Matrix4();\n  const _zero = /* @__PURE__ */ new Vector3(0, 0, 0);\n  const _one = /* @__PURE__ */ new Vector3(1, 1, 1);\n  const _x = /* @__PURE__ */ new Vector3();\n  const _y = /* @__PURE__ */ new Vector3();\n  const _z = /* @__PURE__ */ new Vector3();\n  const _matrix$2 = /* @__PURE__ */ new Matrix4();\n  const _quaternion$3 = /* @__PURE__ */ new Quaternion();\n  class Euler {\n    constructor(x2 = 0, y = 0, z = 0, order = Euler.DEFAULT_ORDER) {\n      this.isEuler = true;\n      this._x = x2;\n      this._y = y;\n      this._z = z;\n      this._order = order;\n    }\n    get x() {\n      return this._x;\n    }\n    set x(value) {\n      this._x = value;\n      this._onChangeCallback();\n    }\n    get y() {\n      return this._y;\n    }\n    set y(value) {\n      this._y = value;\n      this._onChangeCallback();\n    }\n    get z() {\n      return this._z;\n    }\n    set z(value) {\n      this._z = value;\n      this._onChangeCallback();\n    }\n    get order() {\n      return this._order;\n    }\n    set order(value) {\n      this._order = value;\n      this._onChangeCallback();\n    }\n    set(x2, y, z, order = this._order) {\n      this._x = x2;\n      this._y = y;\n      this._z = z;\n      this._order = order;\n      this._onChangeCallback();\n      return this;\n    }\n    clone() {\n      return new this.constructor(this._x, this._y, this._z, this._order);\n    }\n    copy(euler) {\n      this._x = euler._x;\n      this._y = euler._y;\n      this._z = euler._z;\n      this._order = euler._order;\n      this._onChangeCallback();\n      return this;\n    }\n    setFromRotationMatrix(m, order = this._order, update = true) {\n      const te = m.elements;\n      const m11 = te[0], m12 = te[4], m13 = te[8];\n      const m21 = te[1], m22 = te[5], m23 = te[9];\n      const m31 = te[2], m32 = te[6], m33 = te[10];\n      switch (order) {\n        case "XYZ":\n          this._y = Math.asin(clamp(m13, -1, 1));\n          if (Math.abs(m13) < 0.9999999) {\n            this._x = Math.atan2(-m23, m33);\n            this._z = Math.atan2(-m12, m11);\n          } else {\n            this._x = Math.atan2(m32, m22);\n            this._z = 0;\n          }\n          break;\n        case "YXZ":\n          this._x = Math.asin(-clamp(m23, -1, 1));\n          if (Math.abs(m23) < 0.9999999) {\n            this._y = Math.atan2(m13, m33);\n            this._z = Math.atan2(m21, m22);\n          } else {\n            this._y = Math.atan2(-m31, m11);\n            this._z = 0;\n          }\n          break;\n        case "ZXY":\n          this._x = Math.asin(clamp(m32, -1, 1));\n          if (Math.abs(m32) < 0.9999999) {\n            this._y = Math.atan2(-m31, m33);\n            this._z = Math.atan2(-m12, m22);\n          } else {\n            this._y = 0;\n            this._z = Math.atan2(m21, m11);\n          }\n          break;\n        case "ZYX":\n          this._y = Math.asin(-clamp(m31, -1, 1));\n          if (Math.abs(m31) < 0.9999999) {\n            this._x = Math.atan2(m32, m33);\n            this._z = Math.atan2(m21, m11);\n          } else {\n            this._x = 0;\n            this._z = Math.atan2(-m12, m22);\n          }\n          break;\n        case "YZX":\n          this._z = Math.asin(clamp(m21, -1, 1));\n          if (Math.abs(m21) < 0.9999999) {\n            this._x = Math.atan2(-m23, m22);\n            this._y = Math.atan2(-m31, m11);\n          } else {\n            this._x = 0;\n            this._y = Math.atan2(m13, m33);\n          }\n          break;\n        case "XZY":\n          this._z = Math.asin(-clamp(m12, -1, 1));\n          if (Math.abs(m12) < 0.9999999) {\n            this._x = Math.atan2(m32, m22);\n            this._y = Math.atan2(m13, m11);\n          } else {\n            this._x = Math.atan2(-m23, m33);\n            this._y = 0;\n          }\n          break;\n        default:\n          console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " + order);\n      }\n      this._order = order;\n      if (update === true) this._onChangeCallback();\n      return this;\n    }\n    setFromQuaternion(q, order, update) {\n      _matrix$2.makeRotationFromQuaternion(q);\n      return this.setFromRotationMatrix(_matrix$2, order, update);\n    }\n    setFromVector3(v, order = this._order) {\n      return this.set(v.x, v.y, v.z, order);\n    }\n    reorder(newOrder) {\n      _quaternion$3.setFromEuler(this);\n      return this.setFromQuaternion(_quaternion$3, newOrder);\n    }\n    equals(euler) {\n      return euler._x === this._x && euler._y === this._y && euler._z === this._z && euler._order === this._order;\n    }\n    fromArray(array) {\n      this._x = array[0];\n      this._y = array[1];\n      this._z = array[2];\n      if (array[3] !== void 0) this._order = array[3];\n      this._onChangeCallback();\n      return this;\n    }\n    toArray(array = [], offset = 0) {\n      array[offset] = this._x;\n      array[offset + 1] = this._y;\n      array[offset + 2] = this._z;\n      array[offset + 3] = this._order;\n      return array;\n    }\n    _onChange(callback) {\n      this._onChangeCallback = callback;\n      return this;\n    }\n    _onChangeCallback() {\n    }\n    *[Symbol.iterator]() {\n      yield this._x;\n      yield this._y;\n      yield this._z;\n      yield this._order;\n    }\n  }\n  Euler.DEFAULT_ORDER = "XYZ";\n  class Layers {\n    constructor() {\n      this.mask = 1 | 0;\n    }\n    set(channel) {\n      this.mask = (1 << channel | 0) >>> 0;\n    }\n    enable(channel) {\n      this.mask |= 1 << channel | 0;\n    }\n    enableAll() {\n      this.mask = 4294967295 | 0;\n    }\n    toggle(channel) {\n      this.mask ^= 1 << channel | 0;\n    }\n    disable(channel) {\n      this.mask &= ~(1 << channel | 0);\n    }\n    disableAll() {\n      this.mask = 0;\n    }\n    test(layers) {\n      return (this.mask & layers.mask) !== 0;\n    }\n    isEnabled(channel) {\n      return (this.mask & (1 << channel | 0)) !== 0;\n    }\n  }\n  let _object3DId = 0;\n  const _v1$4 = /* @__PURE__ */ new Vector3();\n  const _q1 = /* @__PURE__ */ new Quaternion();\n  const _m1$1 = /* @__PURE__ */ new Matrix4();\n  const _target = /* @__PURE__ */ new Vector3();\n  const _position$3 = /* @__PURE__ */ new Vector3();\n  const _scale$2 = /* @__PURE__ */ new Vector3();\n  const _quaternion$2 = /* @__PURE__ */ new Quaternion();\n  const _xAxis = /* @__PURE__ */ new Vector3(1, 0, 0);\n  const _yAxis = /* @__PURE__ */ new Vector3(0, 1, 0);\n  const _zAxis = /* @__PURE__ */ new Vector3(0, 0, 1);\n  const _addedEvent = { type: "added" };\n  const _removedEvent = { type: "removed" };\n  const _childaddedEvent = { type: "childadded", child: null };\n  const _childremovedEvent = { type: "childremoved", child: null };\n  class Object3D extends EventDispatcher {\n    constructor() {\n      super();\n      this.isObject3D = true;\n      Object.defineProperty(this, "id", { value: _object3DId++ });\n      this.uuid = generateUUID();\n      this.name = "";\n      this.type = "Object3D";\n      this.parent = null;\n      this.children = [];\n      this.up = Object3D.DEFAULT_UP.clone();\n      const position = new Vector3();\n      const rotation = new Euler();\n      const quaternion = new Quaternion();\n      const scale = new Vector3(1, 1, 1);\n      function onRotationChange() {\n        quaternion.setFromEuler(rotation, false);\n      }\n      function onQuaternionChange() {\n        rotation.setFromQuaternion(quaternion, void 0, false);\n      }\n      rotation._onChange(onRotationChange);\n      quaternion._onChange(onQuaternionChange);\n      Object.defineProperties(this, {\n        position: {\n          configurable: true,\n          enumerable: true,\n          value: position\n        },\n        rotation: {\n          configurable: true,\n          enumerable: true,\n          value: rotation\n        },\n        quaternion: {\n          configurable: true,\n          enumerable: true,\n          value: quaternion\n        },\n        scale: {\n          configurable: true,\n          enumerable: true,\n          value: scale\n        },\n        modelViewMatrix: {\n          value: new Matrix4()\n        },\n        normalMatrix: {\n          value: new Matrix3()\n        }\n      });\n      this.matrix = new Matrix4();\n      this.matrixWorld = new Matrix4();\n      this.matrixAutoUpdate = Object3D.DEFAULT_MATRIX_AUTO_UPDATE;\n      this.matrixWorldAutoUpdate = Object3D.DEFAULT_MATRIX_WORLD_AUTO_UPDATE;\n      this.matrixWorldNeedsUpdate = false;\n      this.layers = new Layers();\n      this.visible = true;\n      this.castShadow = false;\n      this.receiveShadow = false;\n      this.frustumCulled = true;\n      this.renderOrder = 0;\n      this.animations = [];\n      this.userData = {};\n    }\n    onBeforeShadow() {\n    }\n    onAfterShadow() {\n    }\n    onBeforeRender() {\n    }\n    onAfterRender() {\n    }\n    applyMatrix4(matrix) {\n      if (this.matrixAutoUpdate) this.updateMatrix();\n      this.matrix.premultiply(matrix);\n      this.matrix.decompose(this.position, this.quaternion, this.scale);\n    }\n    applyQuaternion(q) {\n      this.quaternion.premultiply(q);\n      return this;\n    }\n    setRotationFromAxisAngle(axis, angle) {\n      this.quaternion.setFromAxisAngle(axis, angle);\n    }\n    setRotationFromEuler(euler) {\n      this.quaternion.setFromEuler(euler, true);\n    }\n    setRotationFromMatrix(m) {\n      this.quaternion.setFromRotationMatrix(m);\n    }\n    setRotationFromQuaternion(q) {\n      this.quaternion.copy(q);\n    }\n    rotateOnAxis(axis, angle) {\n      _q1.setFromAxisAngle(axis, angle);\n      this.quaternion.multiply(_q1);\n      return this;\n    }\n    rotateOnWorldAxis(axis, angle) {\n      _q1.setFromAxisAngle(axis, angle);\n      this.quaternion.premultiply(_q1);\n      return this;\n    }\n    rotateX(angle) {\n      return this.rotateOnAxis(_xAxis, angle);\n    }\n    rotateY(angle) {\n      return this.rotateOnAxis(_yAxis, angle);\n    }\n    rotateZ(angle) {\n      return this.rotateOnAxis(_zAxis, angle);\n    }\n    translateOnAxis(axis, distance) {\n      _v1$4.copy(axis).applyQuaternion(this.quaternion);\n      this.position.add(_v1$4.multiplyScalar(distance));\n      return this;\n    }\n    translateX(distance) {\n      return this.translateOnAxis(_xAxis, distance);\n    }\n    translateY(distance) {\n      return this.translateOnAxis(_yAxis, distance);\n    }\n    translateZ(distance) {\n      return this.translateOnAxis(_zAxis, distance);\n    }\n    localToWorld(vector) {\n      this.updateWorldMatrix(true, false);\n      return vector.applyMatrix4(this.matrixWorld);\n    }\n    worldToLocal(vector) {\n      this.updateWorldMatrix(true, false);\n      return vector.applyMatrix4(_m1$1.copy(this.matrixWorld).invert());\n    }\n    lookAt(x2, y, z) {\n      if (x2.isVector3) {\n        _target.copy(x2);\n      } else {\n        _target.set(x2, y, z);\n      }\n      const parent = this.parent;\n      this.updateWorldMatrix(true, false);\n      _position$3.setFromMatrixPosition(this.matrixWorld);\n      if (this.isCamera || this.isLight) {\n        _m1$1.lookAt(_position$3, _target, this.up);\n      } else {\n        _m1$1.lookAt(_target, _position$3, this.up);\n      }\n      this.quaternion.setFromRotationMatrix(_m1$1);\n      if (parent) {\n        _m1$1.extractRotation(parent.matrixWorld);\n        _q1.setFromRotationMatrix(_m1$1);\n        this.quaternion.premultiply(_q1.invert());\n      }\n    }\n    add(object) {\n      if (arguments.length > 1) {\n        for (let i2 = 0; i2 < arguments.length; i2++) {\n          this.add(arguments[i2]);\n        }\n        return this;\n      }\n      if (object === this) {\n        console.error("THREE.Object3D.add: object can\'t be added as a child of itself.", object);\n        return this;\n      }\n      if (object && object.isObject3D) {\n        object.removeFromParent();\n        object.parent = this;\n        this.children.push(object);\n        object.dispatchEvent(_addedEvent);\n        _childaddedEvent.child = object;\n        this.dispatchEvent(_childaddedEvent);\n        _childaddedEvent.child = null;\n      } else {\n        console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", object);\n      }\n      return this;\n    }\n    remove(object) {\n      if (arguments.length > 1) {\n        for (let i2 = 0; i2 < arguments.length; i2++) {\n          this.remove(arguments[i2]);\n        }\n        return this;\n      }\n      const index = this.children.indexOf(object);\n      if (index !== -1) {\n        object.parent = null;\n        this.children.splice(index, 1);\n        object.dispatchEvent(_removedEvent);\n        _childremovedEvent.child = object;\n        this.dispatchEvent(_childremovedEvent);\n        _childremovedEvent.child = null;\n      }\n      return this;\n    }\n    removeFromParent() {\n      const parent = this.parent;\n      if (parent !== null) {\n        parent.remove(this);\n      }\n      return this;\n    }\n    clear() {\n      return this.remove(...this.children);\n    }\n    attach(object) {\n      this.updateWorldMatrix(true, false);\n      _m1$1.copy(this.matrixWorld).invert();\n      if (object.parent !== null) {\n        object.parent.updateWorldMatrix(true, false);\n        _m1$1.multiply(object.parent.matrixWorld);\n      }\n      object.applyMatrix4(_m1$1);\n      object.removeFromParent();\n      object.parent = this;\n      this.children.push(object);\n      object.updateWorldMatrix(false, true);\n      object.dispatchEvent(_addedEvent);\n      _childaddedEvent.child = object;\n      this.dispatchEvent(_childaddedEvent);\n      _childaddedEvent.child = null;\n      return this;\n    }\n    getObjectById(id) {\n      return this.getObjectByProperty("id", id);\n    }\n    getObjectByName(name) {\n      return this.getObjectByProperty("name", name);\n    }\n    getObjectByProperty(name, value) {\n      if (this[name] === value) return this;\n      for (let i2 = 0, l = this.children.length; i2 < l; i2++) {\n        const child = this.children[i2];\n        const object = child.getObjectByProperty(name, value);\n        if (object !== void 0) {\n          return object;\n        }\n      }\n      return void 0;\n    }\n    getObjectsByProperty(name, value, result = []) {\n      if (this[name] === value) result.push(this);\n      const children = this.children;\n      for (let i2 = 0, l = children.length; i2 < l; i2++) {\n        children[i2].getObjectsByProperty(name, value, result);\n      }\n      return result;\n    }\n    getWorldPosition(target) {\n      this.updateWorldMatrix(true, false);\n      return target.setFromMatrixPosition(this.matrixWorld);\n    }\n    getWorldQuaternion(target) {\n      this.updateWorldMatrix(true, false);\n      this.matrixWorld.decompose(_position$3, target, _scale$2);\n      return target;\n    }\n    getWorldScale(target) {\n      this.updateWorldMatrix(true, false);\n      this.matrixWorld.decompose(_position$3, _quaternion$2, target);\n      return target;\n    }\n    getWorldDirection(target) {\n      this.updateWorldMatrix(true, false);\n      const e = this.matrixWorld.elements;\n      return target.set(e[8], e[9], e[10]).normalize();\n    }\n    raycast() {\n    }\n    traverse(callback) {\n      callback(this);\n      const children = this.children;\n      for (let i2 = 0, l = children.length; i2 < l; i2++) {\n        children[i2].traverse(callback);\n      }\n    }\n    traverseVisible(callback) {\n      if (this.visible === false) return;\n      callback(this);\n      const children = this.children;\n      for (let i2 = 0, l = children.length; i2 < l; i2++) {\n        children[i2].traverseVisible(callback);\n      }\n    }\n    traverseAncestors(callback) {\n      const parent = this.parent;\n      if (parent !== null) {\n        callback(parent);\n        parent.traverseAncestors(callback);\n      }\n    }\n    updateMatrix() {\n      this.matrix.compose(this.position, this.quaternion, this.scale);\n      this.matrixWorldNeedsUpdate = true;\n    }\n    updateMatrixWorld(force) {\n      if (this.matrixAutoUpdate) this.updateMatrix();\n      if (this.matrixWorldNeedsUpdate || force) {\n        if (this.matrixWorldAutoUpdate === true) {\n          if (this.parent === null) {\n            this.matrixWorld.copy(this.matrix);\n          } else {\n            this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix);\n          }\n        }\n        this.matrixWorldNeedsUpdate = false;\n        force = true;\n      }\n      const children = this.children;\n      for (let i2 = 0, l = children.length; i2 < l; i2++) {\n        const child = children[i2];\n        child.updateMatrixWorld(force);\n      }\n    }\n    updateWorldMatrix(updateParents, updateChildren) {\n      const parent = this.parent;\n      if (updateParents === true && parent !== null) {\n        parent.updateWorldMatrix(true, false);\n      }\n      if (this.matrixAutoUpdate) this.updateMatrix();\n      if (this.matrixWorldAutoUpdate === true) {\n        if (this.parent === null) {\n          this.matrixWorld.copy(this.matrix);\n        } else {\n          this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix);\n        }\n      }\n      if (updateChildren === true) {\n        const children = this.children;\n        for (let i2 = 0, l = children.length; i2 < l; i2++) {\n          const child = children[i2];\n          child.updateWorldMatrix(false, true);\n        }\n      }\n    }\n    toJSON(meta) {\n      const isRootObject = meta === void 0 || typeof meta === "string";\n      const output = {};\n      if (isRootObject) {\n        meta = {\n          geometries: {},\n          materials: {},\n          textures: {},\n          images: {},\n          shapes: {},\n          skeletons: {},\n          animations: {},\n          nodes: {}\n        };\n        output.metadata = {\n          version: 4.6,\n          type: "Object",\n          generator: "Object3D.toJSON"\n        };\n      }\n      const object = {};\n      object.uuid = this.uuid;\n      object.type = this.type;\n      if (this.name !== "") object.name = this.name;\n      if (this.castShadow === true) object.castShadow = true;\n      if (this.receiveShadow === true) object.receiveShadow = true;\n      if (this.visible === false) object.visible = false;\n      if (this.frustumCulled === false) object.frustumCulled = false;\n      if (this.renderOrder !== 0) object.renderOrder = this.renderOrder;\n      if (Object.keys(this.userData).length > 0) object.userData = this.userData;\n      object.layers = this.layers.mask;\n      object.matrix = this.matrix.toArray();\n      object.up = this.up.toArray();\n      if (this.matrixAutoUpdate === false) object.matrixAutoUpdate = false;\n      if (this.isInstancedMesh) {\n        object.type = "InstancedMesh";\n        object.count = this.count;\n        object.instanceMatrix = this.instanceMatrix.toJSON();\n        if (this.instanceColor !== null) object.instanceColor = this.instanceColor.toJSON();\n      }\n      if (this.isBatchedMesh) {\n        object.type = "BatchedMesh";\n        object.perObjectFrustumCulled = this.perObjectFrustumCulled;\n        object.sortObjects = this.sortObjects;\n        object.drawRanges = this._drawRanges;\n        object.reservedRanges = this._reservedRanges;\n        object.visibility = this._visibility;\n        object.active = this._active;\n        object.bounds = this._bounds.map((bound) => ({\n          boxInitialized: bound.boxInitialized,\n          boxMin: bound.box.min.toArray(),\n          boxMax: bound.box.max.toArray(),\n          sphereInitialized: bound.sphereInitialized,\n          sphereRadius: bound.sphere.radius,\n          sphereCenter: bound.sphere.center.toArray()\n        }));\n        object.maxInstanceCount = this._maxInstanceCount;\n        object.maxVertexCount = this._maxVertexCount;\n        object.maxIndexCount = this._maxIndexCount;\n        object.geometryInitialized = this._geometryInitialized;\n        object.geometryCount = this._geometryCount;\n        object.matricesTexture = this._matricesTexture.toJSON(meta);\n        if (this._colorsTexture !== null) object.colorsTexture = this._colorsTexture.toJSON(meta);\n        if (this.boundingSphere !== null) {\n          object.boundingSphere = {\n            center: object.boundingSphere.center.toArray(),\n            radius: object.boundingSphere.radius\n          };\n        }\n        if (this.boundingBox !== null) {\n          object.boundingBox = {\n            min: object.boundingBox.min.toArray(),\n            max: object.boundingBox.max.toArray()\n          };\n        }\n      }\n      function serialize(library, element) {\n        if (library[element.uuid] === void 0) {\n          library[element.uuid] = element.toJSON(meta);\n        }\n        return element.uuid;\n      }\n      if (this.isScene) {\n        if (this.background) {\n          if (this.background.isColor) {\n            object.background = this.background.toJSON();\n          } else if (this.background.isTexture) {\n            object.background = this.background.toJSON(meta).uuid;\n          }\n        }\n        if (this.environment && this.environment.isTexture && this.environment.isRenderTargetTexture !== true) {\n          object.environment = this.environment.toJSON(meta).uuid;\n        }\n      } else if (this.isMesh || this.isLine || this.isPoints) {\n        object.geometry = serialize(meta.geometries, this.geometry);\n        const parameters = this.geometry.parameters;\n        if (parameters !== void 0 && parameters.shapes !== void 0) {\n          const shapes = parameters.shapes;\n          if (Array.isArray(shapes)) {\n            for (let i2 = 0, l = shapes.length; i2 < l; i2++) {\n              const shape = shapes[i2];\n              serialize(meta.shapes, shape);\n            }\n          } else {\n            serialize(meta.shapes, shapes);\n          }\n        }\n      }\n      if (this.isSkinnedMesh) {\n        object.bindMode = this.bindMode;\n        object.bindMatrix = this.bindMatrix.toArray();\n        if (this.skeleton !== void 0) {\n          serialize(meta.skeletons, this.skeleton);\n          object.skeleton = this.skeleton.uuid;\n        }\n      }\n      if (this.material !== void 0) {\n        if (Array.isArray(this.material)) {\n          const uuids = [];\n          for (let i2 = 0, l = this.material.length; i2 < l; i2++) {\n            uuids.push(serialize(meta.materials, this.material[i2]));\n          }\n          object.material = uuids;\n        } else {\n          object.material = serialize(meta.materials, this.material);\n        }\n      }\n      if (this.children.length > 0) {\n        object.children = [];\n        for (let i2 = 0; i2 < this.children.length; i2++) {\n          object.children.push(this.children[i2].toJSON(meta).object);\n        }\n      }\n      if (this.animations.length > 0) {\n        object.animations = [];\n        for (let i2 = 0; i2 < this.animations.length; i2++) {\n          const animation = this.animations[i2];\n          object.animations.push(serialize(meta.animations, animation));\n        }\n      }\n      if (isRootObject) {\n        const geometries = extractFromCache(meta.geometries);\n        const materials = extractFromCache(meta.materials);\n        const textures = extractFromCache(meta.textures);\n        const images = extractFromCache(meta.images);\n        const shapes = extractFromCache(meta.shapes);\n        const skeletons = extractFromCache(meta.skeletons);\n        const animations = extractFromCache(meta.animations);\n        const nodes = extractFromCache(meta.nodes);\n        if (geometries.length > 0) output.geometries = geometries;\n        if (materials.length > 0) output.materials = materials;\n        if (textures.length > 0) output.textures = textures;\n        if (images.length > 0) output.images = images;\n        if (shapes.length > 0) output.shapes = shapes;\n        if (skeletons.length > 0) output.skeletons = skeletons;\n        if (animations.length > 0) output.animations = animations;\n        if (nodes.length > 0) output.nodes = nodes;\n      }\n      output.object = object;\n      return output;\n      function extractFromCache(cache) {\n        const values = [];\n        for (const key in cache) {\n          const data = cache[key];\n          delete data.metadata;\n          values.push(data);\n        }\n        return values;\n      }\n    }\n    clone(recursive) {\n      return new this.constructor().copy(this, recursive);\n    }\n    copy(source, recursive = true) {\n      this.name = source.name;\n      this.up.copy(source.up);\n      this.position.copy(source.position);\n      this.rotation.order = source.rotation.order;\n      this.quaternion.copy(source.quaternion);\n      this.scale.copy(source.scale);\n      this.matrix.copy(source.matrix);\n      this.matrixWorld.copy(source.matrixWorld);\n      this.matrixAutoUpdate = source.matrixAutoUpdate;\n      this.matrixWorldAutoUpdate = source.matrixWorldAutoUpdate;\n      this.matrixWorldNeedsUpdate = source.matrixWorldNeedsUpdate;\n      this.layers.mask = source.layers.mask;\n      this.visible = source.visible;\n      this.castShadow = source.castShadow;\n      this.receiveShadow = source.receiveShadow;\n      this.frustumCulled = source.frustumCulled;\n      this.renderOrder = source.renderOrder;\n      this.animations = source.animations.slice();\n      this.userData = JSON.parse(JSON.stringify(source.userData));\n      if (recursive === true) {\n        for (let i2 = 0; i2 < source.children.length; i2++) {\n          const child = source.children[i2];\n          this.add(child.clone());\n        }\n      }\n      return this;\n    }\n  }\n  Object3D.DEFAULT_UP = /* @__PURE__ */ new Vector3(0, 1, 0);\n  Object3D.DEFAULT_MATRIX_AUTO_UPDATE = true;\n  Object3D.DEFAULT_MATRIX_WORLD_AUTO_UPDATE = true;\n  const _v0$1 = /* @__PURE__ */ new Vector3();\n  const _v1$3 = /* @__PURE__ */ new Vector3();\n  const _v2$2 = /* @__PURE__ */ new Vector3();\n  const _v3$2 = /* @__PURE__ */ new Vector3();\n  const _vab = /* @__PURE__ */ new Vector3();\n  const _vac = /* @__PURE__ */ new Vector3();\n  const _vbc = /* @__PURE__ */ new Vector3();\n  const _vap = /* @__PURE__ */ new Vector3();\n  const _vbp = /* @__PURE__ */ new Vector3();\n  const _vcp = /* @__PURE__ */ new Vector3();\n  const _v40 = /* @__PURE__ */ new Vector4();\n  const _v41 = /* @__PURE__ */ new Vector4();\n  const _v42 = /* @__PURE__ */ new Vector4();\n  class Triangle {\n    constructor(a = new Vector3(), b = new Vector3(), c = new Vector3()) {\n      this.a = a;\n      this.b = b;\n      this.c = c;\n    }\n    static getNormal(a, b, c, target) {\n      target.subVectors(c, b);\n      _v0$1.subVectors(a, b);\n      target.cross(_v0$1);\n      const targetLengthSq = target.lengthSq();\n      if (targetLengthSq > 0) {\n        return target.multiplyScalar(1 / Math.sqrt(targetLengthSq));\n      }\n      return target.set(0, 0, 0);\n    }\n    // static/instance method to calculate barycentric coordinates\n    // based on: http://www.blackpawn.com/texts/pointinpoly/default.html\n    static getBarycoord(point, a, b, c, target) {\n      _v0$1.subVectors(c, a);\n      _v1$3.subVectors(b, a);\n      _v2$2.subVectors(point, a);\n      const dot00 = _v0$1.dot(_v0$1);\n      const dot01 = _v0$1.dot(_v1$3);\n      const dot02 = _v0$1.dot(_v2$2);\n      const dot11 = _v1$3.dot(_v1$3);\n      const dot12 = _v1$3.dot(_v2$2);\n      const denom = dot00 * dot11 - dot01 * dot01;\n      if (denom === 0) {\n        target.set(0, 0, 0);\n        return null;\n      }\n      const invDenom = 1 / denom;\n      const u = (dot11 * dot02 - dot01 * dot12) * invDenom;\n      const v = (dot00 * dot12 - dot01 * dot02) * invDenom;\n      return target.set(1 - u - v, v, u);\n    }\n    static containsPoint(point, a, b, c) {\n      if (this.getBarycoord(point, a, b, c, _v3$2) === null) {\n        return false;\n      }\n      return _v3$2.x >= 0 && _v3$2.y >= 0 && _v3$2.x + _v3$2.y <= 1;\n    }\n    static getInterpolation(point, p1, p2, p3, v1, v2, v3, target) {\n      if (this.getBarycoord(point, p1, p2, p3, _v3$2) === null) {\n        target.x = 0;\n        target.y = 0;\n        if ("z" in target) target.z = 0;\n        if ("w" in target) target.w = 0;\n        return null;\n      }\n      target.setScalar(0);\n      target.addScaledVector(v1, _v3$2.x);\n      target.addScaledVector(v2, _v3$2.y);\n      target.addScaledVector(v3, _v3$2.z);\n      return target;\n    }\n    static getInterpolatedAttribute(attr, i1, i2, i3, barycoord, target) {\n      _v40.setScalar(0);\n      _v41.setScalar(0);\n      _v42.setScalar(0);\n      _v40.fromBufferAttribute(attr, i1);\n      _v41.fromBufferAttribute(attr, i2);\n      _v42.fromBufferAttribute(attr, i3);\n      target.setScalar(0);\n      target.addScaledVector(_v40, barycoord.x);\n      target.addScaledVector(_v41, barycoord.y);\n      target.addScaledVector(_v42, barycoord.z);\n      return target;\n    }\n    static isFrontFacing(a, b, c, direction) {\n      _v0$1.subVectors(c, b);\n      _v1$3.subVectors(a, b);\n      return _v0$1.cross(_v1$3).dot(direction) < 0 ? true : false;\n    }\n    set(a, b, c) {\n      this.a.copy(a);\n      this.b.copy(b);\n      this.c.copy(c);\n      return this;\n    }\n    setFromPointsAndIndices(points, i0, i1, i2) {\n      this.a.copy(points[i0]);\n      this.b.copy(points[i1]);\n      this.c.copy(points[i2]);\n      return this;\n    }\n    setFromAttributeAndIndices(attribute, i0, i1, i2) {\n      this.a.fromBufferAttribute(attribute, i0);\n      this.b.fromBufferAttribute(attribute, i1);\n      this.c.fromBufferAttribute(attribute, i2);\n      return this;\n    }\n    clone() {\n      return new this.constructor().copy(this);\n    }\n    copy(triangle) {\n      this.a.copy(triangle.a);\n      this.b.copy(triangle.b);\n      this.c.copy(triangle.c);\n      return this;\n    }\n    getArea() {\n      _v0$1.subVectors(this.c, this.b);\n      _v1$3.subVectors(this.a, this.b);\n      return _v0$1.cross(_v1$3).length() * 0.5;\n    }\n    getMidpoint(target) {\n      return target.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3);\n    }\n    getNormal(target) {\n      return Triangle.getNormal(this.a, this.b, this.c, target);\n    }\n    getPlane(target) {\n      return target.setFromCoplanarPoints(this.a, this.b, this.c);\n    }\n    getBarycoord(point, target) {\n      return Triangle.getBarycoord(point, this.a, this.b, this.c, target);\n    }\n    getInterpolation(point, v1, v2, v3, target) {\n      return Triangle.getInterpolation(point, this.a, this.b, this.c, v1, v2, v3, target);\n    }\n    containsPoint(point) {\n      return Triangle.containsPoint(point, this.a, this.b, this.c);\n    }\n    isFrontFacing(direction) {\n      return Triangle.isFrontFacing(this.a, this.b, this.c, direction);\n    }\n    intersectsBox(box) {\n      return box.intersectsTriangle(this);\n    }\n    closestPointToPoint(p, target) {\n      const a = this.a, b = this.b, c = this.c;\n      let v, w;\n      _vab.subVectors(b, a);\n      _vac.subVectors(c, a);\n      _vap.subVectors(p, a);\n      const d1 = _vab.dot(_vap);\n      const d2 = _vac.dot(_vap);\n      if (d1 <= 0 && d2 <= 0) {\n        return target.copy(a);\n      }\n      _vbp.subVectors(p, b);\n      const d3 = _vab.dot(_vbp);\n      const d4 = _vac.dot(_vbp);\n      if (d3 >= 0 && d4 <= d3) {\n        return target.copy(b);\n      }\n      const vc = d1 * d4 - d3 * d2;\n      if (vc <= 0 && d1 >= 0 && d3 <= 0) {\n        v = d1 / (d1 - d3);\n        return target.copy(a).addScaledVector(_vab, v);\n      }\n      _vcp.subVectors(p, c);\n      const d5 = _vab.dot(_vcp);\n      const d6 = _vac.dot(_vcp);\n      if (d6 >= 0 && d5 <= d6) {\n        return target.copy(c);\n      }\n      const vb = d5 * d2 - d1 * d6;\n      if (vb <= 0 && d2 >= 0 && d6 <= 0) {\n        w = d2 / (d2 - d6);\n        return target.copy(a).addScaledVector(_vac, w);\n      }\n      const va = d3 * d6 - d5 * d4;\n      if (va <= 0 && d4 - d3 >= 0 && d5 - d6 >= 0) {\n        _vbc.subVectors(c, b);\n        w = (d4 - d3) / (d4 - d3 + (d5 - d6));\n        return target.copy(b).addScaledVector(_vbc, w);\n      }\n      const denom = 1 / (va + vb + vc);\n      v = vb * denom;\n      w = vc * denom;\n      return target.copy(a).addScaledVector(_vab, v).addScaledVector(_vac, w);\n    }\n    equals(triangle) {\n      return triangle.a.equals(this.a) && triangle.b.equals(this.b) && triangle.c.equals(this.c);\n    }\n  }\n  const _colorKeywords = {\n    "aliceblue": 15792383,\n    "antiquewhite": 16444375,\n    "aqua": 65535,\n    "aquamarine": 8388564,\n    "azure": 15794175,\n    "beige": 16119260,\n    "bisque": 16770244,\n    "black": 0,\n    "blanchedalmond": 16772045,\n    "blue": 255,\n    "blueviolet": 9055202,\n    "brown": 10824234,\n    "burlywood": 14596231,\n    "cadetblue": 6266528,\n    "chartreuse": 8388352,\n    "chocolate": 13789470,\n    "coral": 16744272,\n    "cornflowerblue": 6591981,\n    "cornsilk": 16775388,\n    "crimson": 14423100,\n    "cyan": 65535,\n    "darkblue": 139,\n    "darkcyan": 35723,\n    "darkgoldenrod": 12092939,\n    "darkgray": 11119017,\n    "darkgreen": 25600,\n    "darkgrey": 11119017,\n    "darkkhaki": 12433259,\n    "darkmagenta": 9109643,\n    "darkolivegreen": 5597999,\n    "darkorange": 16747520,\n    "darkorchid": 10040012,\n    "darkred": 9109504,\n    "darksalmon": 15308410,\n    "darkseagreen": 9419919,\n    "darkslateblue": 4734347,\n    "darkslategray": 3100495,\n    "darkslategrey": 3100495,\n    "darkturquoise": 52945,\n    "darkviolet": 9699539,\n    "deeppink": 16716947,\n    "deepskyblue": 49151,\n    "dimgray": 6908265,\n    "dimgrey": 6908265,\n    "dodgerblue": 2003199,\n    "firebrick": 11674146,\n    "floralwhite": 16775920,\n    "forestgreen": 2263842,\n    "fuchsia": 16711935,\n    "gainsboro": 14474460,\n    "ghostwhite": 16316671,\n    "gold": 16766720,\n    "goldenrod": 14329120,\n    "gray": 8421504,\n    "green": 32768,\n    "greenyellow": 11403055,\n    "grey": 8421504,\n    "honeydew": 15794160,\n    "hotpink": 16738740,\n    "indianred": 13458524,\n    "indigo": 4915330,\n    "ivory": 16777200,\n    "khaki": 15787660,\n    "lavender": 15132410,\n    "lavenderblush": 16773365,\n    "lawngreen": 8190976,\n    "lemonchiffon": 16775885,\n    "lightblue": 11393254,\n    "lightcoral": 15761536,\n    "lightcyan": 14745599,\n    "lightgoldenrodyellow": 16448210,\n    "lightgray": 13882323,\n    "lightgreen": 9498256,\n    "lightgrey": 13882323,\n    "lightpink": 16758465,\n    "lightsalmon": 16752762,\n    "lightseagreen": 2142890,\n    "lightskyblue": 8900346,\n    "lightslategray": 7833753,\n    "lightslategrey": 7833753,\n    "lightsteelblue": 11584734,\n    "lightyellow": 16777184,\n    "lime": 65280,\n    "limegreen": 3329330,\n    "linen": 16445670,\n    "magenta": 16711935,\n    "maroon": 8388608,\n    "mediumaquamarine": 6737322,\n    "mediumblue": 205,\n    "mediumorchid": 12211667,\n    "mediumpurple": 9662683,\n    "mediumseagreen": 3978097,\n    "mediumslateblue": 8087790,\n    "mediumspringgreen": 64154,\n    "mediumturquoise": 4772300,\n    "mediumvioletred": 13047173,\n    "midnightblue": 1644912,\n    "mintcream": 16121850,\n    "mistyrose": 16770273,\n    "moccasin": 16770229,\n    "navajowhite": 16768685,\n    "navy": 128,\n    "oldlace": 16643558,\n    "olive": 8421376,\n    "olivedrab": 7048739,\n    "orange": 16753920,\n    "orangered": 16729344,\n    "orchid": 14315734,\n    "palegoldenrod": 15657130,\n    "palegreen": 10025880,\n    "paleturquoise": 11529966,\n    "palevioletred": 14381203,\n    "papayawhip": 16773077,\n    "peachpuff": 16767673,\n    "peru": 13468991,\n    "pink": 16761035,\n    "plum": 14524637,\n    "powderblue": 11591910,\n    "purple": 8388736,\n    "rebeccapurple": 6697881,\n    "red": 16711680,\n    "rosybrown": 12357519,\n    "royalblue": 4286945,\n    "saddlebrown": 9127187,\n    "salmon": 16416882,\n    "sandybrown": 16032864,\n    "seagreen": 3050327,\n    "seashell": 16774638,\n    "sienna": 10506797,\n    "silver": 12632256,\n    "skyblue": 8900331,\n    "slateblue": 6970061,\n    "slategray": 7372944,\n    "slategrey": 7372944,\n    "snow": 16775930,\n    "springgreen": 65407,\n    "steelblue": 4620980,\n    "tan": 13808780,\n    "teal": 32896,\n    "thistle": 14204888,\n    "tomato": 16737095,\n    "turquoise": 4251856,\n    "violet": 15631086,\n    "wheat": 16113331,\n    "white": 16777215,\n    "whitesmoke": 16119285,\n    "yellow": 16776960,\n    "yellowgreen": 10145074\n  };\n  const _hslA = { h: 0, s: 0, l: 0 };\n  const _hslB = { h: 0, s: 0, l: 0 };\n  function hue2rgb(p, q, t) {\n    if (t < 0) t += 1;\n    if (t > 1) t -= 1;\n    if (t < 1 / 6) return p + (q - p) * 6 * t;\n    if (t < 1 / 2) return q;\n    if (t < 2 / 3) return p + (q - p) * 6 * (2 / 3 - t);\n    return p;\n  }\n  class Color {\n    constructor(r, g, b) {\n      this.isColor = true;\n      this.r = 1;\n      this.g = 1;\n      this.b = 1;\n      return this.set(r, g, b);\n    }\n    set(r, g, b) {\n      if (g === void 0 && b === void 0) {\n        const value = r;\n        if (value && value.isColor) {\n          this.copy(value);\n        } else if (typeof value === "number") {\n          this.setHex(value);\n        } else if (typeof value === "string") {\n          this.setStyle(value);\n        }\n      } else {\n        this.setRGB(r, g, b);\n      }\n      return this;\n    }\n    setScalar(scalar) {\n      this.r = scalar;\n      this.g = scalar;\n      this.b = scalar;\n      return this;\n    }\n    setHex(hex, colorSpace = SRGBColorSpace) {\n      hex = Math.floor(hex);\n      this.r = (hex >> 16 & 255) / 255;\n      this.g = (hex >> 8 & 255) / 255;\n      this.b = (hex & 255) / 255;\n      ColorManagement.toWorkingColorSpace(this, colorSpace);\n      return this;\n    }\n    setRGB(r, g, b, colorSpace = ColorManagement.workingColorSpace) {\n      this.r = r;\n      this.g = g;\n      this.b = b;\n      ColorManagement.toWorkingColorSpace(this, colorSpace);\n      return this;\n    }\n    setHSL(h, s, l, colorSpace = ColorManagement.workingColorSpace) {\n      h = euclideanModulo(h, 1);\n      s = clamp(s, 0, 1);\n      l = clamp(l, 0, 1);\n      if (s === 0) {\n        this.r = this.g = this.b = l;\n      } else {\n        const p = l <= 0.5 ? l * (1 + s) : l + s - l * s;\n        const q = 2 * l - p;\n        this.r = hue2rgb(q, p, h + 1 / 3);\n        this.g = hue2rgb(q, p, h);\n        this.b = hue2rgb(q, p, h - 1 / 3);\n      }\n      ColorManagement.toWorkingColorSpace(this, colorSpace);\n      return this;\n    }\n    setStyle(style, colorSpace = SRGBColorSpace) {\n      function handleAlpha(string) {\n        if (string === void 0) return;\n        if (parseFloat(string) < 1) {\n          console.warn("THREE.Color: Alpha component of " + style + " will be ignored.");\n        }\n      }\n      let m;\n      if (m = /^(\\w+)\\(([^\\)]*)\\)/.exec(style)) {\n        let color;\n        const name = m[1];\n        const components = m[2];\n        switch (name) {\n          case "rgb":\n          case "rgba":\n            if (color = /^\\s*(\\d+)\\s*,\\s*(\\d+)\\s*,\\s*(\\d+)\\s*(?:,\\s*(\\d*\\.?\\d+)\\s*)?$/.exec(components)) {\n              handleAlpha(color[4]);\n              return this.setRGB(\n                Math.min(255, parseInt(color[1], 10)) / 255,\n                Math.min(255, parseInt(color[2], 10)) / 255,\n                Math.min(255, parseInt(color[3], 10)) / 255,\n                colorSpace\n              );\n            }\n            if (color = /^\\s*(\\d+)\\%\\s*,\\s*(\\d+)\\%\\s*,\\s*(\\d+)\\%\\s*(?:,\\s*(\\d*\\.?\\d+)\\s*)?$/.exec(components)) {\n              handleAlpha(color[4]);\n              return this.setRGB(\n                Math.min(100, parseInt(color[1], 10)) / 100,\n                Math.min(100, parseInt(color[2], 10)) / 100,\n                Math.min(100, parseInt(color[3], 10)) / 100,\n                colorSpace\n              );\n            }\n            break;\n          case "hsl":\n          case "hsla":\n            if (color = /^\\s*(\\d*\\.?\\d+)\\s*,\\s*(\\d*\\.?\\d+)\\%\\s*,\\s*(\\d*\\.?\\d+)\\%\\s*(?:,\\s*(\\d*\\.?\\d+)\\s*)?$/.exec(components)) {\n              handleAlpha(color[4]);\n              return this.setHSL(\n                parseFloat(color[1]) / 360,\n                parseFloat(color[2]) / 100,\n                parseFloat(color[3]) / 100,\n                colorSpace\n              );\n            }\n            break;\n          default:\n            console.warn("THREE.Color: Unknown color model " + style);\n        }\n      } else if (m = /^\\#([A-Fa-f\\d]+)$/.exec(style)) {\n        const hex = m[1];\n        const size = hex.length;\n        if (size === 3) {\n          return this.setRGB(\n            parseInt(hex.charAt(0), 16) / 15,\n            parseInt(hex.charAt(1), 16) / 15,\n            parseInt(hex.charAt(2), 16) / 15,\n            colorSpace\n          );\n        } else if (size === 6) {\n          return this.setHex(parseInt(hex, 16), colorSpace);\n        } else {\n          console.warn("THREE.Color: Invalid hex color " + style);\n        }\n      } else if (style && style.length > 0) {\n        return this.setColorName(style, colorSpace);\n      }\n      return this;\n    }\n    setColorName(style, colorSpace = SRGBColorSpace) {\n      const hex = _colorKeywords[style.toLowerCase()];\n      if (hex !== void 0) {\n        this.setHex(hex, colorSpace);\n      } else {\n        console.warn("THREE.Color: Unknown color " + style);\n      }\n      return this;\n    }\n    clone() {\n      return new this.constructor(this.r, this.g, this.b);\n    }\n    copy(color) {\n      this.r = color.r;\n      this.g = color.g;\n      this.b = color.b;\n      return this;\n    }\n    copySRGBToLinear(color) {\n      this.r = SRGBToLinear(color.r);\n      this.g = SRGBToLinear(color.g);\n      this.b = SRGBToLinear(color.b);\n      return this;\n    }\n    copyLinearToSRGB(color) {\n      this.r = LinearToSRGB(color.r);\n      this.g = LinearToSRGB(color.g);\n      this.b = LinearToSRGB(color.b);\n      return this;\n    }\n    convertSRGBToLinear() {\n      this.copySRGBToLinear(this);\n      return this;\n    }\n    convertLinearToSRGB() {\n      this.copyLinearToSRGB(this);\n      return this;\n    }\n    getHex(colorSpace = SRGBColorSpace) {\n      ColorManagement.fromWorkingColorSpace(_color.copy(this), colorSpace);\n      return Math.round(clamp(_color.r * 255, 0, 255)) * 65536 + Math.round(clamp(_color.g * 255, 0, 255)) * 256 + Math.round(clamp(_color.b * 255, 0, 255));\n    }\n    getHexString(colorSpace = SRGBColorSpace) {\n      return ("000000" + this.getHex(colorSpace).toString(16)).slice(-6);\n    }\n    getHSL(target, colorSpace = ColorManagement.workingColorSpace) {\n      ColorManagement.fromWorkingColorSpace(_color.copy(this), colorSpace);\n      const r = _color.r, g = _color.g, b = _color.b;\n      const max2 = Math.max(r, g, b);\n      const min = Math.min(r, g, b);\n      let hue, saturation;\n      const lightness = (min + max2) / 2;\n      if (min === max2) {\n        hue = 0;\n        saturation = 0;\n      } else {\n        const delta = max2 - min;\n        saturation = lightness <= 0.5 ? delta / (max2 + min) : delta / (2 - max2 - min);\n        switch (max2) {\n          case r:\n            hue = (g - b) / delta + (g < b ? 6 : 0);\n            break;\n          case g:\n            hue = (b - r) / delta + 2;\n            break;\n          case b:\n            hue = (r - g) / delta + 4;\n            break;\n        }\n        hue /= 6;\n      }\n      target.h = hue;\n      target.s = saturation;\n      target.l = lightness;\n      return target;\n    }\n    getRGB(target, colorSpace = ColorManagement.workingColorSpace) {\n      ColorManagement.fromWorkingColorSpace(_color.copy(this), colorSpace);\n      target.r = _color.r;\n      target.g = _color.g;\n      target.b = _color.b;\n      return target;\n    }\n    getStyle(colorSpace = SRGBColorSpace) {\n      ColorManagement.fromWorkingColorSpace(_color.copy(this), colorSpace);\n      const r = _color.r, g = _color.g, b = _color.b;\n      if (colorSpace !== SRGBColorSpace) {\n        return `color(${colorSpace} ${r.toFixed(3)} ${g.toFixed(3)} ${b.toFixed(3)})`;\n      }\n      return `rgb(${Math.round(r * 255)},${Math.round(g * 255)},${Math.round(b * 255)})`;\n    }\n    offsetHSL(h, s, l) {\n      this.getHSL(_hslA);\n      return this.setHSL(_hslA.h + h, _hslA.s + s, _hslA.l + l);\n    }\n    add(color) {\n      this.r += color.r;\n      this.g += color.g;\n      this.b += color.b;\n      return this;\n    }\n    addColors(color1, color2) {\n      this.r = color1.r + color2.r;\n      this.g = color1.g + color2.g;\n      this.b = color1.b + color2.b;\n      return this;\n    }\n    addScalar(s) {\n      this.r += s;\n      this.g += s;\n      this.b += s;\n      return this;\n    }\n    sub(color) {\n      this.r = Math.max(0, this.r - color.r);\n      this.g = Math.max(0, this.g - color.g);\n      this.b = Math.max(0, this.b - color.b);\n      return this;\n    }\n    multiply(color) {\n      this.r *= color.r;\n      this.g *= color.g;\n      this.b *= color.b;\n      return this;\n    }\n    multiplyScalar(s) {\n      this.r *= s;\n      this.g *= s;\n      this.b *= s;\n      return this;\n    }\n    lerp(color, alpha) {\n      this.r += (color.r - this.r) * alpha;\n      this.g += (color.g - this.g) * alpha;\n      this.b += (color.b - this.b) * alpha;\n      return this;\n    }\n    lerpColors(color1, color2, alpha) {\n      this.r = color1.r + (color2.r - color1.r) * alpha;\n      this.g = color1.g + (color2.g - color1.g) * alpha;\n      this.b = color1.b + (color2.b - color1.b) * alpha;\n      return this;\n    }\n    lerpHSL(color, alpha) {\n      this.getHSL(_hslA);\n      color.getHSL(_hslB);\n      const h = lerp(_hslA.h, _hslB.h, alpha);\n      const s = lerp(_hslA.s, _hslB.s, alpha);\n      const l = lerp(_hslA.l, _hslB.l, alpha);\n      this.setHSL(h, s, l);\n      return this;\n    }\n    setFromVector3(v) {\n      this.r = v.x;\n      this.g = v.y;\n      this.b = v.z;\n      return this;\n    }\n    applyMatrix3(m) {\n      const r = this.r, g = this.g, b = this.b;\n      const e = m.elements;\n      this.r = e[0] * r + e[3] * g + e[6] * b;\n      this.g = e[1] * r + e[4] * g + e[7] * b;\n      this.b = e[2] * r + e[5] * g + e[8] * b;\n      return this;\n    }\n    equals(c) {\n      return c.r === this.r && c.g === this.g && c.b === this.b;\n    }\n    fromArray(array, offset = 0) {\n      this.r = array[offset];\n      this.g = array[offset + 1];\n      this.b = array[offset + 2];\n      return this;\n    }\n    toArray(array = [], offset = 0) {\n      array[offset] = this.r;\n      array[offset + 1] = this.g;\n      array[offset + 2] = this.b;\n      return array;\n    }\n    fromBufferAttribute(attribute, index) {\n      this.r = attribute.getX(index);\n      this.g = attribute.getY(index);\n      this.b = attribute.getZ(index);\n      return this;\n    }\n    toJSON() {\n      return this.getHex();\n    }\n    *[Symbol.iterator]() {\n      yield this.r;\n      yield this.g;\n      yield this.b;\n    }\n  }\n  const _color = /* @__PURE__ */ new Color();\n  Color.NAMES = _colorKeywords;\n  let _materialId = 0;\n  class Material extends EventDispatcher {\n    constructor() {\n      super();\n      this.isMaterial = true;\n      Object.defineProperty(this, "id", { value: _materialId++ });\n      this.uuid = generateUUID();\n      this.name = "";\n      this.type = "Material";\n      this.blending = NormalBlending;\n      this.side = FrontSide;\n      this.vertexColors = false;\n      this.opacity = 1;\n      this.transparent = false;\n      this.alphaHash = false;\n      this.blendSrc = SrcAlphaFactor;\n      this.blendDst = OneMinusSrcAlphaFactor;\n      this.blendEquation = AddEquation;\n      this.blendSrcAlpha = null;\n      this.blendDstAlpha = null;\n      this.blendEquationAlpha = null;\n      this.blendColor = new Color(0, 0, 0);\n      this.blendAlpha = 0;\n      this.depthFunc = LessEqualDepth;\n      this.depthTest = true;\n      this.depthWrite = true;\n      this.stencilWriteMask = 255;\n      this.stencilFunc = AlwaysStencilFunc;\n      this.stencilRef = 0;\n      this.stencilFuncMask = 255;\n      this.stencilFail = KeepStencilOp;\n      this.stencilZFail = KeepStencilOp;\n      this.stencilZPass = KeepStencilOp;\n      this.stencilWrite = false;\n      this.clippingPlanes = null;\n      this.clipIntersection = false;\n      this.clipShadows = false;\n      this.shadowSide = null;\n      this.colorWrite = true;\n      this.precision = null;\n      this.polygonOffset = false;\n      this.polygonOffsetFactor = 0;\n      this.polygonOffsetUnits = 0;\n      this.dithering = false;\n      this.alphaToCoverage = false;\n      this.premultipliedAlpha = false;\n      this.forceSinglePass = false;\n      this.visible = true;\n      this.toneMapped = true;\n      this.userData = {};\n      this.version = 0;\n      this._alphaTest = 0;\n    }\n    get alphaTest() {\n      return this._alphaTest;\n    }\n    set alphaTest(value) {\n      if (this._alphaTest > 0 !== value > 0) {\n        this.version++;\n      }\n      this._alphaTest = value;\n    }\n    // onBeforeRender and onBeforeCompile only supported in WebGLRenderer\n    onBeforeRender() {\n    }\n    onBeforeCompile() {\n    }\n    customProgramCacheKey() {\n      return this.onBeforeCompile.toString();\n    }\n    setValues(values) {\n      if (values === void 0) return;\n      for (const key in values) {\n        const newValue = values[key];\n        if (newValue === void 0) {\n          console.warn(`THREE.Material: parameter \'${key}\' has value of undefined.`);\n          continue;\n        }\n        const currentValue = this[key];\n        if (currentValue === void 0) {\n          console.warn(`THREE.Material: \'${key}\' is not a property of THREE.${this.type}.`);\n          continue;\n        }\n        if (currentValue && currentValue.isColor) {\n          currentValue.set(newValue);\n        } else if (currentValue && currentValue.isVector3 && (newValue && newValue.isVector3)) {\n          currentValue.copy(newValue);\n        } else {\n          this[key] = newValue;\n        }\n      }\n    }\n    toJSON(meta) {\n      const isRootObject = meta === void 0 || typeof meta === "string";\n      if (isRootObject) {\n        meta = {\n          textures: {},\n          images: {}\n        };\n      }\n      const data = {\n        metadata: {\n          version: 4.6,\n          type: "Material",\n          generator: "Material.toJSON"\n        }\n      };\n      data.uuid = this.uuid;\n      data.type = this.type;\n      if (this.name !== "") data.name = this.name;\n      if (this.color && this.color.isColor) data.color = this.color.getHex();\n      if (this.roughness !== void 0) data.roughness = this.roughness;\n      if (this.metalness !== void 0) data.metalness = this.metalness;\n      if (this.sheen !== void 0) data.sheen = this.sheen;\n      if (this.sheenColor && this.sheenColor.isColor) data.sheenColor = this.sheenColor.getHex();\n      if (this.sheenRoughness !== void 0) data.sheenRoughness = this.sheenRoughness;\n      if (this.emissive && this.emissive.isColor) data.emissive = this.emissive.getHex();\n      if (this.emissiveIntensity !== void 0 && this.emissiveIntensity !== 1) data.emissiveIntensity = this.emissiveIntensity;\n      if (this.specular && this.specular.isColor) data.specular = this.specular.getHex();\n      if (this.specularIntensity !== void 0) data.specularIntensity = this.specularIntensity;\n      if (this.specularColor && this.specularColor.isColor) data.specularColor = this.specularColor.getHex();\n      if (this.shininess !== void 0) data.shininess = this.shininess;\n      if (this.clearcoat !== void 0) data.clearcoat = this.clearcoat;\n      if (this.clearcoatRoughness !== void 0) data.clearcoatRoughness = this.clearcoatRoughness;\n      if (this.clearcoatMap && this.clearcoatMap.isTexture) {\n        data.clearcoatMap = this.clearcoatMap.toJSON(meta).uuid;\n      }\n      if (this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture) {\n        data.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(meta).uuid;\n      }\n      if (this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture) {\n        data.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(meta).uuid;\n        data.clearcoatNormalScale = this.clearcoatNormalScale.toArray();\n      }\n      if (this.dispersion !== void 0) data.dispersion = this.dispersion;\n      if (this.iridescence !== void 0) data.iridescence = this.iridescence;\n      if (this.iridescenceIOR !== void 0) data.iridescenceIOR = this.iridescenceIOR;\n      if (this.iridescenceThicknessRange !== void 0) data.iridescenceThicknessRange = this.iridescenceThicknessRange;\n      if (this.iridescenceMap && this.iridescenceMap.isTexture) {\n        data.iridescenceMap = this.iridescenceMap.toJSON(meta).uuid;\n      }\n      if (this.iridescenceThicknessMap && this.iridescenceThicknessMap.isTexture) {\n        data.iridescenceThicknessMap = this.iridescenceThicknessMap.toJSON(meta).uuid;\n      }\n      if (this.anisotropy !== void 0) data.anisotropy = this.anisotropy;\n      if (this.anisotropyRotation !== void 0) data.anisotropyRotation = this.anisotropyRotation;\n      if (this.anisotropyMap && this.anisotropyMap.isTexture) {\n        data.anisotropyMap = this.anisotropyMap.toJSON(meta).uuid;\n      }\n      if (this.map && this.map.isTexture) data.map = this.map.toJSON(meta).uuid;\n      if (this.matcap && this.matcap.isTexture) data.matcap = this.matcap.toJSON(meta).uuid;\n      if (this.alphaMap && this.alphaMap.isTexture) data.alphaMap = this.alphaMap.toJSON(meta).uuid;\n      if (this.lightMap && this.lightMap.isTexture) {\n        data.lightMap = this.lightMap.toJSON(meta).uuid;\n        data.lightMapIntensity = this.lightMapIntensity;\n      }\n      if (this.aoMap && this.aoMap.isTexture) {\n        data.aoMap = this.aoMap.toJSON(meta).uuid;\n        data.aoMapIntensity = this.aoMapIntensity;\n      }\n      if (this.bumpMap && this.bumpMap.isTexture) {\n        data.bumpMap = this.bumpMap.toJSON(meta).uuid;\n        data.bumpScale = this.bumpScale;\n      }\n      if (this.normalMap && this.normalMap.isTexture) {\n        data.normalMap = this.normalMap.toJSON(meta).uuid;\n        data.normalMapType = this.normalMapType;\n        data.normalScale = this.normalScale.toArray();\n      }\n      if (this.displacementMap && this.displacementMap.isTexture) {\n        data.displacementMap = this.displacementMap.toJSON(meta).uuid;\n        data.displacementScale = this.displacementScale;\n        data.displacementBias = this.displacementBias;\n      }\n      if (this.roughnessMap && this.roughnessMap.isTexture) data.roughnessMap = this.roughnessMap.toJSON(meta).uuid;\n      if (this.metalnessMap && this.metalnessMap.isTexture) data.metalnessMap = this.metalnessMap.toJSON(meta).uuid;\n      if (this.emissiveMap && this.emissiveMap.isTexture) data.emissiveMap = this.emissiveMap.toJSON(meta).uuid;\n      if (this.specularMap && this.specularMap.isTexture) data.specularMap = this.specularMap.toJSON(meta).uuid;\n      if (this.specularIntensityMap && this.specularIntensityMap.isTexture) data.specularIntensityMap = this.specularIntensityMap.toJSON(meta).uuid;\n      if (this.specularColorMap && this.specularColorMap.isTexture) data.specularColorMap = this.specularColorMap.toJSON(meta).uuid;\n      if (this.envMap && this.envMap.isTexture) {\n        data.envMap = this.envMap.toJSON(meta).uuid;\n        if (this.combine !== void 0) data.combine = this.combine;\n      }\n      if (this.envMapRotation !== void 0) data.envMapRotation = this.envMapRotation.toArray();\n      if (this.envMapIntensity !== void 0) data.envMapIntensity = this.envMapIntensity;\n      if (this.reflectivity !== void 0) data.reflectivity = this.reflectivity;\n      if (this.refractionRatio !== void 0) data.refractionRatio = this.refractionRatio;\n      if (this.gradientMap && this.gradientMap.isTexture) {\n        data.gradientMap = this.gradientMap.toJSON(meta).uuid;\n      }\n      if (this.transmission !== void 0) data.transmission = this.transmission;\n      if (this.transmissionMap && this.transmissionMap.isTexture) data.transmissionMap = this.transmissionMap.toJSON(meta).uuid;\n      if (this.thickness !== void 0) data.thickness = this.thickness;\n      if (this.thicknessMap && this.thicknessMap.isTexture) data.thicknessMap = this.thicknessMap.toJSON(meta).uuid;\n      if (this.attenuationDistance !== void 0 && this.attenuationDistance !== Infinity) data.attenuationDistance = this.attenuationDistance;\n      if (this.attenuationColor !== void 0) data.attenuationColor = this.attenuationColor.getHex();\n      if (this.size !== void 0) data.size = this.size;\n      if (this.shadowSide !== null) data.shadowSide = this.shadowSide;\n      if (this.sizeAttenuation !== void 0) data.sizeAttenuation = this.sizeAttenuation;\n      if (this.blending !== NormalBlending) data.blending = this.blending;\n      if (this.side !== FrontSide) data.side = this.side;\n      if (this.vertexColors === true) data.vertexColors = true;\n      if (this.opacity < 1) data.opacity = this.opacity;\n      if (this.transparent === true) data.transparent = true;\n      if (this.blendSrc !== SrcAlphaFactor) data.blendSrc = this.blendSrc;\n      if (this.blendDst !== OneMinusSrcAlphaFactor) data.blendDst = this.blendDst;\n      if (this.blendEquation !== AddEquation) data.blendEquation = this.blendEquation;\n      if (this.blendSrcAlpha !== null) data.blendSrcAlpha = this.blendSrcAlpha;\n      if (this.blendDstAlpha !== null) data.blendDstAlpha = this.blendDstAlpha;\n      if (this.blendEquationAlpha !== null) data.blendEquationAlpha = this.blendEquationAlpha;\n      if (this.blendColor && this.blendColor.isColor) data.blendColor = this.blendColor.getHex();\n      if (this.blendAlpha !== 0) data.blendAlpha = this.blendAlpha;\n      if (this.depthFunc !== LessEqualDepth) data.depthFunc = this.depthFunc;\n      if (this.depthTest === false) data.depthTest = this.depthTest;\n      if (this.depthWrite === false) data.depthWrite = this.depthWrite;\n      if (this.colorWrite === false) data.colorWrite = this.colorWrite;\n      if (this.stencilWriteMask !== 255) data.stencilWriteMask = this.stencilWriteMask;\n      if (this.stencilFunc !== AlwaysStencilFunc) data.stencilFunc = this.stencilFunc;\n      if (this.stencilRef !== 0) data.stencilRef = this.stencilRef;\n      if (this.stencilFuncMask !== 255) data.stencilFuncMask = this.stencilFuncMask;\n      if (this.stencilFail !== KeepStencilOp) data.stencilFail = this.stencilFail;\n      if (this.stencilZFail !== KeepStencilOp) data.stencilZFail = this.stencilZFail;\n      if (this.stencilZPass !== KeepStencilOp) data.stencilZPass = this.stencilZPass;\n      if (this.stencilWrite === true) data.stencilWrite = this.stencilWrite;\n      if (this.rotation !== void 0 && this.rotation !== 0) data.rotation = this.rotation;\n      if (this.polygonOffset === true) data.polygonOffset = true;\n      if (this.polygonOffsetFactor !== 0) data.polygonOffsetFactor = this.polygonOffsetFactor;\n      if (this.polygonOffsetUnits !== 0) data.polygonOffsetUnits = this.polygonOffsetUnits;\n      if (this.linewidth !== void 0 && this.linewidth !== 1) data.linewidth = this.linewidth;\n      if (this.dashSize !== void 0) data.dashSize = this.dashSize;\n      if (this.gapSize !== void 0) data.gapSize = this.gapSize;\n      if (this.scale !== void 0) data.scale = this.scale;\n      if (this.dithering === true) data.dithering = true;\n      if (this.alphaTest > 0) data.alphaTest = this.alphaTest;\n      if (this.alphaHash === true) data.alphaHash = true;\n      if (this.alphaToCoverage === true) data.alphaToCoverage = true;\n      if (this.premultipliedAlpha === true) data.premultipliedAlpha = true;\n      if (this.forceSinglePass === true) data.forceSinglePass = true;\n      if (this.wireframe === true) data.wireframe = true;\n      if (this.wireframeLinewidth > 1) data.wireframeLinewidth = this.wireframeLinewidth;\n      if (this.wireframeLinecap !== "round") data.wireframeLinecap = this.wireframeLinecap;\n      if (this.wireframeLinejoin !== "round") data.wireframeLinejoin = this.wireframeLinejoin;\n      if (this.flatShading === true) data.flatShading = true;\n      if (this.visible === false) data.visible = false;\n      if (this.toneMapped === false) data.toneMapped = false;\n      if (this.fog === false) data.fog = false;\n      if (Object.keys(this.userData).length > 0) data.userData = this.userData;\n      function extractFromCache(cache) {\n        const values = [];\n        for (const key in cache) {\n          const data2 = cache[key];\n          delete data2.metadata;\n          values.push(data2);\n        }\n        return values;\n      }\n      if (isRootObject) {\n        const textures = extractFromCache(meta.textures);\n        const images = extractFromCache(meta.images);\n        if (textures.length > 0) data.textures = textures;\n        if (images.length > 0) data.images = images;\n      }\n      return data;\n    }\n    clone() {\n      return new this.constructor().copy(this);\n    }\n    copy(source) {\n      this.name = source.name;\n      this.blending = source.blending;\n      this.side = source.side;\n      this.vertexColors = source.vertexColors;\n      this.opacity = source.opacity;\n      this.transparent = source.transparent;\n      this.blendSrc = source.blendSrc;\n      this.blendDst = source.blendDst;\n      this.blendEquation = source.blendEquation;\n      this.blendSrcAlpha = source.blendSrcAlpha;\n      this.blendDstAlpha = source.blendDstAlpha;\n      this.blendEquationAlpha = source.blendEquationAlpha;\n      this.blendColor.copy(source.blendColor);\n      this.blendAlpha = source.blendAlpha;\n      this.depthFunc = source.depthFunc;\n      this.depthTest = source.depthTest;\n      this.depthWrite = source.depthWrite;\n      this.stencilWriteMask = source.stencilWriteMask;\n      this.stencilFunc = source.stencilFunc;\n      this.stencilRef = source.stencilRef;\n      this.stencilFuncMask = source.stencilFuncMask;\n      this.stencilFail = source.stencilFail;\n      this.stencilZFail = source.stencilZFail;\n      this.stencilZPass = source.stencilZPass;\n      this.stencilWrite = source.stencilWrite;\n      const srcPlanes = source.clippingPlanes;\n      let dstPlanes = null;\n      if (srcPlanes !== null) {\n        const n = srcPlanes.length;\n        dstPlanes = new Array(n);\n        for (let i2 = 0; i2 !== n; ++i2) {\n          dstPlanes[i2] = srcPlanes[i2].clone();\n        }\n      }\n      this.clippingPlanes = dstPlanes;\n      this.clipIntersection = source.clipIntersection;\n      this.clipShadows = source.clipShadows;\n      this.shadowSide = source.shadowSide;\n      this.colorWrite = source.colorWrite;\n      this.precision = source.precision;\n      this.polygonOffset = source.polygonOffset;\n      this.polygonOffsetFactor = source.polygonOffsetFactor;\n      this.polygonOffsetUnits = source.polygonOffsetUnits;\n      this.dithering = source.dithering;\n      this.alphaTest = source.alphaTest;\n      this.alphaHash = source.alphaHash;\n      this.alphaToCoverage = source.alphaToCoverage;\n      this.premultipliedAlpha = source.premultipliedAlpha;\n      this.forceSinglePass = source.forceSinglePass;\n      this.visible = source.visible;\n      this.toneMapped = source.toneMapped;\n      this.userData = JSON.parse(JSON.stringify(source.userData));\n      return this;\n    }\n    dispose() {\n      this.dispatchEvent({ type: "dispose" });\n    }\n    set needsUpdate(value) {\n      if (value === true) this.version++;\n    }\n    onBuild() {\n      console.warn("Material: onBuild() has been removed.");\n    }\n  }\n  class MeshBasicMaterial extends Material {\n    constructor(parameters) {\n      super();\n      this.isMeshBasicMaterial = true;\n      this.type = "MeshBasicMaterial";\n      this.color = new Color(16777215);\n      this.map = null;\n      this.lightMap = null;\n      this.lightMapIntensity = 1;\n      this.aoMap = null;\n      this.aoMapIntensity = 1;\n      this.specularMap = null;\n      this.alphaMap = null;\n      this.envMap = null;\n      this.envMapRotation = new Euler();\n      this.combine = MultiplyOperation;\n      this.reflectivity = 1;\n      this.refractionRatio = 0.98;\n      this.wireframe = false;\n      this.wireframeLinewidth = 1;\n      this.wireframeLinecap = "round";\n      this.wireframeLinejoin = "round";\n      this.fog = true;\n      this.setValues(parameters);\n    }\n    copy(source) {\n      super.copy(source);\n      this.color.copy(source.color);\n      this.map = source.map;\n      this.lightMap = source.lightMap;\n      this.lightMapIntensity = source.lightMapIntensity;\n      this.aoMap = source.aoMap;\n      this.aoMapIntensity = source.aoMapIntensity;\n      this.specularMap = source.specularMap;\n      this.alphaMap = source.alphaMap;\n      this.envMap = source.envMap;\n      this.envMapRotation.copy(source.envMapRotation);\n      this.combine = source.combine;\n      this.reflectivity = source.reflectivity;\n      this.refractionRatio = source.refractionRatio;\n      this.wireframe = source.wireframe;\n      this.wireframeLinewidth = source.wireframeLinewidth;\n      this.wireframeLinecap = source.wireframeLinecap;\n      this.wireframeLinejoin = source.wireframeLinejoin;\n      this.fog = source.fog;\n      return this;\n    }\n  }\n  const _vector$9 = /* @__PURE__ */ new Vector3();\n  const _vector2$1 = /* @__PURE__ */ new Vector2();\n  class BufferAttribute {\n    constructor(array, itemSize, normalized = false) {\n      if (Array.isArray(array)) {\n        throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");\n      }\n      this.isBufferAttribute = true;\n      this.name = "";\n      this.array = array;\n      this.itemSize = itemSize;\n      this.count = array !== void 0 ? array.length / itemSize : 0;\n      this.normalized = normalized;\n      this.usage = StaticDrawUsage;\n      this.updateRanges = [];\n      this.gpuType = FloatType;\n      this.version = 0;\n    }\n    onUploadCallback() {\n    }\n    set needsUpdate(value) {\n      if (value === true) this.version++;\n    }\n    setUsage(value) {\n      this.usage = value;\n      return this;\n    }\n    addUpdateRange(start, count) {\n      this.updateRanges.push({ start, count });\n    }\n    clearUpdateRanges() {\n      this.updateRanges.length = 0;\n    }\n    copy(source) {\n      this.name = source.name;\n      this.array = new source.array.constructor(source.array);\n      this.itemSize = source.itemSize;\n      this.count = source.count;\n      this.normalized = source.normalized;\n      this.usage = source.usage;\n      this.gpuType = source.gpuType;\n      return this;\n    }\n    copyAt(index1, attribute, index2) {\n      index1 *= this.itemSize;\n      index2 *= attribute.itemSize;\n      for (let i2 = 0, l = this.itemSize; i2 < l; i2++) {\n        this.array[index1 + i2] = attribute.array[index2 + i2];\n      }\n      return this;\n    }\n    copyArray(array) {\n      this.array.set(array);\n      return this;\n    }\n    applyMatrix3(m) {\n      if (this.itemSize === 2) {\n        for (let i2 = 0, l = this.count; i2 < l; i2++) {\n          _vector2$1.fromBufferAttribute(this, i2);\n          _vector2$1.applyMatrix3(m);\n          this.setXY(i2, _vector2$1.x, _vector2$1.y);\n        }\n      } else if (this.itemSize === 3) {\n        for (let i2 = 0, l = this.count; i2 < l; i2++) {\n          _vector$9.fromBufferAttribute(this, i2);\n          _vector$9.applyMatrix3(m);\n          this.setXYZ(i2, _vector$9.x, _vector$9.y, _vector$9.z);\n        }\n      }\n      return this;\n    }\n    applyMatrix4(m) {\n      for (let i2 = 0, l = this.count; i2 < l; i2++) {\n        _vector$9.fromBufferAttribute(this, i2);\n        _vector$9.applyMatrix4(m);\n        this.setXYZ(i2, _vector$9.x, _vector$9.y, _vector$9.z);\n      }\n      return this;\n    }\n    applyNormalMatrix(m) {\n      for (let i2 = 0, l = this.count; i2 < l; i2++) {\n        _vector$9.fromBufferAttribute(this, i2);\n        _vector$9.applyNormalMatrix(m);\n        this.setXYZ(i2, _vector$9.x, _vector$9.y, _vector$9.z);\n      }\n      return this;\n    }\n    transformDirection(m) {\n      for (let i2 = 0, l = this.count; i2 < l; i2++) {\n        _vector$9.fromBufferAttribute(this, i2);\n        _vector$9.transformDirection(m);\n        this.setXYZ(i2, _vector$9.x, _vector$9.y, _vector$9.z);\n      }\n      return this;\n    }\n    set(value, offset = 0) {\n      this.array.set(value, offset);\n      return this;\n    }\n    getComponent(index, component) {\n      let value = this.array[index * this.itemSize + component];\n      if (this.normalized) value = denormalize(value, this.array);\n      return value;\n    }\n    setComponent(index, component, value) {\n      if (this.normalized) value = normalize$1(value, this.array);\n      this.array[index * this.itemSize + component] = value;\n      return this;\n    }\n    getX(index) {\n      let x2 = this.array[index * this.itemSize];\n      if (this.normalized) x2 = denormalize(x2, this.array);\n      return x2;\n    }\n    setX(index, x2) {\n      if (this.normalized) x2 = normalize$1(x2, this.array);\n      this.array[index * this.itemSize] = x2;\n      return this;\n    }\n    getY(index) {\n      let y = this.array[index * this.itemSize + 1];\n      if (this.normalized) y = denormalize(y, this.array);\n      return y;\n    }\n    setY(index, y) {\n      if (this.normalized) y = normalize$1(y, this.array);\n      this.array[index * this.itemSize + 1] = y;\n      return this;\n    }\n    getZ(index) {\n      let z = this.array[index * this.itemSize + 2];\n      if (this.normalized) z = denormalize(z, this.array);\n      return z;\n    }\n    setZ(index, z) {\n      if (this.normalized) z = normalize$1(z, this.array);\n      this.array[index * this.itemSize + 2] = z;\n      return this;\n    }\n    getW(index) {\n      let w = this.array[index * this.itemSize + 3];\n      if (this.normalized) w = denormalize(w, this.array);\n      return w;\n    }\n    setW(index, w) {\n      if (this.normalized) w = normalize$1(w, this.array);\n      this.array[index * this.itemSize + 3] = w;\n      return this;\n    }\n    setXY(index, x2, y) {\n      index *= this.itemSize;\n      if (this.normalized) {\n        x2 = normalize$1(x2, this.array);\n        y = normalize$1(y, this.array);\n      }\n      this.array[index + 0] = x2;\n      this.array[index + 1] = y;\n      return this;\n    }\n    setXYZ(index, x2, y, z) {\n      index *= this.itemSize;\n      if (this.normalized) {\n        x2 = normalize$1(x2, this.array);\n        y = normalize$1(y, this.array);\n        z = normalize$1(z, this.array);\n      }\n      this.array[index + 0] = x2;\n      this.array[index + 1] = y;\n      this.array[index + 2] = z;\n      return this;\n    }\n    setXYZW(index, x2, y, z, w) {\n      index *= this.itemSize;\n      if (this.normalized) {\n        x2 = normalize$1(x2, this.array);\n        y = normalize$1(y, this.array);\n        z = normalize$1(z, this.array);\n        w = normalize$1(w, this.array);\n      }\n      this.array[index + 0] = x2;\n      this.array[index + 1] = y;\n      this.array[index + 2] = z;\n      this.array[index + 3] = w;\n      return this;\n    }\n    onUpload(callback) {\n      this.onUploadCallback = callback;\n      return this;\n    }\n    clone() {\n      return new this.constructor(this.array, this.itemSize).copy(this);\n    }\n    toJSON() {\n      const data = {\n        itemSize: this.itemSize,\n        type: this.array.constructor.name,\n        array: Array.from(this.array),\n        normalized: this.normalized\n      };\n      if (this.name !== "") data.name = this.name;\n      if (this.usage !== StaticDrawUsage) data.usage = this.usage;\n      return data;\n    }\n  }\n  class Uint16BufferAttribute extends BufferAttribute {\n    constructor(array, itemSize, normalized) {\n      super(new Uint16Array(array), itemSize, normalized);\n    }\n  }\n  class Uint32BufferAttribute extends BufferAttribute {\n    constructor(array, itemSize, normalized) {\n      super(new Uint32Array(array), itemSize, normalized);\n    }\n  }\n  class Float32BufferAttribute extends BufferAttribute {\n    constructor(array, itemSize, normalized) {\n      super(new Float32Array(array), itemSize, normalized);\n    }\n  }\n  let _id$1 = 0;\n  const _m1 = /* @__PURE__ */ new Matrix4();\n  const _obj = /* @__PURE__ */ new Object3D();\n  const _offset = /* @__PURE__ */ new Vector3();\n  const _box$2 = /* @__PURE__ */ new Box3();\n  const _boxMorphTargets = /* @__PURE__ */ new Box3();\n  const _vector$8 = /* @__PURE__ */ new Vector3();\n  class BufferGeometry extends EventDispatcher {\n    constructor() {\n      super();\n      this.isBufferGeometry = true;\n      Object.defineProperty(this, "id", { value: _id$1++ });\n      this.uuid = generateUUID();\n      this.name = "";\n      this.type = "BufferGeometry";\n      this.index = null;\n      this.indirect = null;\n      this.attributes = {};\n      this.morphAttributes = {};\n      this.morphTargetsRelative = false;\n      this.groups = [];\n      this.boundingBox = null;\n      this.boundingSphere = null;\n      this.drawRange = { start: 0, count: Infinity };\n      this.userData = {};\n    }\n    getIndex() {\n      return this.index;\n    }\n    setIndex(index) {\n      if (Array.isArray(index)) {\n        this.index = new (arrayNeedsUint32(index) ? Uint32BufferAttribute : Uint16BufferAttribute)(index, 1);\n      } else {\n        this.index = index;\n      }\n      return this;\n    }\n    setIndirect(indirect) {\n      this.indirect = indirect;\n      return this;\n    }\n    getIndirect() {\n      return this.indirect;\n    }\n    getAttribute(name) {\n      return this.attributes[name];\n    }\n    setAttribute(name, attribute) {\n      this.attributes[name] = attribute;\n      return this;\n    }\n    deleteAttribute(name) {\n      delete this.attributes[name];\n      return this;\n    }\n    hasAttribute(name) {\n      return this.attributes[name] !== void 0;\n    }\n    addGroup(start, count, materialIndex = 0) {\n      this.groups.push({\n        start,\n        count,\n        materialIndex\n      });\n    }\n    clearGroups() {\n      this.groups = [];\n    }\n    setDrawRange(start, count) {\n      this.drawRange.start = start;\n      this.drawRange.count = count;\n    }\n    applyMatrix4(matrix) {\n      const position = this.attributes.position;\n      if (position !== void 0) {\n        position.applyMatrix4(matrix);\n        position.needsUpdate = true;\n      }\n      const normal = this.attributes.normal;\n      if (normal !== void 0) {\n        const normalMatrix = new Matrix3().getNormalMatrix(matrix);\n        normal.applyNormalMatrix(normalMatrix);\n        normal.needsUpdate = true;\n      }\n      const tangent = this.attributes.tangent;\n      if (tangent !== void 0) {\n        tangent.transformDirection(matrix);\n        tangent.needsUpdate = true;\n      }\n      if (this.boundingBox !== null) {\n        this.computeBoundingBox();\n      }\n      if (this.boundingSphere !== null) {\n        this.computeBoundingSphere();\n      }\n      return this;\n    }\n    applyQuaternion(q) {\n      _m1.makeRotationFromQuaternion(q);\n      this.applyMatrix4(_m1);\n      return this;\n    }\n    rotateX(angle) {\n      _m1.makeRotationX(angle);\n      this.applyMatrix4(_m1);\n      return this;\n    }\n    rotateY(angle) {\n      _m1.makeRotationY(angle);\n      this.applyMatrix4(_m1);\n      return this;\n    }\n    rotateZ(angle) {\n      _m1.makeRotationZ(angle);\n      this.applyMatrix4(_m1);\n      return this;\n    }\n    translate(x2, y, z) {\n      _m1.makeTranslation(x2, y, z);\n      this.applyMatrix4(_m1);\n      return this;\n    }\n    scale(x2, y, z) {\n      _m1.makeScale(x2, y, z);\n      this.applyMatrix4(_m1);\n      return this;\n    }\n    lookAt(vector) {\n      _obj.lookAt(vector);\n      _obj.updateMatrix();\n      this.applyMatrix4(_obj.matrix);\n      return this;\n    }\n    center() {\n      this.computeBoundingBox();\n      this.boundingBox.getCenter(_offset).negate();\n      this.translate(_offset.x, _offset.y, _offset.z);\n      return this;\n    }\n    setFromPoints(points) {\n      const positionAttribute = this.getAttribute("position");\n      if (positionAttribute === void 0) {\n        const position = [];\n        for (let i2 = 0, l = points.length; i2 < l; i2++) {\n          const point = points[i2];\n          position.push(point.x, point.y, point.z || 0);\n        }\n        this.setAttribute("position", new Float32BufferAttribute(position, 3));\n      } else {\n        const l = Math.min(points.length, positionAttribute.count);\n        for (let i2 = 0; i2 < l; i2++) {\n          const point = points[i2];\n          positionAttribute.setXYZ(i2, point.x, point.y, point.z || 0);\n        }\n        if (points.length > positionAttribute.count) {\n          console.warn("THREE.BufferGeometry: Buffer size too small for points data. Use .dispose() and create a new geometry.");\n        }\n        positionAttribute.needsUpdate = true;\n      }\n      return this;\n    }\n    computeBoundingBox() {\n      if (this.boundingBox === null) {\n        this.boundingBox = new Box3();\n      }\n      const position = this.attributes.position;\n      const morphAttributesPosition = this.morphAttributes.position;\n      if (position && position.isGLBufferAttribute) {\n        console.error("THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box.", this);\n        this.boundingBox.set(\n          new Vector3(-Infinity, -Infinity, -Infinity),\n          new Vector3(Infinity, Infinity, Infinity)\n        );\n        return;\n      }\n      if (position !== void 0) {\n        this.boundingBox.setFromBufferAttribute(position);\n        if (morphAttributesPosition) {\n          for (let i2 = 0, il = morphAttributesPosition.length; i2 < il; i2++) {\n            const morphAttribute = morphAttributesPosition[i2];\n            _box$2.setFromBufferAttribute(morphAttribute);\n            if (this.morphTargetsRelative) {\n              _vector$8.addVectors(this.boundingBox.min, _box$2.min);\n              this.boundingBox.expandByPoint(_vector$8);\n              _vector$8.addVectors(this.boundingBox.max, _box$2.max);\n              this.boundingBox.expandByPoint(_vector$8);\n            } else {\n              this.boundingBox.expandByPoint(_box$2.min);\n              this.boundingBox.expandByPoint(_box$2.max);\n            }\n          }\n        }\n      } else {\n        this.boundingBox.makeEmpty();\n      }\n      if (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) {\n        console.error(\'THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.\', this);\n      }\n    }\n    computeBoundingSphere() {\n      if (this.boundingSphere === null) {\n        this.boundingSphere = new Sphere();\n      }\n      const position = this.attributes.position;\n      const morphAttributesPosition = this.morphAttributes.position;\n      if (position && position.isGLBufferAttribute) {\n        console.error("THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere.", this);\n        this.boundingSphere.set(new Vector3(), Infinity);\n        return;\n      }\n      if (position) {\n        const center = this.boundingSphere.center;\n        _box$2.setFromBufferAttribute(position);\n        if (morphAttributesPosition) {\n          for (let i2 = 0, il = morphAttributesPosition.length; i2 < il; i2++) {\n            const morphAttribute = morphAttributesPosition[i2];\n            _boxMorphTargets.setFromBufferAttribute(morphAttribute);\n            if (this.morphTargetsRelative) {\n              _vector$8.addVectors(_box$2.min, _boxMorphTargets.min);\n              _box$2.expandByPoint(_vector$8);\n              _vector$8.addVectors(_box$2.max, _boxMorphTargets.max);\n              _box$2.expandByPoint(_vector$8);\n            } else {\n              _box$2.expandByPoint(_boxMorphTargets.min);\n              _box$2.expandByPoint(_boxMorphTargets.max);\n            }\n          }\n        }\n        _box$2.getCenter(center);\n        let maxRadiusSq = 0;\n        for (let i2 = 0, il = position.count; i2 < il; i2++) {\n          _vector$8.fromBufferAttribute(position, i2);\n          maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(_vector$8));\n        }\n        if (morphAttributesPosition) {\n          for (let i2 = 0, il = morphAttributesPosition.length; i2 < il; i2++) {\n            const morphAttribute = morphAttributesPosition[i2];\n            const morphTargetsRelative = this.morphTargetsRelative;\n            for (let j = 0, jl = morphAttribute.count; j < jl; j++) {\n              _vector$8.fromBufferAttribute(morphAttribute, j);\n              if (morphTargetsRelative) {\n                _offset.fromBufferAttribute(position, j);\n                _vector$8.add(_offset);\n              }\n              maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(_vector$8));\n            }\n          }\n        }\n        this.boundingSphere.radius = Math.sqrt(maxRadiusSq);\n        if (isNaN(this.boundingSphere.radius)) {\n          console.error(\'THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.\', this);\n        }\n      }\n    }\n    computeTangents() {\n      const index = this.index;\n      const attributes = this.attributes;\n      if (index === null || attributes.position === void 0 || attributes.normal === void 0 || attributes.uv === void 0) {\n        console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");\n        return;\n      }\n      const positionAttribute = attributes.position;\n      const normalAttribute = attributes.normal;\n      const uvAttribute = attributes.uv;\n      if (this.hasAttribute("tangent") === false) {\n        this.setAttribute("tangent", new BufferAttribute(new Float32Array(4 * positionAttribute.count), 4));\n      }\n      const tangentAttribute = this.getAttribute("tangent");\n      const tan1 = [], tan2 = [];\n      for (let i2 = 0; i2 < positionAttribute.count; i2++) {\n        tan1[i2] = new Vector3();\n        tan2[i2] = new Vector3();\n      }\n      const vA = new Vector3(), vB = new Vector3(), vC = new Vector3(), uvA = new Vector2(), uvB = new Vector2(), uvC = new Vector2(), sdir = new Vector3(), tdir = new Vector3();\n      function handleTriangle(a, b, c) {\n        vA.fromBufferAttribute(positionAttribute, a);\n        vB.fromBufferAttribute(positionAttribute, b);\n        vC.fromBufferAttribute(positionAttribute, c);\n        uvA.fromBufferAttribute(uvAttribute, a);\n        uvB.fromBufferAttribute(uvAttribute, b);\n        uvC.fromBufferAttribute(uvAttribute, c);\n        vB.sub(vA);\n        vC.sub(vA);\n        uvB.sub(uvA);\n        uvC.sub(uvA);\n        const r = 1 / (uvB.x * uvC.y - uvC.x * uvB.y);\n        if (!isFinite(r)) return;\n        sdir.copy(vB).multiplyScalar(uvC.y).addScaledVector(vC, -uvB.y).multiplyScalar(r);\n        tdir.copy(vC).multiplyScalar(uvB.x).addScaledVector(vB, -uvC.x).multiplyScalar(r);\n        tan1[a].add(sdir);\n        tan1[b].add(sdir);\n        tan1[c].add(sdir);\n        tan2[a].add(tdir);\n        tan2[b].add(tdir);\n        tan2[c].add(tdir);\n      }\n      let groups = this.groups;\n      if (groups.length === 0) {\n        groups = [{\n          start: 0,\n          count: index.count\n        }];\n      }\n      for (let i2 = 0, il = groups.length; i2 < il; ++i2) {\n        const group = groups[i2];\n        const start = group.start;\n        const count = group.count;\n        for (let j = start, jl = start + count; j < jl; j += 3) {\n          handleTriangle(\n            index.getX(j + 0),\n            index.getX(j + 1),\n            index.getX(j + 2)\n          );\n        }\n      }\n      const tmp = new Vector3(), tmp2 = new Vector3();\n      const n = new Vector3(), n2 = new Vector3();\n      function handleVertex(v) {\n        n.fromBufferAttribute(normalAttribute, v);\n        n2.copy(n);\n        const t = tan1[v];\n        tmp.copy(t);\n        tmp.sub(n.multiplyScalar(n.dot(t))).normalize();\n        tmp2.crossVectors(n2, t);\n        const test = tmp2.dot(tan2[v]);\n        const w = test < 0 ? -1 : 1;\n        tangentAttribute.setXYZW(v, tmp.x, tmp.y, tmp.z, w);\n      }\n      for (let i2 = 0, il = groups.length; i2 < il; ++i2) {\n        const group = groups[i2];\n        const start = group.start;\n        const count = group.count;\n        for (let j = start, jl = start + count; j < jl; j += 3) {\n          handleVertex(index.getX(j + 0));\n          handleVertex(index.getX(j + 1));\n          handleVertex(index.getX(j + 2));\n        }\n      }\n    }\n    computeVertexNormals() {\n      const index = this.index;\n      const positionAttribute = this.getAttribute("position");\n      if (positionAttribute !== void 0) {\n        let normalAttribute = this.getAttribute("normal");\n        if (normalAttribute === void 0) {\n          normalAttribute = new BufferAttribute(new Float32Array(positionAttribute.count * 3), 3);\n          this.setAttribute("normal", normalAttribute);\n        } else {\n          for (let i2 = 0, il = normalAttribute.count; i2 < il; i2++) {\n            normalAttribute.setXYZ(i2, 0, 0, 0);\n          }\n        }\n        const pA = new Vector3(), pB = new Vector3(), pC = new Vector3();\n        const nA = new Vector3(), nB = new Vector3(), nC = new Vector3();\n        const cb = new Vector3(), ab = new Vector3();\n        if (index) {\n          for (let i2 = 0, il = index.count; i2 < il; i2 += 3) {\n            const vA = index.getX(i2 + 0);\n            const vB = index.getX(i2 + 1);\n            const vC = index.getX(i2 + 2);\n            pA.fromBufferAttribute(positionAttribute, vA);\n            pB.fromBufferAttribute(positionAttribute, vB);\n            pC.fromBufferAttribute(positionAttribute, vC);\n            cb.subVectors(pC, pB);\n            ab.subVectors(pA, pB);\n            cb.cross(ab);\n            nA.fromBufferAttribute(normalAttribute, vA);\n            nB.fromBufferAttribute(normalAttribute, vB);\n            nC.fromBufferAttribute(normalAttribute, vC);\n            nA.add(cb);\n            nB.add(cb);\n            nC.add(cb);\n            normalAttribute.setXYZ(vA, nA.x, nA.y, nA.z);\n            normalAttribute.setXYZ(vB, nB.x, nB.y, nB.z);\n            normalAttribute.setXYZ(vC, nC.x, nC.y, nC.z);\n          }\n        } else {\n          for (let i2 = 0, il = positionAttribute.count; i2 < il; i2 += 3) {\n            pA.fromBufferAttribute(positionAttribute, i2 + 0);\n            pB.fromBufferAttribute(positionAttribute, i2 + 1);\n            pC.fromBufferAttribute(positionAttribute, i2 + 2);\n            cb.subVectors(pC, pB);\n            ab.subVectors(pA, pB);\n            cb.cross(ab);\n            normalAttribute.setXYZ(i2 + 0, cb.x, cb.y, cb.z);\n            normalAttribute.setXYZ(i2 + 1, cb.x, cb.y, cb.z);\n            normalAttribute.setXYZ(i2 + 2, cb.x, cb.y, cb.z);\n          }\n        }\n        this.normalizeNormals();\n        normalAttribute.needsUpdate = true;\n      }\n    }\n    normalizeNormals() {\n      const normals = this.attributes.normal;\n      for (let i2 = 0, il = normals.count; i2 < il; i2++) {\n        _vector$8.fromBufferAttribute(normals, i2);\n        _vector$8.normalize();\n        normals.setXYZ(i2, _vector$8.x, _vector$8.y, _vector$8.z);\n      }\n    }\n    toNonIndexed() {\n      function convertBufferAttribute(attribute, indices2) {\n        const array = attribute.array;\n        const itemSize = attribute.itemSize;\n        const normalized = attribute.normalized;\n        const array2 = new array.constructor(indices2.length * itemSize);\n        let index = 0, index2 = 0;\n        for (let i2 = 0, l = indices2.length; i2 < l; i2++) {\n          if (attribute.isInterleavedBufferAttribute) {\n            index = indices2[i2] * attribute.data.stride + attribute.offset;\n          } else {\n            index = indices2[i2] * itemSize;\n          }\n          for (let j = 0; j < itemSize; j++) {\n            array2[index2++] = array[index++];\n          }\n        }\n        return new BufferAttribute(array2, itemSize, normalized);\n      }\n      if (this.index === null) {\n        console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed.");\n        return this;\n      }\n      const geometry2 = new BufferGeometry();\n      const indices = this.index.array;\n      const attributes = this.attributes;\n      for (const name in attributes) {\n        const attribute = attributes[name];\n        const newAttribute = convertBufferAttribute(attribute, indices);\n        geometry2.setAttribute(name, newAttribute);\n      }\n      const morphAttributes = this.morphAttributes;\n      for (const name in morphAttributes) {\n        const morphArray = [];\n        const morphAttribute = morphAttributes[name];\n        for (let i2 = 0, il = morphAttribute.length; i2 < il; i2++) {\n          const attribute = morphAttribute[i2];\n          const newAttribute = convertBufferAttribute(attribute, indices);\n          morphArray.push(newAttribute);\n        }\n        geometry2.morphAttributes[name] = morphArray;\n      }\n      geometry2.morphTargetsRelative = this.morphTargetsRelative;\n      const groups = this.groups;\n      for (let i2 = 0, l = groups.length; i2 < l; i2++) {\n        const group = groups[i2];\n        geometry2.addGroup(group.start, group.count, group.materialIndex);\n      }\n      return geometry2;\n    }\n    toJSON() {\n      const data = {\n        metadata: {\n          version: 4.6,\n          type: "BufferGeometry",\n          generator: "BufferGeometry.toJSON"\n        }\n      };\n      data.uuid = this.uuid;\n      data.type = this.type;\n      if (this.name !== "") data.name = this.name;\n      if (Object.keys(this.userData).length > 0) data.userData = this.userData;\n      if (this.parameters !== void 0) {\n        const parameters = this.parameters;\n        for (const key in parameters) {\n          if (parameters[key] !== void 0) data[key] = parameters[key];\n        }\n        return data;\n      }\n      data.data = { attributes: {} };\n      const index = this.index;\n      if (index !== null) {\n        data.data.index = {\n          type: index.array.constructor.name,\n          array: Array.prototype.slice.call(index.array)\n        };\n      }\n      const attributes = this.attributes;\n      for (const key in attributes) {\n        const attribute = attributes[key];\n        data.data.attributes[key] = attribute.toJSON(data.data);\n      }\n      const morphAttributes = {};\n      let hasMorphAttributes = false;\n      for (const key in this.morphAttributes) {\n        const attributeArray = this.morphAttributes[key];\n        const array = [];\n        for (let i2 = 0, il = attributeArray.length; i2 < il; i2++) {\n          const attribute = attributeArray[i2];\n          array.push(attribute.toJSON(data.data));\n        }\n        if (array.length > 0) {\n          morphAttributes[key] = array;\n          hasMorphAttributes = true;\n        }\n      }\n      if (hasMorphAttributes) {\n        data.data.morphAttributes = morphAttributes;\n        data.data.morphTargetsRelative = this.morphTargetsRelative;\n      }\n      const groups = this.groups;\n      if (groups.length > 0) {\n        data.data.groups = JSON.parse(JSON.stringify(groups));\n      }\n      const boundingSphere = this.boundingSphere;\n      if (boundingSphere !== null) {\n        data.data.boundingSphere = {\n          center: boundingSphere.center.toArray(),\n          radius: boundingSphere.radius\n        };\n      }\n      return data;\n    }\n    clone() {\n      return new this.constructor().copy(this);\n    }\n    copy(source) {\n      this.index = null;\n      this.attributes = {};\n      this.morphAttributes = {};\n      this.groups = [];\n      this.boundingBox = null;\n      this.boundingSphere = null;\n      const data = {};\n      this.name = source.name;\n      const index = source.index;\n      if (index !== null) {\n        this.setIndex(index.clone(data));\n      }\n      const attributes = source.attributes;\n      for (const name in attributes) {\n        const attribute = attributes[name];\n        this.setAttribute(name, attribute.clone(data));\n      }\n      const morphAttributes = source.morphAttributes;\n      for (const name in morphAttributes) {\n        const array = [];\n        const morphAttribute = morphAttributes[name];\n        for (let i2 = 0, l = morphAttribute.length; i2 < l; i2++) {\n          array.push(morphAttribute[i2].clone(data));\n        }\n        this.morphAttributes[name] = array;\n      }\n      this.morphTargetsRelative = source.morphTargetsRelative;\n      const groups = source.groups;\n      for (let i2 = 0, l = groups.length; i2 < l; i2++) {\n        const group = groups[i2];\n        this.addGroup(group.start, group.count, group.materialIndex);\n      }\n      const boundingBox = source.boundingBox;\n      if (boundingBox !== null) {\n        this.boundingBox = boundingBox.clone();\n      }\n      const boundingSphere = source.boundingSphere;\n      if (boundingSphere !== null) {\n        this.boundingSphere = boundingSphere.clone();\n      }\n      this.drawRange.start = source.drawRange.start;\n      this.drawRange.count = source.drawRange.count;\n      this.userData = source.userData;\n      return this;\n    }\n    dispose() {\n      this.dispatchEvent({ type: "dispose" });\n    }\n  }\n  const _inverseMatrix$3 = /* @__PURE__ */ new Matrix4();\n  const _ray$3 = /* @__PURE__ */ new Ray();\n  const _sphere$6 = /* @__PURE__ */ new Sphere();\n  const _sphereHitAt = /* @__PURE__ */ new Vector3();\n  const _vA$1 = /* @__PURE__ */ new Vector3();\n  const _vB$1 = /* @__PURE__ */ new Vector3();\n  const _vC$1 = /* @__PURE__ */ new Vector3();\n  const _tempA = /* @__PURE__ */ new Vector3();\n  const _morphA = /* @__PURE__ */ new Vector3();\n  const _intersectionPoint = /* @__PURE__ */ new Vector3();\n  const _intersectionPointWorld = /* @__PURE__ */ new Vector3();\n  class Mesh extends Object3D {\n    constructor(geometry = new BufferGeometry(), material = new MeshBasicMaterial()) {\n      super();\n      this.isMesh = true;\n      this.type = "Mesh";\n      this.geometry = geometry;\n      this.material = material;\n      this.updateMorphTargets();\n    }\n    copy(source, recursive) {\n      super.copy(source, recursive);\n      if (source.morphTargetInfluences !== void 0) {\n        this.morphTargetInfluences = source.morphTargetInfluences.slice();\n      }\n      if (source.morphTargetDictionary !== void 0) {\n        this.morphTargetDictionary = Object.assign({}, source.morphTargetDictionary);\n      }\n      this.material = Array.isArray(source.material) ? source.material.slice() : source.material;\n      this.geometry = source.geometry;\n      return this;\n    }\n    updateMorphTargets() {\n      const geometry = this.geometry;\n      const morphAttributes = geometry.morphAttributes;\n      const keys = Object.keys(morphAttributes);\n      if (keys.length > 0) {\n        const morphAttribute = morphAttributes[keys[0]];\n        if (morphAttribute !== void 0) {\n          this.morphTargetInfluences = [];\n          this.morphTargetDictionary = {};\n          for (let m = 0, ml = morphAttribute.length; m < ml; m++) {\n            const name = morphAttribute[m].name || String(m);\n            this.morphTargetInfluences.push(0);\n            this.morphTargetDictionary[name] = m;\n          }\n        }\n      }\n    }\n    getVertexPosition(index, target) {\n      const geometry = this.geometry;\n      const position = geometry.attributes.position;\n      const morphPosition = geometry.morphAttributes.position;\n      const morphTargetsRelative = geometry.morphTargetsRelative;\n      target.fromBufferAttribute(position, index);\n      const morphInfluences = this.morphTargetInfluences;\n      if (morphPosition && morphInfluences) {\n        _morphA.set(0, 0, 0);\n        for (let i2 = 0, il = morphPosition.length; i2 < il; i2++) {\n          const influence = morphInfluences[i2];\n          const morphAttribute = morphPosition[i2];\n          if (influence === 0) continue;\n          _tempA.fromBufferAttribute(morphAttribute, index);\n          if (morphTargetsRelative) {\n            _morphA.addScaledVector(_tempA, influence);\n          } else {\n            _morphA.addScaledVector(_tempA.sub(target), influence);\n          }\n        }\n        target.add(_morphA);\n      }\n      return target;\n    }\n    raycast(raycaster, intersects) {\n      const geometry = this.geometry;\n      const material = this.material;\n      const matrixWorld = this.matrixWorld;\n      if (material === void 0) return;\n      if (geometry.boundingSphere === null) geometry.computeBoundingSphere();\n      _sphere$6.copy(geometry.boundingSphere);\n      _sphere$6.applyMatrix4(matrixWorld);\n      _ray$3.copy(raycaster.ray).recast(raycaster.near);\n      if (_sphere$6.containsPoint(_ray$3.origin) === false) {\n        if (_ray$3.intersectSphere(_sphere$6, _sphereHitAt) === null) return;\n        if (_ray$3.origin.distanceToSquared(_sphereHitAt) > (raycaster.far - raycaster.near) ** 2) return;\n      }\n      _inverseMatrix$3.copy(matrixWorld).invert();\n      _ray$3.copy(raycaster.ray).applyMatrix4(_inverseMatrix$3);\n      if (geometry.boundingBox !== null) {\n        if (_ray$3.intersectsBox(geometry.boundingBox) === false) return;\n      }\n      this._computeIntersections(raycaster, intersects, _ray$3);\n    }\n    _computeIntersections(raycaster, intersects, rayLocalSpace) {\n      let intersection;\n      const geometry = this.geometry;\n      const material = this.material;\n      const index = geometry.index;\n      const position = geometry.attributes.position;\n      const uv = geometry.attributes.uv;\n      const uv1 = geometry.attributes.uv1;\n      const normal = geometry.attributes.normal;\n      const groups = geometry.groups;\n      const drawRange = geometry.drawRange;\n      if (index !== null) {\n        if (Array.isArray(material)) {\n          for (let i2 = 0, il = groups.length; i2 < il; i2++) {\n            const group = groups[i2];\n            const groupMaterial = material[group.materialIndex];\n            const start = Math.max(group.start, drawRange.start);\n            const end = Math.min(index.count, Math.min(group.start + group.count, drawRange.start + drawRange.count));\n            for (let j = start, jl = end; j < jl; j += 3) {\n              const a = index.getX(j);\n              const b = index.getX(j + 1);\n              const c = index.getX(j + 2);\n              intersection = checkGeometryIntersection(this, groupMaterial, raycaster, rayLocalSpace, uv, uv1, normal, a, b, c);\n              if (intersection) {\n                intersection.faceIndex = Math.floor(j / 3);\n                intersection.face.materialIndex = group.materialIndex;\n                intersects.push(intersection);\n              }\n            }\n          }\n        } else {\n          const start = Math.max(0, drawRange.start);\n          const end = Math.min(index.count, drawRange.start + drawRange.count);\n          for (let i2 = start, il = end; i2 < il; i2 += 3) {\n            const a = index.getX(i2);\n            const b = index.getX(i2 + 1);\n            const c = index.getX(i2 + 2);\n            intersection = checkGeometryIntersection(this, material, raycaster, rayLocalSpace, uv, uv1, normal, a, b, c);\n            if (intersection) {\n              intersection.faceIndex = Math.floor(i2 / 3);\n              intersects.push(intersection);\n            }\n          }\n        }\n      } else if (position !== void 0) {\n        if (Array.isArray(material)) {\n          for (let i2 = 0, il = groups.length; i2 < il; i2++) {\n            const group = groups[i2];\n            const groupMaterial = material[group.materialIndex];\n            const start = Math.max(group.start, drawRange.start);\n            const end = Math.min(position.count, Math.min(group.start + group.count, drawRange.start + drawRange.count));\n            for (let j = start, jl = end; j < jl; j += 3) {\n              const a = j;\n              const b = j + 1;\n              const c = j + 2;\n              intersection = checkGeometryIntersection(this, groupMaterial, raycaster, rayLocalSpace, uv, uv1, normal, a, b, c);\n              if (intersection) {\n                intersection.faceIndex = Math.floor(j / 3);\n                intersection.face.materialIndex = group.materialIndex;\n                intersects.push(intersection);\n              }\n            }\n          }\n        } else {\n          const start = Math.max(0, drawRange.start);\n          const end = Math.min(position.count, drawRange.start + drawRange.count);\n          for (let i2 = start, il = end; i2 < il; i2 += 3) {\n            const a = i2;\n            const b = i2 + 1;\n            const c = i2 + 2;\n            intersection = checkGeometryIntersection(this, material, raycaster, rayLocalSpace, uv, uv1, normal, a, b, c);\n            if (intersection) {\n              intersection.faceIndex = Math.floor(i2 / 3);\n              intersects.push(intersection);\n            }\n          }\n        }\n      }\n    }\n  }\n  function checkIntersection$1(object, material, raycaster, ray, pA, pB, pC, point) {\n    let intersect;\n    if (material.side === BackSide) {\n      intersect = ray.intersectTriangle(pC, pB, pA, true, point);\n    } else {\n      intersect = ray.intersectTriangle(pA, pB, pC, material.side === FrontSide, point);\n    }\n    if (intersect === null) return null;\n    _intersectionPointWorld.copy(point);\n    _intersectionPointWorld.applyMatrix4(object.matrixWorld);\n    const distance = raycaster.ray.origin.distanceTo(_intersectionPointWorld);\n    if (distance < raycaster.near || distance > raycaster.far) return null;\n    return {\n      distance,\n      point: _intersectionPointWorld.clone(),\n      object\n    };\n  }\n  function checkGeometryIntersection(object, material, raycaster, ray, uv, uv1, normal, a, b, c) {\n    object.getVertexPosition(a, _vA$1);\n    object.getVertexPosition(b, _vB$1);\n    object.getVertexPosition(c, _vC$1);\n    const intersection = checkIntersection$1(object, material, raycaster, ray, _vA$1, _vB$1, _vC$1, _intersectionPoint);\n    if (intersection) {\n      const barycoord = new Vector3();\n      Triangle.getBarycoord(_intersectionPoint, _vA$1, _vB$1, _vC$1, barycoord);\n      if (uv) {\n        intersection.uv = Triangle.getInterpolatedAttribute(uv, a, b, c, barycoord, new Vector2());\n      }\n      if (uv1) {\n        intersection.uv1 = Triangle.getInterpolatedAttribute(uv1, a, b, c, barycoord, new Vector2());\n      }\n      if (normal) {\n        intersection.normal = Triangle.getInterpolatedAttribute(normal, a, b, c, barycoord, new Vector3());\n        if (intersection.normal.dot(ray.direction) > 0) {\n          intersection.normal.multiplyScalar(-1);\n        }\n      }\n      const face = {\n        a,\n        b,\n        c,\n        normal: new Vector3(),\n        materialIndex: 0\n      };\n      Triangle.getNormal(_vA$1, _vB$1, _vC$1, face.normal);\n      intersection.face = face;\n      intersection.barycoord = barycoord;\n    }\n    return intersection;\n  }\n  function cloneUniforms(src) {\n    const dst = {};\n    for (const u in src) {\n      dst[u] = {};\n      for (const p in src[u]) {\n        const property = src[u][p];\n        if (property && (property.isColor || property.isMatrix3 || property.isMatrix4 || property.isVector2 || property.isVector3 || property.isVector4 || property.isTexture || property.isQuaternion)) {\n          if (property.isRenderTargetTexture) {\n            console.warn("UniformsUtils: Textures of render targets cannot be cloned via cloneUniforms() or mergeUniforms().");\n            dst[u][p] = null;\n          } else {\n            dst[u][p] = property.clone();\n          }\n        } else if (Array.isArray(property)) {\n          dst[u][p] = property.slice();\n        } else {\n          dst[u][p] = property;\n        }\n      }\n    }\n    return dst;\n  }\n  function cloneUniformsGroups(src) {\n    const dst = [];\n    for (let u = 0; u < src.length; u++) {\n      dst.push(src[u].clone());\n    }\n    return dst;\n  }\n  var default_vertex = "void main() {\\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\\n}";\n  var default_fragment = "void main() {\\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\\n}";\n  class ShaderMaterial extends Material {\n    constructor(parameters) {\n      super();\n      this.isShaderMaterial = true;\n      this.type = "ShaderMaterial";\n      this.defines = {};\n      this.uniforms = {};\n      this.uniformsGroups = [];\n      this.vertexShader = default_vertex;\n      this.fragmentShader = default_fragment;\n      this.linewidth = 1;\n      this.wireframe = false;\n      this.wireframeLinewidth = 1;\n      this.fog = false;\n      this.lights = false;\n      this.clipping = false;\n      this.forceSinglePass = true;\n      this.extensions = {\n        clipCullDistance: false,\n        // set to use vertex shader clipping\n        multiDraw: false\n        // set to use vertex shader multi_draw / enable gl_DrawID\n      };\n      this.defaultAttributeValues = {\n        "color": [1, 1, 1],\n        "uv": [0, 0],\n        "uv1": [0, 0]\n      };\n      this.index0AttributeName = void 0;\n      this.uniformsNeedUpdate = false;\n      this.glslVersion = null;\n      if (parameters !== void 0) {\n        this.setValues(parameters);\n      }\n    }\n    copy(source) {\n      super.copy(source);\n      this.fragmentShader = source.fragmentShader;\n      this.vertexShader = source.vertexShader;\n      this.uniforms = cloneUniforms(source.uniforms);\n      this.uniformsGroups = cloneUniformsGroups(source.uniformsGroups);\n      this.defines = Object.assign({}, source.defines);\n      this.wireframe = source.wireframe;\n      this.wireframeLinewidth = source.wireframeLinewidth;\n      this.fog = source.fog;\n      this.lights = source.lights;\n      this.clipping = source.clipping;\n      this.extensions = Object.assign({}, source.extensions);\n      this.glslVersion = source.glslVersion;\n      return this;\n    }\n    toJSON(meta) {\n      const data = super.toJSON(meta);\n      data.glslVersion = this.glslVersion;\n      data.uniforms = {};\n      for (const name in this.uniforms) {\n        const uniform = this.uniforms[name];\n        const value = uniform.value;\n        if (value && value.isTexture) {\n          data.uniforms[name] = {\n            type: "t",\n            value: value.toJSON(meta).uuid\n          };\n        } else if (value && value.isColor) {\n          data.uniforms[name] = {\n            type: "c",\n            value: value.getHex()\n          };\n        } else if (value && value.isVector2) {\n          data.uniforms[name] = {\n            type: "v2",\n            value: value.toArray()\n          };\n        } else if (value && value.isVector3) {\n          data.uniforms[name] = {\n            type: "v3",\n            value: value.toArray()\n          };\n        } else if (value && value.isVector4) {\n          data.uniforms[name] = {\n            type: "v4",\n            value: value.toArray()\n          };\n        } else if (value && value.isMatrix3) {\n          data.uniforms[name] = {\n            type: "m3",\n            value: value.toArray()\n          };\n        } else if (value && value.isMatrix4) {\n          data.uniforms[name] = {\n            type: "m4",\n            value: value.toArray()\n          };\n        } else {\n          data.uniforms[name] = {\n            value\n          };\n        }\n      }\n      if (Object.keys(this.defines).length > 0) data.defines = this.defines;\n      data.vertexShader = this.vertexShader;\n      data.fragmentShader = this.fragmentShader;\n      data.lights = this.lights;\n      data.clipping = this.clipping;\n      const extensions = {};\n      for (const key in this.extensions) {\n        if (this.extensions[key] === true) extensions[key] = true;\n      }\n      if (Object.keys(extensions).length > 0) data.extensions = extensions;\n      return data;\n    }\n  }\n  class Camera extends Object3D {\n    constructor() {\n      super();\n      this.isCamera = true;\n      this.type = "Camera";\n      this.matrixWorldInverse = new Matrix4();\n      this.projectionMatrix = new Matrix4();\n      this.projectionMatrixInverse = new Matrix4();\n      this.coordinateSystem = WebGLCoordinateSystem;\n    }\n    copy(source, recursive) {\n      super.copy(source, recursive);\n      this.matrixWorldInverse.copy(source.matrixWorldInverse);\n      this.projectionMatrix.copy(source.projectionMatrix);\n      this.projectionMatrixInverse.copy(source.projectionMatrixInverse);\n      this.coordinateSystem = source.coordinateSystem;\n      return this;\n    }\n    getWorldDirection(target) {\n      return super.getWorldDirection(target).negate();\n    }\n    updateMatrixWorld(force) {\n      super.updateMatrixWorld(force);\n      this.matrixWorldInverse.copy(this.matrixWorld).invert();\n    }\n    updateWorldMatrix(updateParents, updateChildren) {\n      super.updateWorldMatrix(updateParents, updateChildren);\n      this.matrixWorldInverse.copy(this.matrixWorld).invert();\n    }\n    clone() {\n      return new this.constructor().copy(this);\n    }\n  }\n  class Scene extends Object3D {\n    constructor() {\n      super();\n      this.isScene = true;\n      this.type = "Scene";\n      this.background = null;\n      this.environment = null;\n      this.fog = null;\n      this.backgroundBlurriness = 0;\n      this.backgroundIntensity = 1;\n      this.backgroundRotation = new Euler();\n      this.environmentIntensity = 1;\n      this.environmentRotation = new Euler();\n      this.overrideMaterial = null;\n      if (typeof __THREE_DEVTOOLS__ !== "undefined") {\n        __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", { detail: this }));\n      }\n    }\n    copy(source, recursive) {\n      super.copy(source, recursive);\n      if (source.background !== null) this.background = source.background.clone();\n      if (source.environment !== null) this.environment = source.environment.clone();\n      if (source.fog !== null) this.fog = source.fog.clone();\n      this.backgroundBlurriness = source.backgroundBlurriness;\n      this.backgroundIntensity = source.backgroundIntensity;\n      this.backgroundRotation.copy(source.backgroundRotation);\n      this.environmentIntensity = source.environmentIntensity;\n      this.environmentRotation.copy(source.environmentRotation);\n      if (source.overrideMaterial !== null) this.overrideMaterial = source.overrideMaterial.clone();\n      this.matrixAutoUpdate = source.matrixAutoUpdate;\n      return this;\n    }\n    toJSON(meta) {\n      const data = super.toJSON(meta);\n      if (this.fog !== null) data.object.fog = this.fog.toJSON();\n      if (this.backgroundBlurriness > 0) data.object.backgroundBlurriness = this.backgroundBlurriness;\n      if (this.backgroundIntensity !== 1) data.object.backgroundIntensity = this.backgroundIntensity;\n      data.object.backgroundRotation = this.backgroundRotation.toArray();\n      if (this.environmentIntensity !== 1) data.object.environmentIntensity = this.environmentIntensity;\n      data.object.environmentRotation = this.environmentRotation.toArray();\n      return data;\n    }\n  }\n  class DataTexture extends Texture {\n    constructor(data = null, width = 1, height = 1, format, type, mapping, wrapS, wrapT, magFilter = NearestFilter, minFilter = NearestFilter, anisotropy, colorSpace) {\n      super(null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, colorSpace);\n      this.isDataTexture = true;\n      this.image = { data, width, height };\n      this.generateMipmaps = false;\n      this.flipY = false;\n      this.unpackAlignment = 1;\n    }\n  }\n  class PlaneGeometry extends BufferGeometry {\n    constructor(width = 1, height = 1, widthSegments = 1, heightSegments = 1) {\n      super();\n      this.type = "PlaneGeometry";\n      this.parameters = {\n        width,\n        height,\n        widthSegments,\n        heightSegments\n      };\n      const width_half = width / 2;\n      const height_half = height / 2;\n      const gridX = Math.floor(widthSegments);\n      const gridY = Math.floor(heightSegments);\n      const gridX1 = gridX + 1;\n      const gridY1 = gridY + 1;\n      const segment_width = width / gridX;\n      const segment_height = height / gridY;\n      const indices = [];\n      const vertices = [];\n      const normals = [];\n      const uvs = [];\n      for (let iy = 0; iy < gridY1; iy++) {\n        const y = iy * segment_height - height_half;\n        for (let ix = 0; ix < gridX1; ix++) {\n          const x2 = ix * segment_width - width_half;\n          vertices.push(x2, -y, 0);\n          normals.push(0, 0, 1);\n          uvs.push(ix / gridX);\n          uvs.push(1 - iy / gridY);\n        }\n      }\n      for (let iy = 0; iy < gridY; iy++) {\n        for (let ix = 0; ix < gridX; ix++) {\n          const a = ix + gridX1 * iy;\n          const b = ix + gridX1 * (iy + 1);\n          const c = ix + 1 + gridX1 * (iy + 1);\n          const d = ix + 1 + gridX1 * iy;\n          indices.push(a, b, d);\n          indices.push(b, c, d);\n        }\n      }\n      this.setIndex(indices);\n      this.setAttribute("position", new Float32BufferAttribute(vertices, 3));\n      this.setAttribute("normal", new Float32BufferAttribute(normals, 3));\n      this.setAttribute("uv", new Float32BufferAttribute(uvs, 2));\n    }\n    copy(source) {\n      super.copy(source);\n      this.parameters = Object.assign({}, source.parameters);\n      return this;\n    }\n    static fromJSON(data) {\n      return new PlaneGeometry(data.width, data.height, data.widthSegments, data.heightSegments);\n    }\n  }\n  class RawShaderMaterial extends ShaderMaterial {\n    constructor(parameters) {\n      super(parameters);\n      this.isRawShaderMaterial = true;\n      this.type = "RawShaderMaterial";\n    }\n  }\n  const Cache = {\n    enabled: false,\n    files: {},\n    add: function(key, file) {\n      if (this.enabled === false) return;\n      this.files[key] = file;\n    },\n    get: function(key) {\n      if (this.enabled === false) return;\n      return this.files[key];\n    },\n    remove: function(key) {\n      delete this.files[key];\n    },\n    clear: function() {\n      this.files = {};\n    }\n  };\n  class LoadingManager {\n    constructor(onLoad, onProgress, onError) {\n      const scope = this;\n      let isLoading = false;\n      let itemsLoaded = 0;\n      let itemsTotal = 0;\n      let urlModifier = void 0;\n      const handlers = [];\n      this.onStart = void 0;\n      this.onLoad = onLoad;\n      this.onProgress = onProgress;\n      this.onError = onError;\n      this.itemStart = function(url) {\n        itemsTotal++;\n        if (isLoading === false) {\n          if (scope.onStart !== void 0) {\n            scope.onStart(url, itemsLoaded, itemsTotal);\n          }\n        }\n        isLoading = true;\n      };\n      this.itemEnd = function(url) {\n        itemsLoaded++;\n        if (scope.onProgress !== void 0) {\n          scope.onProgress(url, itemsLoaded, itemsTotal);\n        }\n        if (itemsLoaded === itemsTotal) {\n          isLoading = false;\n          if (scope.onLoad !== void 0) {\n            scope.onLoad();\n          }\n        }\n      };\n      this.itemError = function(url) {\n        if (scope.onError !== void 0) {\n          scope.onError(url);\n        }\n      };\n      this.resolveURL = function(url) {\n        if (urlModifier) {\n          return urlModifier(url);\n        }\n        return url;\n      };\n      this.setURLModifier = function(transform) {\n        urlModifier = transform;\n        return this;\n      };\n      this.addHandler = function(regex, loader) {\n        handlers.push(regex, loader);\n        return this;\n      };\n      this.removeHandler = function(regex) {\n        const index = handlers.indexOf(regex);\n        if (index !== -1) {\n          handlers.splice(index, 2);\n        }\n        return this;\n      };\n      this.getHandler = function(file) {\n        for (let i2 = 0, l = handlers.length; i2 < l; i2 += 2) {\n          const regex = handlers[i2];\n          const loader = handlers[i2 + 1];\n          if (regex.global) regex.lastIndex = 0;\n          if (regex.test(file)) {\n            return loader;\n          }\n        }\n        return null;\n      };\n    }\n  }\n  const DefaultLoadingManager = /* @__PURE__ */ new LoadingManager();\n  class Loader {\n    constructor(manager) {\n      this.manager = manager !== void 0 ? manager : DefaultLoadingManager;\n      this.crossOrigin = "anonymous";\n      this.withCredentials = false;\n      this.path = "";\n      this.resourcePath = "";\n      this.requestHeader = {};\n    }\n    load() {\n    }\n    loadAsync(url, onProgress) {\n      const scope = this;\n      return new Promise(function(resolve, reject) {\n        scope.load(url, resolve, onProgress, reject);\n      });\n    }\n    parse() {\n    }\n    setCrossOrigin(crossOrigin) {\n      this.crossOrigin = crossOrigin;\n      return this;\n    }\n    setWithCredentials(value) {\n      this.withCredentials = value;\n      return this;\n    }\n    setPath(path) {\n      this.path = path;\n      return this;\n    }\n    setResourcePath(resourcePath) {\n      this.resourcePath = resourcePath;\n      return this;\n    }\n    setRequestHeader(requestHeader) {\n      this.requestHeader = requestHeader;\n      return this;\n    }\n  }\n  Loader.DEFAULT_MATERIAL_NAME = "__DEFAULT";\n  const loading = {};\n  class HttpError extends Error {\n    constructor(message, response) {\n      super(message);\n      this.response = response;\n    }\n  }\n  class FileLoader extends Loader {\n    constructor(manager) {\n      super(manager);\n    }\n    load(url, onLoad, onProgress, onError) {\n      if (url === void 0) url = "";\n      if (this.path !== void 0) url = this.path + url;\n      url = this.manager.resolveURL(url);\n      const cached = Cache.get(url);\n      if (cached !== void 0) {\n        this.manager.itemStart(url);\n        setTimeout(() => {\n          if (onLoad) onLoad(cached);\n          this.manager.itemEnd(url);\n        }, 0);\n        return cached;\n      }\n      if (loading[url] !== void 0) {\n        loading[url].push({\n          onLoad,\n          onProgress,\n          onError\n        });\n        return;\n      }\n      loading[url] = [];\n      loading[url].push({\n        onLoad,\n        onProgress,\n        onError\n      });\n      const req = new Request(url, {\n        headers: new Headers(this.requestHeader),\n        credentials: this.withCredentials ? "include" : "same-origin"\n        // An abort controller could be added within a future PR\n      });\n      const mimeType = this.mimeType;\n      const responseType = this.responseType;\n      fetch(req).then((response) => {\n        if (response.status === 200 || response.status === 0) {\n          if (response.status === 0) {\n            console.warn("THREE.FileLoader: HTTP Status 0 received.");\n          }\n          if (typeof ReadableStream === "undefined" || response.body === void 0 || response.body.getReader === void 0) {\n            return response;\n          }\n          const callbacks = loading[url];\n          const reader = response.body.getReader();\n          const contentLength = response.headers.get("X-File-Size") || response.headers.get("Content-Length");\n          const total = contentLength ? parseInt(contentLength) : 0;\n          const lengthComputable = total !== 0;\n          let loaded = 0;\n          const stream = new ReadableStream({\n            start(controller) {\n              readData();\n              function readData() {\n                reader.read().then(({ done, value }) => {\n                  if (done) {\n                    controller.close();\n                  } else {\n                    loaded += value.byteLength;\n                    const event = new ProgressEvent("progress", { lengthComputable, loaded, total });\n                    for (let i2 = 0, il = callbacks.length; i2 < il; i2++) {\n                      const callback = callbacks[i2];\n                      if (callback.onProgress) callback.onProgress(event);\n                    }\n                    controller.enqueue(value);\n                    readData();\n                  }\n                }, (e) => {\n                  controller.error(e);\n                });\n              }\n            }\n          });\n          return new Response(stream);\n        } else {\n          throw new HttpError(`fetch for "${response.url}" responded with ${response.status}: ${response.statusText}`, response);\n        }\n      }).then((response) => {\n        switch (responseType) {\n          case "arraybuffer":\n            return response.arrayBuffer();\n          case "blob":\n            return response.blob();\n          case "document":\n            return response.text().then((text) => {\n              const parser = new DOMParser();\n              return parser.parseFromString(text, mimeType);\n            });\n          case "json":\n            return response.json();\n          default:\n            if (mimeType === void 0) {\n              return response.text();\n            } else {\n              const re = /charset="?([^;"\\s]*)"?/i;\n              const exec = re.exec(mimeType);\n              const label = exec && exec[1] ? exec[1].toLowerCase() : void 0;\n              const decoder = new TextDecoder(label);\n              return response.arrayBuffer().then((ab) => decoder.decode(ab));\n            }\n        }\n      }).then((data) => {\n        Cache.add(url, data);\n        const callbacks = loading[url];\n        delete loading[url];\n        for (let i2 = 0, il = callbacks.length; i2 < il; i2++) {\n          const callback = callbacks[i2];\n          if (callback.onLoad) callback.onLoad(data);\n        }\n      }).catch((err2) => {\n        const callbacks = loading[url];\n        if (callbacks === void 0) {\n          this.manager.itemError(url);\n          throw err2;\n        }\n        delete loading[url];\n        for (let i2 = 0, il = callbacks.length; i2 < il; i2++) {\n          const callback = callbacks[i2];\n          if (callback.onError) callback.onError(err2);\n        }\n        this.manager.itemError(url);\n      }).finally(() => {\n        this.manager.itemEnd(url);\n      });\n      this.manager.itemStart(url);\n    }\n    setResponseType(value) {\n      this.responseType = value;\n      return this;\n    }\n    setMimeType(value) {\n      this.mimeType = value;\n      return this;\n    }\n  }\n  class Matrix2 {\n    constructor(n11, n12, n21, n22) {\n      Matrix2.prototype.isMatrix2 = true;\n      this.elements = [\n        1,\n        0,\n        0,\n        1\n      ];\n      if (n11 !== void 0) {\n        this.set(n11, n12, n21, n22);\n      }\n    }\n    identity() {\n      this.set(\n        1,\n        0,\n        0,\n        1\n      );\n      return this;\n    }\n    fromArray(array, offset = 0) {\n      for (let i2 = 0; i2 < 4; i2++) {\n        this.elements[i2] = array[i2 + offset];\n      }\n      return this;\n    }\n    set(n11, n12, n21, n22) {\n      const te = this.elements;\n      te[0] = n11;\n      te[2] = n12;\n      te[1] = n21;\n      te[3] = n22;\n      return this;\n    }\n  }\n  if (typeof __THREE_DEVTOOLS__ !== "undefined") {\n    __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register", { detail: {\n      revision: REVISION\n    } }));\n  }\n  if (typeof window !== "undefined") {\n    if (window.__THREE__) {\n      console.warn("WARNING: Multiple instances of Three.js being imported.");\n    } else {\n      window.__THREE__ = REVISION;\n    }\n  }\n  const LN_SCALE_MIN = -9;\n  const LN_SCALE_MAX = 9;\n  const LN_RESCALE = (LN_SCALE_MAX - LN_SCALE_MIN) / 254;\n  const SCALE_MIN = Math.exp(LN_SCALE_MIN);\n  const SPLAT_TEX_WIDTH_BITS = 11;\n  const SPLAT_TEX_HEIGHT_BITS = 11;\n  const SPLAT_TEX_WIDTH = 1 << SPLAT_TEX_WIDTH_BITS;\n  const SPLAT_TEX_HEIGHT = 1 << SPLAT_TEX_HEIGHT_BITS;\n  const SPLAT_TEX_MIN_HEIGHT = 1;\n  const WASM_SPLAT_SORT = true;\n  function isIntType(type) {\n    return type === "int" || type === "ivec2" || type === "ivec3" || type === "ivec4";\n  }\n  function isUintType(type) {\n    return type === "uint" || type === "uvec2" || type === "uvec3" || type === "uvec4";\n  }\n  function isFloatType(type) {\n    return type === "float" || type === "vec2" || type === "vec3" || type === "vec4";\n  }\n  function isMatFloatType(type) {\n    return type === "mat2" || type === "mat2x2" || type === "mat2x3" || type === "mat2x4" || type === "mat3" || type === "mat3x2" || type === "mat3x3" || type === "mat3x4" || type === "mat4" || type === "mat4x2" || type === "mat4x3" || type === "mat4x4";\n  }\n  function isAllFloatType(type) {\n    return isFloatType(type) || isMatFloatType(type);\n  }\n  function isMat2(type) {\n    return type === "mat2" || type === "mat2x2";\n  }\n  function isMat3(type) {\n    return type === "mat3" || type === "mat3x3";\n  }\n  function isMat4(type) {\n    return type === "mat4" || type === "mat4x4";\n  }\n  function numberAsInt(value) {\n    return Math.trunc(value).toString();\n  }\n  function numberAsUint(value) {\n    const v = Math.max(0, Math.trunc(value));\n    return `${v.toString()}u`;\n  }\n  function numberAsFloat(value) {\n    return value === Number.POSITIVE_INFINITY ? "INFINITY" : value === Number.NEGATIVE_INFINITY ? "-INFINITY" : Number.isInteger(value) ? value.toFixed(1) : value.toString();\n  }\n  function valType(val) {\n    if (val instanceof DynoValue) {\n      return val.type;\n    }\n    const value = val.dynoOut();\n    return value.type;\n  }\n  class DynoValue {\n    constructor(type) {\n      this.__isDynoValue = true;\n      this.type = type;\n    }\n  }\n  class DynoOutput extends DynoValue {\n    constructor(dyno2, key) {\n      super(dyno2.outTypes[key]);\n      this.dyno = dyno2;\n      this.key = key;\n    }\n  }\n  class DynoLiteral extends DynoValue {\n    constructor(type, literal) {\n      super(type);\n      this.literal = literal;\n    }\n    getLiteral() {\n      return this.literal;\n    }\n  }\n  class DynoConst extends DynoLiteral {\n    constructor(type, value) {\n      super(type, "");\n      this.value = value;\n    }\n    getLiteral() {\n      const { type, value } = this;\n      switch (type) {\n        case "bool":\n          return value ? "true" : "false";\n        case "uint":\n          return numberAsUint(value);\n        case "int":\n          return numberAsInt(value);\n        case "float":\n          return numberAsFloat(value);\n        case "bvec2": {\n          const v = value;\n          return `bvec2(${v[0]}, ${v[1]})`;\n        }\n        case "uvec2": {\n          if (value instanceof Vector2) {\n            return `uvec2(${numberAsUint(value.x)}, ${numberAsUint(value.y)})`;\n          }\n          const v = value;\n          return `uvec2(${numberAsUint(v[0])}, ${numberAsUint(v[1])})`;\n        }\n        case "ivec2": {\n          if (value instanceof Vector2) {\n            return `ivec2(${numberAsInt(value.x)}, ${numberAsInt(value.y)})`;\n          }\n          const v = value;\n          return `ivec2(${numberAsInt(v[0])}, ${numberAsInt(v[1])})`;\n        }\n        case "vec2": {\n          if (value instanceof Vector2) {\n            return `vec2(${numberAsFloat(value.x)}, ${numberAsFloat(value.y)})`;\n          }\n          const v = value;\n          return `vec2(${numberAsFloat(v[0])}, ${numberAsFloat(v[1])})`;\n        }\n        case "bvec3": {\n          const v = value;\n          return `bvec3(${v[0]}, ${v[1]}, ${v[2]})`;\n        }\n        case "uvec3": {\n          if (value instanceof Vector3) {\n            return `uvec3(${numberAsUint(value.x)}, ${numberAsUint(value.y)}, ${numberAsUint(value.z)})`;\n          }\n          const v = value;\n          return `uvec3(${numberAsUint(v[0])}, ${numberAsUint(v[1])}, ${numberAsUint(v[2])})`;\n        }\n        case "ivec3": {\n          if (value instanceof Vector3) {\n            return `ivec3(${numberAsInt(value.x)}, ${numberAsInt(value.y)}, ${numberAsInt(value.z)})`;\n          }\n          const v = value;\n          return `ivec3(${numberAsInt(v[0])}, ${numberAsInt(v[1])}, ${numberAsInt(v[2])})`;\n        }\n        case "vec3": {\n          if (value instanceof Vector3) {\n            return `vec3(${numberAsFloat(value.x)}, ${numberAsFloat(value.y)}, ${numberAsFloat(value.z)})`;\n          }\n          const v = value;\n          return `vec3(${numberAsFloat(v[0])}, ${numberAsFloat(v[1])}, ${numberAsFloat(v[2])})`;\n        }\n        case "bvec4": {\n          const v = value;\n          return `bvec4(${v[0]}, ${v[1]}, ${v[2]}, ${v[3]})`;\n        }\n        case "uvec4": {\n          if (value instanceof Vector4) {\n            return `uvec4(${numberAsUint(value.x)}, ${numberAsUint(value.y)}, ${numberAsUint(value.z)}, ${numberAsUint(value.w)})`;\n          }\n          const v = value;\n          return `uvec4(${numberAsUint(v[0])}, ${numberAsUint(v[1])}, ${numberAsUint(v[2])}, ${numberAsUint(v[3])})`;\n        }\n        case "ivec4": {\n          if (value instanceof Vector4) {\n            return `ivec4(${numberAsInt(value.x)}, ${numberAsInt(value.y)}, ${numberAsInt(value.z)}, ${numberAsInt(value.w)})`;\n          }\n          const v = value;\n          return `ivec4(${numberAsInt(v[0])}, ${numberAsInt(v[1])}, ${numberAsInt(v[2])}, ${numberAsInt(v[3])})`;\n        }\n        case "vec4": {\n          if (value instanceof Vector4) {\n            return `vec4(${numberAsFloat(value.x)}, ${numberAsFloat(value.y)}, ${numberAsFloat(value.z)}, ${numberAsFloat(value.w)})`;\n          }\n          if (value instanceof Quaternion) {\n            return `vec4(${numberAsFloat(value.x)}, ${numberAsFloat(value.y)}, ${numberAsFloat(value.z)}, ${numberAsFloat(value.w)})`;\n          }\n          const v = value;\n          return `vec4(${numberAsFloat(v[0])}, ${numberAsFloat(v[1])}, ${numberAsFloat(v[2])}, ${numberAsFloat(v[3])})`;\n        }\n        case "mat2":\n        case "mat2x2": {\n          const m = value;\n          const e = m instanceof Matrix2 ? m.elements : value;\n          const arg = new Array(4).fill(0).map((_, i2) => numberAsFloat(e[i2]));\n          return `${type}(${arg.join(", ")})`;\n        }\n        case "mat2x3": {\n          const e = value;\n          const arg = new Array(6).fill(0).map((_, i2) => numberAsFloat(e[i2]));\n          return `${type}(${arg.join(", ")})`;\n        }\n        case "mat2x4": {\n          const e = value;\n          const arg = new Array(8).fill(0).map((_, i2) => numberAsFloat(e[i2]));\n          return `${type}(${arg.join(", ")})`;\n        }\n        case "mat3":\n        case "mat3x3": {\n          const m = value;\n          const e = m instanceof Matrix3 ? m.elements : value;\n          const arg = new Array(9).fill(0).map((_, i2) => numberAsFloat(e[i2]));\n          return `${type}(${arg.join(", ")})`;\n        }\n        case "mat3x2": {\n          const e = value;\n          const arg = new Array(6).fill(0).map((_, i2) => numberAsFloat(e[i2]));\n          return `${type}(${arg.join(", ")})`;\n        }\n        case "mat3x4": {\n          const e = value;\n          const arg = new Array(12).fill(0).map((_, i2) => numberAsFloat(e[i2]));\n          return `${type}(${arg.join(", ")})`;\n        }\n        case "mat4":\n        case "mat4x4": {\n          const m = value;\n          const e = m instanceof Matrix4 ? m.elements : value;\n          const arg = new Array(16).fill(0).map((_, i2) => numberAsFloat(e[i2]));\n          return `${type}(${arg.join(", ")})`;\n        }\n        case "mat4x2": {\n          const e = value;\n          const arg = new Array(8).fill(0).map((_, i2) => numberAsFloat(e[i2]));\n          return `${type}(${arg.join(", ")})`;\n        }\n        case "mat4x3": {\n          const e = value;\n          const arg = new Array(12).fill(0).map((_, i2) => numberAsFloat(e[i2]));\n          return `${type}(${arg.join(", ")})`;\n        }\n        default:\n          throw new Error(`Type not implemented: ${String(type)}`);\n      }\n    }\n  }\n  function dynoConst(type, value) {\n    return new DynoConst(type, value);\n  }\n  const DEFAULT_INDENT = "    ";\n  class Compilation {\n    constructor({ indent } = {}) {\n      this.globals = /* @__PURE__ */ new Set();\n      this.statements = [];\n      this.uniforms = {};\n      this.declares = /* @__PURE__ */ new Set();\n      this.updaters = [];\n      this.sequence = 0;\n      this.indent = DEFAULT_INDENT;\n      this.indent = indent ?? DEFAULT_INDENT;\n    }\n    nextSequence() {\n      return this.sequence++;\n    }\n  }\n  class Dyno {\n    constructor({\n      inTypes,\n      outTypes,\n      inputs,\n      update,\n      globals,\n      statements,\n      generate\n    }) {\n      this.inTypes = inTypes ?? {};\n      this.outTypes = outTypes ?? {};\n      this.inputs = inputs ?? {};\n      this.update = update;\n      this.globals = globals;\n      this.statements = statements;\n      this.generate = generate ?? (({ inputs: inputs2, outputs, compile }) => {\n        var _a2, _b2;\n        return {\n          globals: (_a2 = this.globals) == null ? void 0 : _a2.call(this, { inputs: inputs2, outputs, compile }),\n          statements: (_b2 = this.statements) == null ? void 0 : _b2.call(this, { inputs: inputs2, outputs, compile })\n        };\n      });\n    }\n    get outputs() {\n      const outputs = {};\n      for (const key in this.outTypes) {\n        outputs[key] = new DynoOutput(this, key);\n      }\n      return outputs;\n    }\n    apply(inputs) {\n      Object.assign(this.inputs, inputs);\n      return this.outputs;\n    }\n    compile({\n      inputs,\n      outputs,\n      compile\n    }) {\n      const result = [\n        `// ${this.constructor.name}(${Object.values(inputs).join(", ")}) => (${Object.values(outputs).join(", ")})`\n      ];\n      const declares = [];\n      for (const key in outputs) {\n        const name = outputs[key];\n        if (name && !compile.declares.has(name)) {\n          compile.declares.add(name);\n          declares.push(key);\n        }\n      }\n      const { globals, statements, uniforms } = this.generate({\n        inputs,\n        outputs,\n        compile\n      });\n      for (const global2 of globals ?? []) {\n        compile.globals.add(global2);\n      }\n      for (const key in uniforms) {\n        compile.uniforms[key] = uniforms[key];\n      }\n      if (this.update) {\n        compile.updaters.push(this.update);\n      }\n      for (const key of declares) {\n        const name = outputs[key];\n        if (name) {\n          if (!compile.uniforms[name]) {\n            result.push(`${dynoDeclare(name, this.outTypes[key])};`);\n          }\n        }\n      }\n      if (statements == null ? void 0 : statements.length) {\n        result.push("{");\n        result.push(...statements.map((line) => compile.indent + line));\n        result.push("}");\n      }\n      return result;\n    }\n  }\n  class DynoBlock extends Dyno {\n    constructor({\n      inTypes,\n      outTypes,\n      inputs,\n      update,\n      globals,\n      construct\n    }) {\n      super({\n        inTypes,\n        outTypes,\n        inputs,\n        update,\n        globals,\n        generate: (args) => this.generateBlock(args)\n      });\n      this.construct = construct;\n    }\n    generateBlock({\n      inputs,\n      outputs,\n      compile\n    }) {\n      var _a2, _b2;\n      const blockInputs = {};\n      const blockOutputs = {};\n      for (const key in inputs) {\n        if (inputs[key] != null) {\n          blockInputs[key] = new DynoLiteral(this.inTypes[key], inputs[key]);\n        }\n      }\n      for (const key in outputs) {\n        if (outputs[key] != null) {\n          blockOutputs[key] = new DynoValue(this.outTypes[key]);\n        }\n      }\n      const options = { roots: [] };\n      const returned = this.construct(blockInputs, blockOutputs, options);\n      for (const global2 of ((_a2 = this.globals) == null ? void 0 : _a2.call(this, { inputs, outputs, compile })) ?? []) {\n        compile.globals.add(global2);\n      }\n      const ordering = [];\n      const nodeOuts = /* @__PURE__ */ new Map();\n      function visit(node, outKey, outName) {\n        let outs = nodeOuts.get(node);\n        if (!outs) {\n          outs = {\n            sequence: compile.nextSequence(),\n            outNames: /* @__PURE__ */ new Map(),\n            newOuts: /* @__PURE__ */ new Set()\n          };\n          nodeOuts.set(node, outs);\n          for (const key in node.inputs) {\n            let input = node.inputs[key];\n            while (input) {\n              if (input instanceof DynoValue) {\n                if (input instanceof DynoOutput) {\n                  visit(input.dyno, input.key);\n                }\n                break;\n              }\n              input = input.dynoOut();\n            }\n          }\n          ordering.push(node);\n        }\n        if (outKey) {\n          if (!outName) {\n            outs.newOuts.add(outKey);\n          }\n          outs.outNames.set(outKey, outName ?? `${outKey}_${outs.sequence}`);\n        }\n      }\n      for (const root of options.roots) {\n        visit(root);\n      }\n      for (const key in blockOutputs) {\n        let value = (returned == null ? void 0 : returned[key]) ?? blockOutputs[key];\n        while (value) {\n          if (value instanceof DynoValue) {\n            if (value instanceof DynoOutput) {\n              visit(value.dyno, value.key, outputs[key]);\n            }\n            break;\n          }\n          value = value.dynoOut();\n        }\n        blockOutputs[key] = value;\n      }\n      const steps = [];\n      for (const dyno2 of ordering) {\n        const inputs2 = {};\n        const outputs2 = {};\n        for (const key in dyno2.inputs) {\n          let value = dyno2.inputs[key];\n          while (value) {\n            if (value instanceof DynoValue) {\n              if (value instanceof DynoLiteral) {\n                inputs2[key] = value.getLiteral();\n              } else if (value instanceof DynoOutput) {\n                const source = (_b2 = nodeOuts.get(value.dyno)) == null ? void 0 : _b2.outNames.get(value.key);\n                if (!source) {\n                  throw new Error(\n                    `Source not found for ${value.dyno.constructor.name}.${value.key}`\n                  );\n                }\n                inputs2[key] = source;\n              }\n              break;\n            }\n            value = value.dynoOut();\n          }\n        }\n        const outs = nodeOuts.get(dyno2) ?? { outNames: /* @__PURE__ */ new Map() };\n        for (const [key, name] of outs.outNames.entries()) {\n          outputs2[key] = name;\n        }\n        const newSteps = dyno2.compile({ inputs: inputs2, outputs: outputs2, compile });\n        steps.push(newSteps);\n      }\n      const literalOutputs = [];\n      for (const key in outputs) {\n        if (blockOutputs[key] instanceof DynoLiteral) {\n          literalOutputs.push(\n            `${outputs[key]} = ${blockOutputs[key].getLiteral()};`\n          );\n        }\n      }\n      if (literalOutputs.length > 0) {\n        steps.push(literalOutputs);\n      }\n      const statements = steps.flatMap((step, index) => {\n        return index === 0 ? step : ["", ...step];\n      });\n      return { statements };\n    }\n  }\n  function dynoBlock(inTypes, outTypes, construct, { update, globals } = {}) {\n    return new DynoBlock({ inTypes, outTypes, construct, update, globals });\n  }\n  function dyno({\n    inTypes,\n    outTypes,\n    inputs,\n    update,\n    globals,\n    statements,\n    generate\n  }) {\n    return new Dyno({\n      inTypes,\n      outTypes,\n      inputs,\n      update,\n      globals,\n      statements,\n      generate\n    });\n  }\n  function dynoDeclare(name, type, count) {\n    const typeStr = typeof type === "string" ? type : type.type;\n    if (!typeStr) {\n      throw new Error(`Invalid DynoType: ${String(type)}`);\n    }\n    return `${typeStr} ${name}${count != null ? `[${count}]` : ""}`;\n  }\n  function unindentLines(s) {\n    var _a2;\n    let seenNonEmpty = false;\n    const lines = s.split("\\n").map((line) => {\n      const trimmedLine = line.trimEnd();\n      if (seenNonEmpty) {\n        return trimmedLine;\n      }\n      if (trimmedLine.length > 0) {\n        seenNonEmpty = true;\n        return trimmedLine;\n      }\n      return null;\n    }).filter((line) => line != null);\n    while (lines.length > 0 && lines[lines.length - 1].length === 0) {\n      lines.pop();\n    }\n    if (lines.length === 0) {\n      return [];\n    }\n    const indent = (_a2 = lines[0].match(/^\\s*/)) == null ? void 0 : _a2[0];\n    if (!indent) {\n      return lines;\n    }\n    const regex = new RegExp(`^${indent}`);\n    return lines.map((line) => line.replace(regex, ""));\n  }\n  function unindent(s) {\n    return unindentLines(s).join("\\n");\n  }\n  class UnaryOp extends Dyno {\n    constructor({\n      a,\n      outKey,\n      outTypeFunc\n    }) {\n      const inTypes = { a: valType(a) };\n      const outType = outTypeFunc(valType(a));\n      const outTypes = { [outKey]: outType };\n      super({ inTypes, outTypes, inputs: { a } });\n      this.outKey = outKey;\n    }\n    dynoOut() {\n      return new DynoOutput(this, this.outKey);\n    }\n  }\n  class BinaryOp extends Dyno {\n    constructor({\n      a,\n      b,\n      outKey,\n      outTypeFunc\n    }) {\n      const inTypes = { a: valType(a), b: valType(b) };\n      const outType = outTypeFunc(valType(a), valType(b));\n      const outTypes = { [outKey]: outType };\n      super({ inTypes, outTypes, inputs: { a, b } });\n      this.outKey = outKey;\n    }\n    dynoOut() {\n      return new DynoOutput(this, this.outKey);\n    }\n  }\n  const f32buffer = new Float32Array(1);\n  const u32buffer = new Uint32Array(f32buffer.buffer);\n  function toHalf(f) {\n    f32buffer[0] = f;\n    const bits2 = u32buffer[0];\n    const sign = bits2 >> 31 & 1;\n    const exp = bits2 >> 23 & 255;\n    const frac = bits2 & 8388607;\n    const halfSign = sign << 15;\n    if (exp === 255) {\n      if (frac !== 0) {\n        return halfSign | 32767;\n      }\n      return halfSign | 31744;\n    }\n    const newExp = exp - 127 + 15;\n    if (newExp >= 31) {\n      return halfSign | 31744;\n    }\n    if (newExp <= 0) {\n      if (newExp < -10) {\n        return halfSign;\n      }\n      const subFrac = (frac | 8388608) >> 1 - newExp + 13;\n      return halfSign | subFrac;\n    }\n    const halfFrac = frac >> 13;\n    return halfSign | newExp << 10 | halfFrac;\n  }\n  function fromHalf(h) {\n    const sign = h >> 15 & 1;\n    const exp = h >> 10 & 31;\n    const frac = h & 1023;\n    let f32bits;\n    if (exp === 0) {\n      if (frac === 0) {\n        f32bits = sign << 31;\n      } else {\n        let mant = frac;\n        let e = -14;\n        while ((mant & 1024) === 0) {\n          mant <<= 1;\n          e--;\n        }\n        mant &= 1023;\n        const newExp = e + 127;\n        const newFrac = mant << 13;\n        f32bits = sign << 31 | newExp << 23 | newFrac;\n      }\n    } else if (exp === 31) {\n      if (frac === 0) {\n        f32bits = sign << 31 | 2139095040;\n      } else {\n        f32bits = sign << 31 | 2143289344;\n      }\n    } else {\n      const newExp = exp - 15 + 127;\n      const newFrac = frac << 13;\n      f32bits = sign << 31 | newExp << 23 | newFrac;\n    }\n    u32buffer[0] = f32bits;\n    return f32buffer[0];\n  }\n  function floatToUint8(v) {\n    return Math.max(0, Math.min(255, Math.round(v * 255)));\n  }\n  function getArrayBuffers(ctx) {\n    const buffers = [];\n    const seen = /* @__PURE__ */ new Set();\n    function traverse(obj) {\n      if (obj && typeof obj === "object" && !seen.has(obj)) {\n        seen.add(obj);\n        if (obj instanceof ArrayBuffer) {\n          buffers.push(obj);\n        } else if (ArrayBuffer.isView(obj)) {\n          buffers.push(obj.buffer);\n        } else if (Array.isArray(obj)) {\n          obj.forEach(traverse);\n        } else {\n          Object.values(obj).forEach(traverse);\n        }\n      }\n    }\n    traverse(ctx);\n    return buffers;\n  }\n  function setPackedSplat(packedSplats, index, x2, y, z, scaleX, scaleY, scaleZ, quatX, quatY, quatZ, quatW, opacity, r, g, b) {\n    const uR = floatToUint8(r);\n    const uG = floatToUint8(g);\n    const uB = floatToUint8(b);\n    const uA = floatToUint8(opacity);\n    const uQuat = encodeQuatOctXy88R8(\n      new Quaternion(quatX, quatY, quatZ, quatW)\n    );\n    const uQuatX = uQuat & 255;\n    const uQuatY = uQuat >>> 8 & 255;\n    const uQuatZ = uQuat >>> 16 & 255;\n    const uScaleX = scaleX === 0 ? 0 : Math.min(\n      255,\n      Math.max(\n        0,\n        Math.round((Math.log(scaleX) - LN_SCALE_MIN) / LN_RESCALE) + 1\n      )\n    );\n    const uScaleY = scaleY === 0 ? 0 : Math.min(\n      255,\n      Math.max(\n        0,\n        Math.round((Math.log(scaleY) - LN_SCALE_MIN) / LN_RESCALE) + 1\n      )\n    );\n    const uScaleZ = scaleZ === 0 ? 0 : Math.min(\n      255,\n      Math.max(\n        0,\n        Math.round((Math.log(scaleZ) - LN_SCALE_MIN) / LN_RESCALE) + 1\n      )\n    );\n    const uCenterX = toHalf(x2);\n    const uCenterY = toHalf(y);\n    const uCenterZ = toHalf(z);\n    const i4 = index * 4;\n    packedSplats[i4] = uR | uG << 8 | uB << 16 | uA << 24;\n    packedSplats[i4 + 1] = uCenterX | uCenterY << 16;\n    packedSplats[i4 + 2] = uCenterZ | uQuatX << 16 | uQuatY << 24;\n    packedSplats[i4 + 3] = uScaleX | uScaleY << 8 | uScaleZ << 16 | uQuatZ << 24;\n  }\n  function setPackedSplatCenter(packedSplats, index, x2, y, z) {\n    const uCenterX = toHalf(x2);\n    const uCenterY = toHalf(y);\n    const uCenterZ = toHalf(z);\n    const i4 = index * 4;\n    packedSplats[i4 + 1] = uCenterX | uCenterY << 16;\n    packedSplats[i4 + 2] = uCenterZ | packedSplats[i4 + 2] & 4294901760;\n  }\n  function setPackedSplatScales(packedSplats, index, scaleX, scaleY, scaleZ) {\n    const uScaleX = scaleX === 0 ? 0 : Math.min(\n      255,\n      Math.max(\n        0,\n        Math.round((Math.log(scaleX) - LN_SCALE_MIN) / LN_RESCALE) + 1\n      )\n    );\n    const uScaleY = scaleY === 0 ? 0 : Math.min(\n      255,\n      Math.max(\n        0,\n        Math.round((Math.log(scaleY) - LN_SCALE_MIN) / LN_RESCALE) + 1\n      )\n    );\n    const uScaleZ = scaleZ === 0 ? 0 : Math.min(\n      255,\n      Math.max(\n        0,\n        Math.round((Math.log(scaleZ) - LN_SCALE_MIN) / LN_RESCALE) + 1\n      )\n    );\n    const i4 = index * 4;\n    packedSplats[i4 + 3] = uScaleX | uScaleY << 8 | uScaleZ << 16 | packedSplats[i4 + 3] & 4278190080;\n  }\n  function setPackedSplatQuat(packedSplats, index, quatX, quatY, quatZ, quatW) {\n    const uQuat = encodeQuatOctXy88R8(\n      new Quaternion(quatX, quatY, quatZ, quatW)\n    );\n    const uQuatX = uQuat & 255;\n    const uQuatY = uQuat >>> 8 & 255;\n    const uQuatZ = uQuat >>> 16 & 255;\n    const i4 = index * 4;\n    packedSplats[i4 + 2] = packedSplats[i4 + 2] & 65535 | uQuatX << 16 | uQuatY << 24;\n    packedSplats[i4 + 3] = packedSplats[i4 + 3] & 16777215 | uQuatZ << 24;\n  }\n  function setPackedSplatRgba(packedSplats, index, r, g, b, a) {\n    const uR = floatToUint8(r);\n    const uG = floatToUint8(g);\n    const uB = floatToUint8(b);\n    const uA = floatToUint8(a);\n    const i4 = index * 4;\n    packedSplats[i4] = uR | uG << 8 | uB << 16 | uA << 24;\n  }\n  function setPackedSplatRgb(packedSplats, index, r, g, b) {\n    const uR = floatToUint8(r);\n    const uG = floatToUint8(g);\n    const uB = floatToUint8(b);\n    const i4 = index * 4;\n    packedSplats[i4] = uR | uG << 8 | uB << 16 | packedSplats[i4] & 4278190080;\n  }\n  function setPackedSplatOpacity(packedSplats, index, opacity) {\n    const uA = floatToUint8(opacity);\n    const i4 = index * 4;\n    packedSplats[i4] = packedSplats[i4] & 16777215 | uA << 24;\n  }\n  const packedCenter = new Vector3();\n  const packedScales = new Vector3();\n  const packedQuaternion = new Quaternion();\n  const packedColor = new Color();\n  const packedFields = {\n    center: packedCenter,\n    scales: packedScales,\n    quaternion: packedQuaternion,\n    color: packedColor,\n    opacity: 0\n  };\n  function unpackSplat(packedSplats, index) {\n    const result = packedFields;\n    const i4 = index * 4;\n    const word0 = packedSplats[i4];\n    const word1 = packedSplats[i4 + 1];\n    const word2 = packedSplats[i4 + 2];\n    const word3 = packedSplats[i4 + 3];\n    result.color.set(\n      (word0 & 255) / 255,\n      (word0 >>> 8 & 255) / 255,\n      (word0 >>> 16 & 255) / 255\n    );\n    result.opacity = (word0 >>> 24 & 255) / 255;\n    result.center.set(\n      fromHalf(word1 & 65535),\n      fromHalf(word1 >>> 16 & 65535),\n      fromHalf(word2 & 65535)\n    );\n    const uScalesX = word3 & 255;\n    result.scales.x = uScalesX === 0 ? 0 : Math.exp(LN_SCALE_MIN + (uScalesX - 1) * LN_RESCALE);\n    const uScalesY = word3 >>> 8 & 255;\n    result.scales.y = uScalesY === 0 ? 0 : Math.exp(LN_SCALE_MIN + (uScalesY - 1) * LN_RESCALE);\n    const uScalesZ = word3 >>> 16 & 255;\n    result.scales.z = uScalesZ === 0 ? 0 : Math.exp(LN_SCALE_MIN + (uScalesZ - 1) * LN_RESCALE);\n    const uQuat = word2 >>> 16 & 65535 | word3 >>> 8 & 16711680;\n    decodeQuatOctXy88R8(uQuat, result.quaternion);\n    return result;\n  }\n  function getTextureSize(numSplats) {\n    const width = SPLAT_TEX_WIDTH;\n    const height = Math.max(\n      SPLAT_TEX_MIN_HEIGHT,\n      Math.min(SPLAT_TEX_HEIGHT, Math.ceil(numSplats / width))\n    );\n    const depth = Math.ceil(numSplats / (width * height));\n    const maxSplats = width * height * depth;\n    return { width, height, depth, maxSplats };\n  }\n  function computeMaxSplats(numSplats) {\n    const width = SPLAT_TEX_WIDTH;\n    const height = Math.max(\n      SPLAT_TEX_MIN_HEIGHT,\n      Math.min(SPLAT_TEX_HEIGHT, Math.ceil(numSplats / width))\n    );\n    const depth = Math.ceil(numSplats / (width * height));\n    return width * height * depth;\n  }\n  const IDENT_VERTEX_SHADER = unindent(`\n  precision highp float;\n\n  in vec3 position;\n\n  void main() {\n    gl_Position = vec4(position.xy, 0.0, 1.0);\n  }\n`);\n  function encodeQuatOctXy88R8(q) {\n    const qnorm = q.clone().normalize();\n    if (qnorm.w < 0) {\n      qnorm.set(-qnorm.x, -qnorm.y, -qnorm.z, -qnorm.w);\n    }\n    const theta = 2 * Math.acos(qnorm.w);\n    const xyz_norm = Math.sqrt(\n      qnorm.x * qnorm.x + qnorm.y * qnorm.y + qnorm.z * qnorm.z\n    );\n    const axis = xyz_norm < 1e-6 ? new Vector3(1, 0, 0) : new Vector3(qnorm.x, qnorm.y, qnorm.z).divideScalar(xyz_norm);\n    const sum = Math.abs(axis.x) + Math.abs(axis.y) + Math.abs(axis.z);\n    let p_x = axis.x / sum;\n    let p_y = axis.y / sum;\n    if (axis.z < 0) {\n      const tmp = p_x;\n      p_x = (1 - Math.abs(p_y)) * (p_x >= 0 ? 1 : -1);\n      p_y = (1 - Math.abs(tmp)) * (p_y >= 0 ? 1 : -1);\n    }\n    const u_f = p_x * 0.5 + 0.5;\n    const v_f = p_y * 0.5 + 0.5;\n    const quantU = Math.round(u_f * 255);\n    const quantV = Math.round(v_f * 255);\n    const angleInt = Math.round(theta * (255 / Math.PI));\n    return angleInt << 16 | quantV << 8 | quantU;\n  }\n  function decodeQuatOctXy88R8(encoded, out) {\n    const quantU = encoded & 255;\n    const quantV = encoded >>> 8 & 255;\n    const angleInt = encoded >>> 16 & 255;\n    const u_f = quantU / 255;\n    const v_f = quantV / 255;\n    let f_x = (u_f - 0.5) * 2;\n    let f_y = (v_f - 0.5) * 2;\n    const f_z = 1 - (Math.abs(f_x) + Math.abs(f_y));\n    const t = Math.max(-f_z, 0);\n    f_x += f_x >= 0 ? -t : t;\n    f_y += f_y >= 0 ? -t : t;\n    const axis = new Vector3(f_x, f_y, f_z).normalize();\n    const theta = angleInt / 255 * Math.PI;\n    const halfTheta = theta * 0.5;\n    const s = Math.sin(halfTheta);\n    const w = Math.cos(halfTheta);\n    out.set(axis.x * s, axis.y * s, axis.z * s, w);\n    return out;\n  }\n  function packSint8Bytes(b0, b1, b2, b3) {\n    const clampedB0 = Math.max(-127, Math.min(127, b0 * 127));\n    const clampedB1 = Math.max(-127, Math.min(127, b1 * 127));\n    const clampedB2 = Math.max(-127, Math.min(127, b2 * 127));\n    const clampedB3 = Math.max(-127, Math.min(127, b3 * 127));\n    return clampedB0 & 255 | (clampedB1 & 255) << 8 | (clampedB2 & 255) << 16 | (clampedB3 & 255) << 24;\n  }\n  function encodeSh1Rgb(sh1Array, index, sh1Rgb) {\n    const base = index * 2;\n    for (let i2 = 0; i2 < 9; ++i2) {\n      const value = Math.max(-63, Math.min(63, sh1Rgb[i2] * 63)) & 127;\n      const bitStart = i2 * 7;\n      const bitEnd = bitStart + 7;\n      const wordStart = Math.floor(bitStart / 32);\n      const bitOffset = bitStart - wordStart * 32;\n      const firstWord = value << bitOffset & 4294967295;\n      sh1Array[base + wordStart] |= firstWord;\n      if (bitEnd > wordStart * 32 + 32) {\n        const secondWord = value >>> 32 - bitOffset & 4294967295;\n        sh1Array[base + wordStart + 1] |= secondWord;\n      }\n    }\n  }\n  function encodeSh2Rgb(sh2Array, index, sh2Rgb) {\n    sh2Array[index * 4 + 0] = packSint8Bytes(\n      sh2Rgb[0],\n      sh2Rgb[1],\n      sh2Rgb[2],\n      sh2Rgb[3]\n    );\n    sh2Array[index * 4 + 1] = packSint8Bytes(\n      sh2Rgb[4],\n      sh2Rgb[5],\n      sh2Rgb[6],\n      sh2Rgb[7]\n    );\n    sh2Array[index * 4 + 2] = packSint8Bytes(\n      sh2Rgb[8],\n      sh2Rgb[9],\n      sh2Rgb[10],\n      sh2Rgb[11]\n    );\n    sh2Array[index * 4 + 3] = packSint8Bytes(\n      sh2Rgb[12],\n      sh2Rgb[13],\n      sh2Rgb[14],\n      0\n    );\n  }\n  function encodeSh3Rgb(sh3Array, index, sh3Rgb) {\n    const base = index * 4;\n    for (let i2 = 0; i2 < 21; ++i2) {\n      const value = Math.max(-31, Math.min(31, sh3Rgb[i2] * 31)) & 63;\n      const bitStart = i2 * 6;\n      const bitEnd = bitStart + 6;\n      const wordStart = Math.floor(bitStart / 32);\n      const bitOffset = bitStart - wordStart * 32;\n      const firstWord = value << bitOffset & 4294967295;\n      sh3Array[base + wordStart] |= firstWord;\n      if (bitEnd > wordStart * 32 + 32) {\n        const secondWord = value >>> 32 - bitOffset & 4294967295;\n        sh3Array[base + wordStart + 1] |= secondWord;\n      }\n    }\n  }\n  function decompressPartialGzip(fileBytes, numBytes) {\n    const chunks = [];\n    let totalBytes = 0;\n    let result = null;\n    const gunzip = new Gunzip((data, final) => {\n      chunks.push(data);\n      totalBytes += data.length;\n      if (final || totalBytes >= numBytes) {\n        const allBytes = new Uint8Array(totalBytes);\n        let offset2 = 0;\n        for (const chunk of chunks) {\n          allBytes.set(chunk, offset2);\n          offset2 += chunk.length;\n        }\n        result = allBytes.slice(0, numBytes);\n      }\n    });\n    const CHUNK_SIZE = 1024;\n    let offset = 0;\n    while (result == null && offset < fileBytes.length) {\n      const chunk = fileBytes.slice(offset, offset + CHUNK_SIZE);\n      gunzip.push(chunk, false);\n      offset += CHUNK_SIZE;\n    }\n    if (result == null) {\n      gunzip.push(new Uint8Array(), true);\n      if (result == null) {\n        throw new Error("Failed to decompress partial gzip");\n      }\n    }\n    return result;\n  }\n  class GunzipReader {\n    constructor({\n      fileBytes,\n      chunkBytes = 64 * 1024\n    }) {\n      this.fileBytes = fileBytes;\n      this.chunkBytes = chunkBytes;\n      this.offset = 0;\n      this.chunks = [];\n      this.totalBytes = 0;\n      this.gunzip = new Gunzip((chunk, _final) => {\n        this.chunks.push(chunk);\n        this.totalBytes += chunk.length;\n      });\n    }\n    read(numBytes) {\n      while (this.totalBytes < numBytes && this.offset < this.fileBytes.length) {\n        const end = Math.min(\n          this.offset + this.chunkBytes,\n          this.fileBytes.length\n        );\n        this.gunzip.push(this.fileBytes.subarray(this.offset, end), false);\n        this.offset = end;\n      }\n      if (this.totalBytes < numBytes && this.offset >= this.fileBytes.length) {\n        this.gunzip.push(new Uint8Array(0), true);\n      }\n      if (this.totalBytes < numBytes) {\n        throw new Error(\n          `Unexpected EOF: needed ${numBytes}, got ${this.totalBytes}`\n        );\n      }\n      const allBytes = new Uint8Array(this.totalBytes);\n      let outOffset = 0;\n      for (const chunk of this.chunks) {\n        allBytes.set(chunk, outOffset);\n        outOffset += chunk.length;\n      }\n      const result = allBytes.subarray(0, numBytes);\n      this.chunks = [allBytes.subarray(numBytes)];\n      this.totalBytes -= numBytes;\n      return result;\n    }\n  }\n  function decodeAntiSplat(fileBytes, initNumSplats, splatCallback) {\n    const numSplats = Math.floor(fileBytes.length / 32);\n    if (numSplats * 32 !== fileBytes.length) {\n      throw new Error("Invalid .splat file size");\n    }\n    initNumSplats(numSplats);\n    const f32 = new Float32Array(fileBytes.buffer);\n    for (let i2 = 0; i2 < numSplats; ++i2) {\n      const i322 = i2 * 32;\n      const i8 = i2 * 8;\n      const x2 = f32[i8 + 0];\n      const y = f32[i8 + 1];\n      const z = f32[i8 + 2];\n      const scaleX = f32[i8 + 3];\n      const scaleY = f32[i8 + 4];\n      const scaleZ = f32[i8 + 5];\n      const r = fileBytes[i322 + 24] / 255;\n      const g = fileBytes[i322 + 25] / 255;\n      const b = fileBytes[i322 + 26] / 255;\n      const opacity = fileBytes[i322 + 27] / 255;\n      const quatW = (fileBytes[i322 + 28] - 128) / 128;\n      const quatX = (fileBytes[i322 + 29] - 128) / 128;\n      const quatY = (fileBytes[i322 + 30] - 128) / 128;\n      const quatZ = (fileBytes[i322 + 31] - 128) / 128;\n      splatCallback(\n        i2,\n        x2,\n        y,\n        z,\n        scaleX,\n        scaleY,\n        scaleZ,\n        quatX,\n        quatY,\n        quatZ,\n        quatW,\n        opacity,\n        r,\n        g,\n        b\n      );\n    }\n  }\n  function unpackAntiSplat(fileBytes) {\n    let numSplats = 0;\n    let maxSplats = 0;\n    let packedArray = new Uint32Array(0);\n    decodeAntiSplat(\n      fileBytes,\n      (cbNumSplats) => {\n        numSplats = cbNumSplats;\n        maxSplats = computeMaxSplats(numSplats);\n        packedArray = new Uint32Array(maxSplats * 4);\n      },\n      (index, x2, y, z, scaleX, scaleY, scaleZ, quatX, quatY, quatZ, quatW, opacity, r, g, b) => {\n        setPackedSplat(\n          packedArray,\n          index,\n          x2,\n          y,\n          z,\n          scaleX,\n          scaleY,\n          scaleZ,\n          quatX,\n          quatY,\n          quatZ,\n          quatW,\n          opacity,\n          r,\n          g,\n          b\n        );\n      }\n    );\n    return { packedArray, numSplats };\n  }\n  const KSPLAT_COMPRESSION = {\n    0: {\n      bytesPerCenter: 12,\n      bytesPerScale: 12,\n      bytesPerRotation: 16,\n      bytesPerColor: 4,\n      bytesPerSphericalHarmonicsComponent: 4,\n      scaleOffsetBytes: 12,\n      rotationOffsetBytes: 24,\n      colorOffsetBytes: 40,\n      sphericalHarmonicsOffsetBytes: 44,\n      scaleRange: 1\n    },\n    1: {\n      bytesPerCenter: 6,\n      bytesPerScale: 6,\n      bytesPerRotation: 8,\n      bytesPerColor: 4,\n      bytesPerSphericalHarmonicsComponent: 2,\n      scaleOffsetBytes: 6,\n      rotationOffsetBytes: 12,\n      colorOffsetBytes: 20,\n      sphericalHarmonicsOffsetBytes: 24,\n      scaleRange: 32767\n    },\n    2: {\n      bytesPerCenter: 6,\n      bytesPerScale: 6,\n      bytesPerRotation: 8,\n      bytesPerColor: 4,\n      bytesPerSphericalHarmonicsComponent: 1,\n      scaleOffsetBytes: 6,\n      rotationOffsetBytes: 12,\n      colorOffsetBytes: 20,\n      sphericalHarmonicsOffsetBytes: 24,\n      scaleRange: 32767\n    }\n  };\n  const KSPLAT_SH_DEGREE_TO_COMPONENTS = {\n    0: 0,\n    1: 9,\n    2: 24,\n    3: 45\n  };\n  function decodeKsplat(fileBytes, initNumSplats, splatCallback, shCallback) {\n    var _a2;\n    const HEADER_BYTES = 4096;\n    const SECTION_BYTES = 1024;\n    let headerOffset = 0;\n    const header = new DataView(fileBytes.buffer, headerOffset, HEADER_BYTES);\n    headerOffset += HEADER_BYTES;\n    const versionMajor = header.getUint8(0);\n    const versionMinor = header.getUint8(1);\n    if (versionMajor !== 0 || versionMinor < 1) {\n      throw new Error(\n        `Unsupported .ksplat version: ${versionMajor}.${versionMinor}`\n      );\n    }\n    const maxSectionCount = header.getUint32(4, true);\n    header.getUint32(16, true);\n    const compressionLevel = header.getUint16(20, true);\n    if (compressionLevel < 0 || compressionLevel > 2) {\n      throw new Error(`Invalid .ksplat compression level: ${compressionLevel}`);\n    }\n    const minSphericalHarmonicsCoeff = header.getFloat32(36, true) || -1.5;\n    const maxSphericalHarmonicsCoeff = header.getFloat32(40, true) || 1.5;\n    let sectionBase = HEADER_BYTES + maxSectionCount * SECTION_BYTES;\n    for (let section = 0; section < maxSectionCount; ++section) {\n      let getSh = function(splatOffset, component) {\n        if (compressionLevel === 0) {\n          return data.getFloat32(\n            splatOffset + sphericalHarmonicsOffsetBytes + component * 4,\n            true\n          );\n        }\n        if (compressionLevel === 1) {\n          return fromHalf(\n            data.getUint16(\n              splatOffset + sphericalHarmonicsOffsetBytes + component * 2,\n              true\n            )\n          );\n        }\n        const t = data.getUint8(splatOffset + sphericalHarmonicsOffsetBytes + component) / 255;\n        return minSphericalHarmonicsCoeff + t * (maxSphericalHarmonicsCoeff - minSphericalHarmonicsCoeff);\n      };\n      const section2 = new DataView(fileBytes.buffer, headerOffset, SECTION_BYTES);\n      headerOffset += SECTION_BYTES;\n      const sectionSplatCount = section2.getUint32(0, true);\n      const sectionMaxSplatCount = section2.getUint32(4, true);\n      const bucketSize = section2.getUint32(8, true);\n      const bucketCount = section2.getUint32(12, true);\n      const bucketBlockSize = section2.getFloat32(16, true);\n      const bucketStorageSizeBytes = section2.getUint16(20, true);\n      const compressionScaleRange = (section2.getUint32(24, true) || ((_a2 = KSPLAT_COMPRESSION[compressionLevel]) == null ? void 0 : _a2.scaleRange)) ?? 1;\n      const fullBucketCount = section2.getUint32(32, true);\n      const fullBucketSplats = fullBucketCount * bucketSize;\n      const partiallyFilledBucketCount = section2.getUint32(36, true);\n      const bucketsMetaDataSizeBytes = partiallyFilledBucketCount * 4;\n      const bucketsStorageSizeBytes = bucketStorageSizeBytes * bucketCount + bucketsMetaDataSizeBytes;\n      const sphericalHarmonicsDegree = section2.getUint16(40, true);\n      const shComponents = KSPLAT_SH_DEGREE_TO_COMPONENTS[sphericalHarmonicsDegree];\n      const {\n        bytesPerCenter,\n        bytesPerScale,\n        bytesPerRotation,\n        bytesPerColor,\n        bytesPerSphericalHarmonicsComponent,\n        scaleOffsetBytes,\n        rotationOffsetBytes,\n        colorOffsetBytes,\n        sphericalHarmonicsOffsetBytes\n      } = KSPLAT_COMPRESSION[compressionLevel];\n      const bytesPerSplat = bytesPerCenter + bytesPerScale + bytesPerRotation + bytesPerColor + shComponents * bytesPerSphericalHarmonicsComponent;\n      const splatDataStorageSizeBytes = bytesPerSplat * sectionMaxSplatCount;\n      const storageSizeBytes = splatDataStorageSizeBytes + bucketsStorageSizeBytes;\n      const sh1Index = [0, 3, 6, 1, 4, 7, 2, 5, 8];\n      const sh2Index = [\n        9,\n        14,\n        19,\n        10,\n        15,\n        20,\n        11,\n        16,\n        21,\n        12,\n        17,\n        22,\n        13,\n        18,\n        23\n      ];\n      const sh3Index = [\n        24,\n        31,\n        38,\n        25,\n        32,\n        39,\n        26,\n        33,\n        40,\n        27,\n        34,\n        41,\n        28,\n        35,\n        42,\n        29,\n        36,\n        43,\n        30,\n        37,\n        44\n      ];\n      const sh1 = sphericalHarmonicsDegree >= 1 ? new Float32Array(3 * 3) : void 0;\n      const sh2 = sphericalHarmonicsDegree >= 2 ? new Float32Array(5 * 3) : void 0;\n      const sh3 = sphericalHarmonicsDegree >= 3 ? new Float32Array(7 * 3) : void 0;\n      const compressionScaleFactor = bucketBlockSize / 2 / compressionScaleRange;\n      const bucketsBase = sectionBase + bucketsMetaDataSizeBytes;\n      const dataBase = sectionBase + bucketsStorageSizeBytes;\n      const data = new DataView(\n        fileBytes.buffer,\n        dataBase,\n        splatDataStorageSizeBytes\n      );\n      const bucketArray = new Float32Array(\n        fileBytes.buffer,\n        bucketsBase,\n        bucketCount * 3\n      );\n      const partiallyFilledBucketLengths = new Uint32Array(\n        fileBytes.buffer,\n        sectionBase,\n        partiallyFilledBucketCount\n      );\n      let partialBucketIndex = fullBucketCount;\n      let partialBucketBase = fullBucketSplats;\n      for (let i2 = 0; i2 < sectionSplatCount; ++i2) {\n        const splatOffset = i2 * bytesPerSplat;\n        let bucketIndex;\n        if (i2 < fullBucketSplats) {\n          bucketIndex = Math.floor(i2 / bucketSize);\n        } else {\n          const bucketLength = partiallyFilledBucketLengths[partialBucketIndex - fullBucketCount];\n          if (i2 >= partialBucketBase + bucketLength) {\n            partialBucketIndex += 1;\n            partialBucketBase += bucketLength;\n          }\n          bucketIndex = partialBucketIndex;\n        }\n        const x2 = compressionLevel === 0 ? data.getFloat32(splatOffset + 0, true) : (data.getUint16(splatOffset + 0, true) - compressionScaleRange) * compressionScaleFactor + bucketArray[3 * bucketIndex + 0];\n        const y = compressionLevel === 0 ? data.getFloat32(splatOffset + 4, true) : (data.getUint16(splatOffset + 2, true) - compressionScaleRange) * compressionScaleFactor + bucketArray[3 * bucketIndex + 1];\n        const z = compressionLevel === 0 ? data.getFloat32(splatOffset + 8, true) : (data.getUint16(splatOffset + 4, true) - compressionScaleRange) * compressionScaleFactor + bucketArray[3 * bucketIndex + 2];\n        const scaleX = compressionLevel === 0 ? data.getFloat32(splatOffset + scaleOffsetBytes + 0, true) : fromHalf(data.getUint16(splatOffset + scaleOffsetBytes + 0, true));\n        const scaleY = compressionLevel === 0 ? data.getFloat32(splatOffset + scaleOffsetBytes + 4, true) : fromHalf(data.getUint16(splatOffset + scaleOffsetBytes + 2, true));\n        const scaleZ = compressionLevel === 0 ? data.getFloat32(splatOffset + scaleOffsetBytes + 8, true) : fromHalf(data.getUint16(splatOffset + scaleOffsetBytes + 4, true));\n        const quatW = compressionLevel === 0 ? data.getFloat32(splatOffset + rotationOffsetBytes + 0, true) : fromHalf(\n          data.getUint16(splatOffset + rotationOffsetBytes + 0, true)\n        );\n        const quatX = compressionLevel === 0 ? data.getFloat32(splatOffset + rotationOffsetBytes + 4, true) : fromHalf(\n          data.getUint16(splatOffset + rotationOffsetBytes + 2, true)\n        );\n        const quatY = compressionLevel === 0 ? data.getFloat32(splatOffset + rotationOffsetBytes + 8, true) : fromHalf(\n          data.getUint16(splatOffset + rotationOffsetBytes + 4, true)\n        );\n        const quatZ = compressionLevel === 0 ? data.getFloat32(splatOffset + rotationOffsetBytes + 12, true) : fromHalf(\n          data.getUint16(splatOffset + rotationOffsetBytes + 6, true)\n        );\n        const r = data.getUint8(splatOffset + colorOffsetBytes + 0) / 255;\n        const g = data.getUint8(splatOffset + colorOffsetBytes + 1) / 255;\n        const b = data.getUint8(splatOffset + colorOffsetBytes + 2) / 255;\n        const opacity = data.getUint8(splatOffset + colorOffsetBytes + 3) / 255;\n        splatCallback(\n          i2,\n          x2,\n          y,\n          z,\n          scaleX,\n          scaleY,\n          scaleZ,\n          quatX,\n          quatY,\n          quatZ,\n          quatW,\n          opacity,\n          r,\n          g,\n          b\n        );\n        if (sphericalHarmonicsDegree >= 1 && sh1) {\n          for (const [i22, key] of sh1Index.entries()) {\n            sh1[i22] = getSh(splatOffset, key);\n          }\n          if (sh2) {\n            for (const [i22, key] of sh2Index.entries()) {\n              sh2[i22] = getSh(splatOffset, key);\n            }\n          }\n          if (sh3) {\n            for (const [i22, key] of sh3Index.entries()) {\n              sh3[i22] = getSh(splatOffset, key);\n            }\n          }\n          shCallback == null ? void 0 : shCallback(i2, sh1, sh2, sh3);\n        }\n      }\n      sectionBase += storageSizeBytes;\n    }\n  }\n  function unpackKsplat(fileBytes) {\n    var _a2;\n    const HEADER_BYTES = 4096;\n    const SECTION_BYTES = 1024;\n    let headerOffset = 0;\n    const header = new DataView(fileBytes.buffer, headerOffset, HEADER_BYTES);\n    headerOffset += HEADER_BYTES;\n    const versionMajor = header.getUint8(0);\n    const versionMinor = header.getUint8(1);\n    if (versionMajor !== 0 || versionMinor < 1) {\n      throw new Error(\n        `Unsupported .ksplat version: ${versionMajor}.${versionMinor}`\n      );\n    }\n    const maxSectionCount = header.getUint32(4, true);\n    const splatCount = header.getUint32(16, true);\n    const compressionLevel = header.getUint16(20, true);\n    if (compressionLevel < 0 || compressionLevel > 2) {\n      throw new Error(`Invalid .ksplat compression level: ${compressionLevel}`);\n    }\n    const minSphericalHarmonicsCoeff = header.getFloat32(36, true) || -1.5;\n    const maxSphericalHarmonicsCoeff = header.getFloat32(40, true) || 1.5;\n    const numSplats = splatCount;\n    const maxSplats = computeMaxSplats(numSplats);\n    const packedArray = new Uint32Array(maxSplats * 4);\n    const extra = {};\n    let sectionBase = HEADER_BYTES + maxSectionCount * SECTION_BYTES;\n    for (let section = 0; section < maxSectionCount; ++section) {\n      let getSh = function(splatOffset, component) {\n        if (compressionLevel === 0) {\n          return data.getFloat32(\n            splatOffset + sphericalHarmonicsOffsetBytes + component * 4,\n            true\n          );\n        }\n        if (compressionLevel === 1) {\n          return fromHalf(\n            data.getUint16(\n              splatOffset + sphericalHarmonicsOffsetBytes + component * 2,\n              true\n            )\n          );\n        }\n        const t = data.getUint8(splatOffset + sphericalHarmonicsOffsetBytes + component) / 255;\n        return minSphericalHarmonicsCoeff + t * (maxSphericalHarmonicsCoeff - minSphericalHarmonicsCoeff);\n      };\n      const section2 = new DataView(fileBytes.buffer, headerOffset, SECTION_BYTES);\n      headerOffset += SECTION_BYTES;\n      const sectionSplatCount = section2.getUint32(0, true);\n      const sectionMaxSplatCount = section2.getUint32(4, true);\n      const bucketSize = section2.getUint32(8, true);\n      const bucketCount = section2.getUint32(12, true);\n      const bucketBlockSize = section2.getFloat32(16, true);\n      const bucketStorageSizeBytes = section2.getUint16(20, true);\n      const compressionScaleRange = (section2.getUint32(24, true) || ((_a2 = KSPLAT_COMPRESSION[compressionLevel]) == null ? void 0 : _a2.scaleRange)) ?? 1;\n      const fullBucketCount = section2.getUint32(32, true);\n      const fullBucketSplats = fullBucketCount * bucketSize;\n      const partiallyFilledBucketCount = section2.getUint32(36, true);\n      const bucketsMetaDataSizeBytes = partiallyFilledBucketCount * 4;\n      const bucketsStorageSizeBytes = bucketStorageSizeBytes * bucketCount + bucketsMetaDataSizeBytes;\n      const sphericalHarmonicsDegree = section2.getUint16(40, true);\n      const shComponents = KSPLAT_SH_DEGREE_TO_COMPONENTS[sphericalHarmonicsDegree];\n      const {\n        bytesPerCenter,\n        bytesPerScale,\n        bytesPerRotation,\n        bytesPerColor,\n        bytesPerSphericalHarmonicsComponent,\n        scaleOffsetBytes,\n        rotationOffsetBytes,\n        colorOffsetBytes,\n        sphericalHarmonicsOffsetBytes\n      } = KSPLAT_COMPRESSION[compressionLevel];\n      const bytesPerSplat = bytesPerCenter + bytesPerScale + bytesPerRotation + bytesPerColor + shComponents * bytesPerSphericalHarmonicsComponent;\n      const splatDataStorageSizeBytes = bytesPerSplat * sectionMaxSplatCount;\n      const storageSizeBytes = splatDataStorageSizeBytes + bucketsStorageSizeBytes;\n      const sh1Index = [0, 3, 6, 1, 4, 7, 2, 5, 8];\n      const sh2Index = [\n        9,\n        14,\n        19,\n        10,\n        15,\n        20,\n        11,\n        16,\n        21,\n        12,\n        17,\n        22,\n        13,\n        18,\n        23\n      ];\n      const sh3Index = [\n        24,\n        31,\n        38,\n        25,\n        32,\n        39,\n        26,\n        33,\n        40,\n        27,\n        34,\n        41,\n        28,\n        35,\n        42,\n        29,\n        36,\n        43,\n        30,\n        37,\n        44\n      ];\n      const sh1 = sphericalHarmonicsDegree >= 1 ? new Float32Array(3 * 3) : void 0;\n      const sh2 = sphericalHarmonicsDegree >= 2 ? new Float32Array(5 * 3) : void 0;\n      const sh3 = sphericalHarmonicsDegree >= 3 ? new Float32Array(7 * 3) : void 0;\n      const compressionScaleFactor = bucketBlockSize / 2 / compressionScaleRange;\n      const bucketsBase = sectionBase + bucketsMetaDataSizeBytes;\n      const dataBase = sectionBase + bucketsStorageSizeBytes;\n      const data = new DataView(\n        fileBytes.buffer,\n        dataBase,\n        splatDataStorageSizeBytes\n      );\n      const bucketArray = new Float32Array(\n        fileBytes.buffer,\n        bucketsBase,\n        bucketCount * 3\n      );\n      const partiallyFilledBucketLengths = new Uint32Array(\n        fileBytes.buffer,\n        sectionBase,\n        partiallyFilledBucketCount\n      );\n      let partialBucketIndex = fullBucketCount;\n      let partialBucketBase = fullBucketSplats;\n      for (let i2 = 0; i2 < sectionSplatCount; ++i2) {\n        const splatOffset = i2 * bytesPerSplat;\n        let bucketIndex;\n        if (i2 < fullBucketSplats) {\n          bucketIndex = Math.floor(i2 / bucketSize);\n        } else {\n          const bucketLength = partiallyFilledBucketLengths[partialBucketIndex - fullBucketCount];\n          if (i2 >= partialBucketBase + bucketLength) {\n            partialBucketIndex += 1;\n            partialBucketBase += bucketLength;\n          }\n          bucketIndex = partialBucketIndex;\n        }\n        const x2 = compressionLevel === 0 ? data.getFloat32(splatOffset + 0, true) : (data.getUint16(splatOffset + 0, true) - compressionScaleRange) * compressionScaleFactor + bucketArray[3 * bucketIndex + 0];\n        const y = compressionLevel === 0 ? data.getFloat32(splatOffset + 4, true) : (data.getUint16(splatOffset + 2, true) - compressionScaleRange) * compressionScaleFactor + bucketArray[3 * bucketIndex + 1];\n        const z = compressionLevel === 0 ? data.getFloat32(splatOffset + 8, true) : (data.getUint16(splatOffset + 4, true) - compressionScaleRange) * compressionScaleFactor + bucketArray[3 * bucketIndex + 2];\n        const scaleX = compressionLevel === 0 ? data.getFloat32(splatOffset + scaleOffsetBytes + 0, true) : fromHalf(data.getUint16(splatOffset + scaleOffsetBytes + 0, true));\n        const scaleY = compressionLevel === 0 ? data.getFloat32(splatOffset + scaleOffsetBytes + 4, true) : fromHalf(data.getUint16(splatOffset + scaleOffsetBytes + 2, true));\n        const scaleZ = compressionLevel === 0 ? data.getFloat32(splatOffset + scaleOffsetBytes + 8, true) : fromHalf(data.getUint16(splatOffset + scaleOffsetBytes + 4, true));\n        const quatW = compressionLevel === 0 ? data.getFloat32(splatOffset + rotationOffsetBytes + 0, true) : fromHalf(\n          data.getUint16(splatOffset + rotationOffsetBytes + 0, true)\n        );\n        const quatX = compressionLevel === 0 ? data.getFloat32(splatOffset + rotationOffsetBytes + 4, true) : fromHalf(\n          data.getUint16(splatOffset + rotationOffsetBytes + 2, true)\n        );\n        const quatY = compressionLevel === 0 ? data.getFloat32(splatOffset + rotationOffsetBytes + 8, true) : fromHalf(\n          data.getUint16(splatOffset + rotationOffsetBytes + 4, true)\n        );\n        const quatZ = compressionLevel === 0 ? data.getFloat32(splatOffset + rotationOffsetBytes + 12, true) : fromHalf(\n          data.getUint16(splatOffset + rotationOffsetBytes + 6, true)\n        );\n        const r = data.getUint8(splatOffset + colorOffsetBytes + 0) / 255;\n        const g = data.getUint8(splatOffset + colorOffsetBytes + 1) / 255;\n        const b = data.getUint8(splatOffset + colorOffsetBytes + 2) / 255;\n        const opacity = data.getUint8(splatOffset + colorOffsetBytes + 3) / 255;\n        setPackedSplat(\n          packedArray,\n          i2,\n          x2,\n          y,\n          z,\n          scaleX,\n          scaleY,\n          scaleZ,\n          quatX,\n          quatY,\n          quatZ,\n          quatW,\n          opacity,\n          r,\n          g,\n          b\n        );\n        if (sphericalHarmonicsDegree >= 1) {\n          if (sh1) {\n            if (!extra.sh1) {\n              extra.sh1 = new Uint32Array(numSplats * 2);\n            }\n            for (const [i22, key] of sh1Index.entries()) {\n              sh1[i22] = getSh(splatOffset, key);\n            }\n            encodeSh1Rgb(extra.sh1, i2, sh1);\n          }\n          if (sh2) {\n            if (!extra.sh2) {\n              extra.sh2 = new Uint32Array(numSplats * 4);\n            }\n            for (const [i22, key] of sh2Index.entries()) {\n              sh2[i22] = getSh(splatOffset, key);\n            }\n            encodeSh2Rgb(extra.sh2, i2, sh2);\n          }\n          if (sh3) {\n            if (!extra.sh3) {\n              extra.sh3 = new Uint32Array(numSplats * 4);\n            }\n            for (const [i22, key] of sh3Index.entries()) {\n              sh3[i22] = getSh(splatOffset, key);\n            }\n            encodeSh3Rgb(extra.sh3, i2, sh3);\n          }\n        }\n      }\n      sectionBase += storageSizeBytes;\n    }\n    return { packedArray, numSplats, extra };\n  }\n  function initEmscriptenModule(moduleFactory, wasmModule, moduleOptionOverrides = {}) {\n    let instantiateWasm;\n    if (wasmModule) {\n      instantiateWasm = (imports, callback) => {\n        const instance = new WebAssembly.Instance(wasmModule, imports);\n        callback(instance);\n        return instance.exports;\n      };\n    }\n    return moduleFactory({\n      // Just to be safe, don\'t automatically invoke any wasm functions\n      noInitialRun: true,\n      instantiateWasm,\n      ...moduleOptionOverrides\n    });\n  }\n  var Module = (() => {\n    var _scriptDir = self.location.href;\n    return function(Module2 = {}) {\n      var Module2 = typeof Module2 != "undefined" ? Module2 : {};\n      var readyPromiseResolve, readyPromiseReject;\n      Module2["ready"] = new Promise(function(resolve, reject) {\n        readyPromiseResolve = resolve;\n        readyPromiseReject = reject;\n      });\n      const isServiceWorker = globalThis.ServiceWorkerGlobalScope !== void 0;\n      const isRunningInCloudFlareWorkers = isServiceWorker && typeof self !== "undefined" && globalThis.caches && globalThis.caches.default !== void 0;\n      const isRunningInNode = typeof process === "object" && process.release && process.release.name === "node";\n      if (isRunningInCloudFlareWorkers || isRunningInNode) {\n        if (!globalThis.ImageData) {\n          globalThis.ImageData = class ImageData {\n            constructor(data, width, height) {\n              this.data = data;\n              this.width = width;\n              this.height = height;\n            }\n          };\n        }\n        if (self.location.href === void 0) {\n          self.location.href = "https://localhost";\n        }\n        if (typeof self !== "undefined" && self.location === void 0) {\n          self.location = { href: "" };\n        }\n      }\n      var moduleOverrides = Object.assign({}, Module2);\n      var ENVIRONMENT_IS_WEB = typeof window == "object";\n      var ENVIRONMENT_IS_WORKER = typeof importScripts == "function";\n      typeof process == "object" && typeof process.versions == "object" && typeof process.versions.node == "string";\n      var scriptDirectory = "";\n      function locateFile(path) {\n        if (Module2["locateFile"]) {\n          return Module2["locateFile"](path, scriptDirectory);\n        }\n        return scriptDirectory + path;\n      }\n      var readBinary;\n      if (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER) {\n        if (ENVIRONMENT_IS_WORKER) {\n          scriptDirectory = self.location.href;\n        } else if (typeof document != "undefined" && document.currentScript) {\n          scriptDirectory = document.currentScript.src;\n        }\n        if (_scriptDir) {\n          scriptDirectory = _scriptDir;\n        }\n        if (scriptDirectory.indexOf("blob:") !== 0) {\n          scriptDirectory = scriptDirectory.substr(0, scriptDirectory.replace(/[?#].*/, "").lastIndexOf("/") + 1);\n        } else {\n          scriptDirectory = "";\n        }\n        {\n          if (ENVIRONMENT_IS_WORKER) {\n            readBinary = (url) => {\n              var xhr = new XMLHttpRequest();\n              xhr.open("GET", url, false);\n              xhr.responseType = "arraybuffer";\n              xhr.send(null);\n              return new Uint8Array(xhr.response);\n            };\n          }\n        }\n      }\n      Module2["print"] || console.log.bind(console);\n      var err2 = Module2["printErr"] || console.warn.bind(console);\n      Object.assign(Module2, moduleOverrides);\n      moduleOverrides = null;\n      if (Module2["arguments"]) Module2["arguments"];\n      if (Module2["thisProgram"]) Module2["thisProgram"];\n      if (Module2["quit"]) Module2["quit"];\n      var wasmBinary;\n      if (Module2["wasmBinary"]) wasmBinary = Module2["wasmBinary"];\n      Module2["noExitRuntime"] || true;\n      if (typeof WebAssembly != "object") {\n        abort("no native wasm support detected");\n      }\n      var wasmMemory;\n      var ABORT = false;\n      function UTF8ArrayToString(heapOrArray, idx, maxBytesToRead) {\n        var endIdx = idx + maxBytesToRead;\n        var str = "";\n        while (!(idx >= endIdx)) {\n          var u0 = heapOrArray[idx++];\n          if (!u0) return str;\n          if (!(u0 & 128)) {\n            str += String.fromCharCode(u0);\n            continue;\n          }\n          var u1 = heapOrArray[idx++] & 63;\n          if ((u0 & 224) == 192) {\n            str += String.fromCharCode((u0 & 31) << 6 | u1);\n            continue;\n          }\n          var u2 = heapOrArray[idx++] & 63;\n          if ((u0 & 240) == 224) {\n            u0 = (u0 & 15) << 12 | u1 << 6 | u2;\n          } else {\n            u0 = (u0 & 7) << 18 | u1 << 12 | u2 << 6 | heapOrArray[idx++] & 63;\n          }\n          if (u0 < 65536) {\n            str += String.fromCharCode(u0);\n          } else {\n            var ch = u0 - 65536;\n            str += String.fromCharCode(55296 | ch >> 10, 56320 | ch & 1023);\n          }\n        }\n        return str;\n      }\n      function UTF8ToString(ptr, maxBytesToRead) {\n        return ptr ? UTF8ArrayToString(HEAPU8, ptr, maxBytesToRead) : "";\n      }\n      function stringToUTF8Array(str, heap, outIdx, maxBytesToWrite) {\n        if (!(maxBytesToWrite > 0)) return 0;\n        var startIdx = outIdx;\n        var endIdx = outIdx + maxBytesToWrite - 1;\n        for (var i2 = 0; i2 < str.length; ++i2) {\n          var u = str.charCodeAt(i2);\n          if (u >= 55296 && u <= 57343) {\n            var u1 = str.charCodeAt(++i2);\n            u = 65536 + ((u & 1023) << 10) | u1 & 1023;\n          }\n          if (u <= 127) {\n            if (outIdx >= endIdx) break;\n            heap[outIdx++] = u;\n          } else if (u <= 2047) {\n            if (outIdx + 1 >= endIdx) break;\n            heap[outIdx++] = 192 | u >> 6;\n            heap[outIdx++] = 128 | u & 63;\n          } else if (u <= 65535) {\n            if (outIdx + 2 >= endIdx) break;\n            heap[outIdx++] = 224 | u >> 12;\n            heap[outIdx++] = 128 | u >> 6 & 63;\n            heap[outIdx++] = 128 | u & 63;\n          } else {\n            if (outIdx + 3 >= endIdx) break;\n            heap[outIdx++] = 240 | u >> 18;\n            heap[outIdx++] = 128 | u >> 12 & 63;\n            heap[outIdx++] = 128 | u >> 6 & 63;\n            heap[outIdx++] = 128 | u & 63;\n          }\n        }\n        heap[outIdx] = 0;\n        return outIdx - startIdx;\n      }\n      function stringToUTF8(str, outPtr, maxBytesToWrite) {\n        return stringToUTF8Array(str, HEAPU8, outPtr, maxBytesToWrite);\n      }\n      function lengthBytesUTF8(str) {\n        var len = 0;\n        for (var i2 = 0; i2 < str.length; ++i2) {\n          var c = str.charCodeAt(i2);\n          if (c <= 127) {\n            len++;\n          } else if (c <= 2047) {\n            len += 2;\n          } else if (c >= 55296 && c <= 57343) {\n            len += 4;\n            ++i2;\n          } else {\n            len += 3;\n          }\n        }\n        return len;\n      }\n      var HEAP8, HEAPU8, HEAP16, HEAPU16, HEAP32, HEAPU32, HEAPF32, HEAPF64;\n      function updateMemoryViews() {\n        var b = wasmMemory.buffer;\n        Module2["HEAP8"] = HEAP8 = new Int8Array(b);\n        Module2["HEAP16"] = HEAP16 = new Int16Array(b);\n        Module2["HEAP32"] = HEAP32 = new Int32Array(b);\n        Module2["HEAPU8"] = HEAPU8 = new Uint8Array(b);\n        Module2["HEAPU16"] = HEAPU16 = new Uint16Array(b);\n        Module2["HEAPU32"] = HEAPU32 = new Uint32Array(b);\n        Module2["HEAPF32"] = HEAPF32 = new Float32Array(b);\n        Module2["HEAPF64"] = HEAPF64 = new Float64Array(b);\n      }\n      var wasmTable;\n      var __ATPRERUN__ = [];\n      var __ATINIT__ = [];\n      var __ATPOSTRUN__ = [];\n      function preRun() {\n        if (Module2["preRun"]) {\n          if (typeof Module2["preRun"] == "function") Module2["preRun"] = [Module2["preRun"]];\n          while (Module2["preRun"].length) {\n            addOnPreRun(Module2["preRun"].shift());\n          }\n        }\n        callRuntimeCallbacks(__ATPRERUN__);\n      }\n      function initRuntime() {\n        callRuntimeCallbacks(__ATINIT__);\n      }\n      function postRun() {\n        if (Module2["postRun"]) {\n          if (typeof Module2["postRun"] == "function") Module2["postRun"] = [Module2["postRun"]];\n          while (Module2["postRun"].length) {\n            addOnPostRun(Module2["postRun"].shift());\n          }\n        }\n        callRuntimeCallbacks(__ATPOSTRUN__);\n      }\n      function addOnPreRun(cb) {\n        __ATPRERUN__.unshift(cb);\n      }\n      function addOnInit(cb) {\n        __ATINIT__.unshift(cb);\n      }\n      function addOnPostRun(cb) {\n        __ATPOSTRUN__.unshift(cb);\n      }\n      var runDependencies = 0;\n      var dependenciesFulfilled = null;\n      function addRunDependency(id) {\n        runDependencies++;\n        if (Module2["monitorRunDependencies"]) {\n          Module2["monitorRunDependencies"](runDependencies);\n        }\n      }\n      function removeRunDependency(id) {\n        runDependencies--;\n        if (Module2["monitorRunDependencies"]) {\n          Module2["monitorRunDependencies"](runDependencies);\n        }\n        if (runDependencies == 0) {\n          if (dependenciesFulfilled) {\n            var callback = dependenciesFulfilled;\n            dependenciesFulfilled = null;\n            callback();\n          }\n        }\n      }\n      function abort(what) {\n        if (Module2["onAbort"]) {\n          Module2["onAbort"](what);\n        }\n        what = "Aborted(" + what + ")";\n        err2(what);\n        ABORT = true;\n        what += ". Build with -sASSERTIONS for more info.";\n        var e = new WebAssembly.RuntimeError(what);\n        readyPromiseReject(e);\n        throw e;\n      }\n      var dataURIPrefix = "data:application/octet-stream;base64,";\n      function isDataURI(filename) {\n        return filename.startsWith(dataURIPrefix);\n      }\n      var wasmBinaryFile;\n      if (Module2["locateFile"]) {\n        wasmBinaryFile = "webp_dec.wasm";\n        if (!isDataURI(wasmBinaryFile)) {\n          wasmBinaryFile = locateFile(wasmBinaryFile);\n        }\n      } else {\n        wasmBinaryFile = new URL("data:application/wasm;base64,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AiABKAIMNgIMIAIgASgCEDYCECACIAEoAhQ2AhQgAiABKAIYNgIYIAIgASgCHDYCHCACIAEoAiA2AiAgAiABKAIkNgIkIAIgASgCKDYCKCACIAEoAiw2AiwgAiABKAIwNgIwIAIgASgCNDYCNCACIAEoAjg2AjggAiABKAI8NgI8IAFBQGshASACQUBrIgIgBU0NAAsLIAIgBE8NAQNAIAIgASgCADYCACABQQRqIQEgAkEEaiICIARJDQALDAELIANBBEkEQCAAIQIMAQsgACADQQRrIgRLBEAgACECDAELIAAhAgNAIAIgAS0AADoAACACIAEtAAE6AAEgAiABLQACOgACIAIgAS0AAzoAAyABQQRqIQEgAkEEaiICIARNDQALCyACIANJBEADQCACIAEtAAA6AAAgAUEBaiEBIAJBAWoiAiADRw0ACwsgAAvyAgICfwF+AkAgAkUNACAAIAE6AAAgACACaiIDQQFrIAE6AAAgAkEDSQ0AIAAgAToAAiAAIAE6AAEgA0EDayABOgAAIANBAmsgAToAACACQQdJDQAgACABOgADIANBBGsgAToAACACQQlJDQAgAEEAIABrQQNxIgRqIgMgAUH/AXFBgYKECGwiATYCACADIAIgBGtBfHEiBGoiAkEEayABNgIAIARBCUkNACADIAE2AgggAyABNgIEIAJBCGsgATYCACACQQxrIAE2AgAgBEEZSQ0AIAMgATYCGCADIAE2AhQgAyABNgIQIAMgATYCDCACQRBrIAE2AgAgAkEUayABNgIAIAJBGGsgATYCACACQRxrIAE2AgAgBCADQQRxQRhyIgRrIgJBIEkNACABrUKBgICAEH4hBSADIARqIQEDQCABIAU3AxggASAFNwMQIAEgBTcDCCABIAU3AwAgAUEgaiEBIAJBIGsiAkEfSw0ACwsgAAuXKQELfyMAQRBrIgskAAJAAkACQAJAAkACQAJAAkACQCAAQfQBTQRAQaDbACgCACIGQRAgAEELakF4cSAAQQtJGyIFQQN2IgB2IgFBA3EEQAJAIAFBf3NBAXEgAGoiAkEDdCIBQcjbAGoiACABQdDbAGooAgAiASgCCCIERgRAQaDbACAGQX4gAndxNgIADAELIAQgADYCDCAAIAQ2AggLIAFBCGohACABIAJBA3QiAkEDcjYCBCABIAJqIgEgASgC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A39BBCECAn8gACABckEDcUUEQEEAIAAoAgAgASgCAEYNARoLAkADQCAALQAAIgMgAS0AACIERw0BIAFBAWohASAAQQFqIQAgAkEBayICDQALQQAPCyADIARrCwt0AQF/IAJFBEAgACgCBCABKAIERg8LIAAgAUYEQEEBDwsgASgCBCICLQAAIQECQCAAKAIEIgMtAAAiAEUNACAAIAFHDQADQCACLQABIQEgAy0AASIARQ0BIAJBAWohAiADQQFqIQMgACABRg0ACwsgACABRgv/AwERfyABQQNsIQ5BACABayEPIAFBfWwhEEEAIAFBAnRrIRFBACABQQF0IhJrIRMgBEEBdEEBciEUA0AgAyEEAkAgACATaiIKLQAAIgggACABaiIMLQAAIgtrIhVB78kAai0AACAAIA9qIg0tAAAiAyAALQAAIglrQe/JAGotAABBAnRqIBRKDQAgACARai0AACAAIBBqLQAAIgdrQe/JAGotAAAgBUoNACAHIAhrQe/JAGotAAAgBUoNACAIIANrQe/JAGotAAAiFiAFSg0AIAAgDmotAAAgACASai0AACIHa0HvyQBqLQAAIAVKDQAgByALa0HvyQBqLQAAIAVKDQAgCyAJa0HvyQBqLQAAIhcgBUoNACAJIANrQQNsIQcCfyAGIBZOIAYgF05xRQRAIA0gAyAHIBVB/DdqLAAAaiIDQQNqQQN1QfDAAGosAABqQe/DAGotAAA6AAAgACEMIAkgA0EEakEDdUHwwABqLAAAawwBCyAKIAggB0EEakEDdUHwwABqLAAAIghBAWpBAXUiCmpB78MAai0AADoAACANIAdBA2pBA3VB8MAAaiwAACADakHvwwBqLQAAOgAAIAAgCSAIa0HvwwBqLQAAOgAAIAsgCmsLIQMgDCADQe/DAGotAAA6AAALIARBAWshAyAAIAJqIQAgBEEBSw0ACwv0AQEHfwJAIAFBAEwNACAAQUBrIQYDQCAGKAIAIAAoAjhIBEAgACgCGEEATA0CCyAAKAIEBEAgACAAKQJMQiCJNwJMCyAAIAJBhOEAQYDhACAAKAIAGygCABEDAAJAIAAoAgQNACAAKAI0IAAoAghsQQBMDQAgACgCTCEHIAAoAlAhCEEAIQUDQCAHIAVBAnQiCWoiCiAKKAIAIAggCWooAgBqNgIAIAVBAWoiBSAAKAI0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akG0AWogBSANIAogBhAnIANBAUYNAQNAIAAgAkEBayIDQRRsakG0AWogBSANIAYgBhAnIAJBAUshBCADIQIgBA0ACwwBCyAGIApGDQAgBiAKIAggCWxBAnQQFBoLIA8gEGohAwJAIA5BAEwNAEEAIQlBACECIA5BBE8EQCAOQXxxIQ8DQCACIANqIAYgAkECdGooAgBBCHY6AAAgAyACQQFyIgRqIAYgBEECdGooAgBBCHY6AAAgAyACQQJyIgRqIAYgBEECdGooAgBBCHY6AAAgAyACQQNyIgRqIAYgBEECdGooAgBBCHY6AAAgAkEEaiICIA9HDQALCyAOQQNxIgRFDQADQCACIANqIAYgAkECdGooAgBBCHY6AAAgAkEBaiECIAlBAWoiCSAERw0ACwsgCygCDCIEBEAgCygCjAEhAiAIQQFxBH8gAiADIAMgByAEQQJ0QbDgAGooAgARAQAgBUEBaiEFIAMiAiAHagUgAwshBCAIQQFHBEADQCACIAQgBCAHIAsoAgxBAnRBsOAAaigCABEBACAEIAQgB2oiAiACIAcgCygCDEECdEGw4ABqKAIAEQEAIAIgB2ohBCACIQMgBUECaiIFIA1HDQALCyALIAM2AowBCyAKIAAoAmQiCSAIbEECdGohCiANIQUgDCAIayIMQQBKDQALCyAAIAE2AmwgACABNgJ0C+IBAQR/IAAEfyAALQAABUEACyEAAkAgA0EATA0AIANBA3EhBQJAIANBBEkEQEEAIQMMAQsgA0F8cSEHQQAhAwNAIAIgA2ogASADai0AACAAaiIAOgAAIAIgA0EBciIEaiABIARqLQAAIABqIgA6AAAgAiADQQJyIgRqIAEgBGotAAAgAGoiADoAACACIANBA3IiBGogASAEai0AACAAaiIAOgAAIANBBGoiAyAHRw0ACwsgBUUNAANAIAIgA2ogASADai0AACAAaiIAOgAAIANBAWohAyAGQQFqIgYgBUcNAAsLC88CAQR/AkAgAARAIANBAEwNASADQQFHBEAgA0EBcSEFIANBfnEhBwNAIAIgBGogASAEai0AACAAIARqLQAAajoAACACIARBAXIiA2ogASADai0AACAAIANqLQAAajoAACAEQQJqIgQgB0cNAAsgBUUNAgsgAiAEaiABIARqLQAAIAAgBGotAABqOgAADwsgA0EA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AigCGCACKAIcajYCGCACIAIoAkQgAigCSGo2AkQgAiACKAJAQQFqNgJAIAEoAhwiAigCGEEATARAQYjhACEDAkACQCACKAIEDQBBjOEAIQMgAigCFA0AIAIoAjQgAigCCGxBAEwNASACKAJMIQRBACEDA0AgAigCRCADaiAEIANBAnQiCGooAgA6AAAgAigCTCIEIAhqQQA2AgAgA0EBaiIDIAIoAjQgAigCCGxIDQALDAELIAIgAygCABEAAAsgAiACKAIYIAIoAhxqNgIYIAIgAigCRCACKAJIajYCRCACIAIoAkBBAWo2AkALIAEoAiAiAigCGEEATARAQYjhACEDAkACQCACKAIEDQBBjOEAIQMgAigCFA0AIAIoAjQgAigCCGxBAEwNASACKAJMIQRBACEDA0AgAigCRCADaiAEIANBAnQiCGooAgA6AAAgAigCTCIEIAhqQQA2AgAgA0EBaiIDIAIoAjQgAigCCGxIDQALDAELIAIgAygCABEAAAsgAiACKAIYIAIoAhxqNgIYIAIgAigCRCACKAJIajYCRCACIAIoAkBBAWo2AkAgASgCICECCyABKAIYIgMoAkQgASgCHCgCRCACKAJEIAwgAygCNCAOEQIAIAZBAWohBiAMIAsoAhRqIQwgASgCGCICQUBrKAIAIAIoAjhIDQALCyAGIAlqIQkgByAKSA0ACyAJC+kCAQl/IAEoAgAiBCgCHCIGIAQoAiwiAyABKAIQIghsaiEFAkAgACgCaCIHBEAgACgCECICQQBMDQEgBCgCICEJIAEoAiQhAyAAKAIAIQYgBCgCECEKQQAhAANAIAcgAyACIAcgBhAbIgsgBmxqIQcgAxAkIABqIQAgAiALayICQQBKDQALIABBAEwNASAKIAggCWxqIAQoAiAgBSAEKAIsIAEoAiQoAjQgAEEBEDFBAA8LIAZFDQAgAkEATA0AIAAoAmAhASACQQhPBEAgAkF4cSEEQQAhAANAIAVB/wEgARAVIANqQf8BIAEQFSADakH/ASABEBUgA2pB/wEgARAVIANqQf8BIAEQFSADakH/ASABEBUgA2pB/wEgARAVIANqQf8BIAEQFSADaiEFIABBCGoiACAERw0ACwsgAkEHcSICRQ0AQQAhAANAIAVB/wEgARAVIANqIQUgAEEBaiIAIAJHDQALC0EAC7MCAQd/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6OcAKAIAIgAEQEHo5wAgACgCCDYCACAAKAIEIAAoAgARAAAgABASDAELC0Hh5wBBADoAAAsGAEGAggQLJAEBf0HE4gAoAgAiAARAA0AgACgCABEKACAAKAIEIgANAAsLC4UBAQN/AkAgACgCBCICIgBBA3EEQANAIAAtAABFDQIgAEEBaiIAQQNxDQALCwNAIAAiAUEEaiEAIAEoAgAiA0F/cyADQYGChAhrcUGAgYKEeHFFDQALA0AgASIAQQFqIQEgAC0AAA0ACwsgACACa0EBaiIAEBYiAQR/IAEgAiAAEBQFQQALC9MBAQF+IAAgAC0A3wEgAEEZay0AACAALQC/ASAAQRprLQAAIAAtAJ8BIABBG2stAAAgAC0AfyAAQRxrLQAAIAAtAF8gAEEday0AACAALQA/IABBHmstAAAgAC0AHyAAQR9rLQAAIABBIGstAAAgAEEBay0AAGpqampqampqampqampqakEIakEEdq1C/wGDQoGChIiQoMCAAX4iATcA4AEgACABNwDAASAAIAE3AKABIAAgATcAgAEgACABNwBgIAAgATcAQCAAIAE3ACAgACABNwAAC9cIARJ/IABB78MAIABBIWstAABrIgIgAEEBay0AAGoiASAAQSBrIgstAAAiA2otAAA6AAAgACABIABBH2siDC0AACIEai0AADoAASAAIAEgAEEeayINLQAAIgVqLQAAOgACIAAgASAAQR1rIg4tAAAiBmotAAA6AAMgACABIABBHGsiDy0AACIHai0AADoABCAAIAEgAEEbayIQLQAAIghqLQAAOgAFIAAgASAAQRprIhEtAAAiCWotAAA6AAYgACABIABBGWsiEi0AACIKai0AADoAByAAIAogAiAALQAfaiIBai0AADoAJyAAIAEgCWotAAA6ACYgACABIAhqLQAAOgAlIAAgASAHai0AADoAJCAAIAEgBmotAAA6ACMgACABIAVqLQAAOgAiIAAgASAEai0AADoAISAAIAEgA2otAAA6ACAgACAKIAIgAC0AP2oiAWotAAA6AEcgACABIAlqLQAAOgBGIAAgASAIai0AADoARSAAIAEgB2otAAA6AEQgACABIAZqLQAAOgBDIAAgASAFai0AADoAQiAAIAEgBGotAAA6AEEgACABIANqLQAAOgBAIAAgAiAALQBfaiIBIAstAAAiA2otAAA6AGAgACABIAwtAAAiBGotAAA6AGEgACABIA0tAAAiBWotAAA6AGIgACABIA4tAAAiBmotAAA6AGMgACABIA8tAAAiB2otAAA6AGQgACABIBAtAAAiCGotAAA6AGUgACABIBEtAAAiCWotAAA6AGYgACABIBItAAAiCmotAAA6AGcgACAKIAIgAC0Af2oiAWotAAA6AIcBIAAgASAJai0AADoAhgEgACABIAhqLQAAOgCFASAAIAEgB2otAAA6AIQBIAAgASAGai0AADoAgwEgACABIAVqLQAAOgCCASAAIAEgBGotAAA6AIEBIAAgASADai0AADoAgAEgACAKIAIgAC0AnwFqIgFqLQAAOgCnASAAIAEgCWotAAA6AKYBIAAgASAIai0AADoApQEgACABIAdqLQAAOgCkASAAIAEgBmotAAA6AKMBIAAgASAFai0AADoAogEgACABIARqLQAAOgChASAAIAEgA2otAAA6AKABIAAgAiAALQC/AWoiASALLQAAIgtqLQAAOgDAASAAIAEgDC0AACIDai0AADoAwQEgACABIA0tAAAiDGotAAA6AMIBIAAgASAOLQAAIgRqLQAAOgDDASAAIAEgDy0AACINai0AADoAxAEgACABIBAtAAAiBWotAAA6AMUBIAAgASARLQAAIg5qLQAAOgDGASAAIAEgEi0AACIGai0AADoAxwEgACAGIAIgAC0A3wFqIgJqLQAAOgDnASAAIAIgDmotAAA6AOYBIAAgAiAFai0AADoA5QEgACACIA1qLQAAOgDkASAAIAIgBGotAAA6AOMBIAAgAiAMai0AADoA4gEgACACIANqLQAAOgDhASAAIAIgC2otAAA6AOABC0gBAX4gACAAQSBrKQAAIgE3AOABIAAgATcAwAEgACABNwCgASAAIAE3AIABIAAgATcAYCAAIAE3AEAgACABNwAgIAAgATcAAAu0AQAgACAAMQAfQoGChIiQoMCAAX43ACAgACAAMQA/QoGChIiQoMCAAX43AEAgACAAMQBfQoGChIiQoMCAAX43AGAgACAAMQB/QoGChIiQoMCAAX43AIABIAAgADEAnwFCgYKEiJCgwIABfjcAoAEgACAAMQC/AUKBgoSIkKDAgAF+NwDAASAAIAAxAN8BQoGChIiQoMCAAX43AOABIAAgAEEBazEAAEKBgoSIkKDAgAF+NwAAC4sBAQF+IAAgAC0A3wEgAC0AvwEgAC0AnwEgAC0AfyAALQBfIAAtAD8gAEEBay0AACAALQAfampqampqakEEakEDdq1C/wGDQoGChIiQoMCAAX4iATcA4AEgACABNwDAASAAIAE3AKABIAAgATcAgAEgACABNwBgIAAgATcAQCAAIAE3ACAgACABNwAAC50BAQF+IAAgAEEZay0AACAAQRprLQAAIABBG2stAAAgAEEcay0AACAAQR1rLQAAIABBHmstAAAgAEEgay0AACAAQR9rLQAAampqampqakEEakEDdq1C/wGDQoGChIiQoMCAAX4iATcA4AEgACABNwDAASAAIAE3AKABIAAgATcAgAEgACABNwBgIAAgATcAQCAAIAE3ACAgACABNwAACwcAIAARDwALhgEAIABCgIGChIiQoMCAfzcA4AEgAEKAgYKEiJCgwIB/NwDAASAAQoCBgoSIkKDAgH83AKABIABCgIGChIiQoMCAfzcAgAEgAEKAgYKEiJCgwIB/NwBgIABCgIGChIiQoMCAfzcAQCAAQoCBgoSIkKDAgH83ACAgAEKAgYKEiJCgwIB/NwAAC48EAQF+IAAgAEERay0AACAALQDfAyAAQRJrLQAAIAAtAL8DIABBE2stAAAgAC0AnwMgAEEUay0AACAALQD/AiAAQRVrLQAAIAAtAN8CIABBFmstAAAgAC0AvwIgAEEXay0AACAALQCfAiAAQRhrLQAAIAAtAP8BIABBGWstAAAgAC0A3wEgAEEaay0AACAALQC/ASAAQRtrLQAAIAAtAJ8BIABBHGstAAAgAC0AfyAAQR1rLQAAIAAtAF8gAEEeay0AACAALQA/IABBH2stAAAgAC0AHyAAQQFrLQAAIABBIGstAABqampqampqampqampqampqampqampqampqampqampqQRBqQQV2rUL/AYNCgYKEiJCgwIABfiIBNwAIIAAgATcAACAAIAE3ACAgACABNwAoIAAgATcAQCAAIAE3AEggACABNwBgIAAgATcAaCAAIAE3AIABIAAgATcAiAEgACABNwCgASAAIAE3AKgBIAAgATcAwAEgACABNwDIASAAIAE3AOgBIAAgATcA4AEgACABNwCIAiAAIAE3AIACIAAgATcAqAIgACABNwCgAiAAIAE3AMgCIAAgATcAwAIgACABNwDoAiAAIAE3AOACIAAgATcAiAMgACABNwCAAyAAIAE3AKgDIAAgATcAoAMgACABNwDIAyAAIAE3AMADIAAgATcA6AMgACABNwDgAwukAwETfyAAQRFrIQMgAEESayEEIABBE2shBSAAQRRrIQYgAEEVayEHIABBFmshCCAAQRdrIQkgAEEYayEKIABBGWshCyAAQRprIQwgAEEbayENIABBHGshDiAAQR1rIQ8gAEEeayEQIABBH2shESAAQSBrIRJB78MAIABBIWstAABrIRMDQCAAIBMgAEEBay0AAGoiASASLQAAai0AADoAACAAIAEgES0AAGotAAA6AAEgACABIBAtAABqLQAAOgACIAAgASAPLQAAai0AADoAAyAAIAEgDi0AAGotAAA6AAQgACABIA0tAABqLQAAOgAFIAAgASAMLQAAai0AADoABiAAIAEgCy0AAGotAAA6AAcgACABIAotAABqLQAAOgAIIAAgASAJLQAAai0AADoACSAAIAEgCC0AAGotAAA6AAogACABIActAABqLQAAOgALIAAgASAGLQAAai0AADoADCAAIAEgBS0AAGotAAA6AA0gACABIAQtAABqLQAAOgAOIAAgASADLQAAai0AADoADyAAQSBqIQAgAkEBaiICQRBHDQALC5cCAgJ+AX8gACAAQSBrIgMpAAAiATcAACAAIAE3ACAgACABNwBAIAAgATcAYCAAIAE3AIABIAAgATcAoAEgACABNwDAASAAIAE3AOABIAAgAykACCIBNwAIIAAgATcAKCAAIAE3AEggACABNwBoIAAgATcAiAEgACABNwCoASAAIAE3AMgBIAAgATcA6AEgACADKQAIIgE3AIgCIAAgAykAACICNwCAAiAAIAE3AKgCIAAgAjcAoAIgACABNwDIAiAAIAI3AMACIAAgATcA6AIgACACNwDgAiAAIAI3AIADIAAgATcAiAMgACABNwCoAyAAIAI3AKADIAAgAjcAwAMgACABNwDIAyAAIAE3AOgDIAAgAjcA4AMLigQBAX4gACAAMQAfQoGChIiQoMCAAX4iATcAICAAIAE3ACggACAAMQA/QoGChIiQoMCAAX4iATcAQCAAIAE3AEggACAAMQBfQoGChIiQoMCAAX4iATcAYCAAIAE3AGggACAAMQB/QoGChIiQoMCAAX4iATcAgAEgACABNwCIASAAIAAxAJ8BQoGChIiQoMCAAX4iATcAqAEgACABNwCgASAAIABBAWsxAABCgYKEiJCgwIABfiIBNwAAIAAgATcACCAAIAAxAL8BQoGChIiQoMCAAX4iATcAyAEgACABNwDAASAAIAAxAN8BQoGChIiQoMCAAX4iATcA6AEgACABNwDgASAAIAAxAP8BQoGChIiQoMCAAX4iATcAiAIgACABNwCAAiAAIAAxAJ8CQoGChIiQoMCAAX4iATcAqAIgACABNwCgAiAAIAAxAL8CQoGChIiQoMCAAX4iATcAyAIgACABNwDAAiAAIAAxAN8CQoGChIiQoMCAAX4iATcA6AIgACABNwDgAiAAIAAxAP8CQoGChIiQoMCAAX4iATcAiAMgACABNwCAAyAAIAAxAJ8DQoGChIiQoMCAAX4iATcAqAMgACABNwCgAyAAIAAxAL8DQoGChIiQoMCAAX4iATcAyAMgACABNwDAAyAAIAAxAN8DQoGChIiQoMCAAX4iATcA6AMgACABNwDgAwv/AgEBfiAAIAAtAN8DIAAtAL8DIAAtAJ8DIAAtAP8CIAAtAN8CIAAtAL8CIAAtAJ8CIAAtAP8BIAAtAN8BIAAtAL8BIAAtAJ8BIAAtAH8gAC0AXyAALQA/IABBAWstAAAgAC0AH2pqampqampqampqampqakEIakEEdq1C/wGDQoGChIiQoMCAAX4iATcAACAAIAE3AAggACABNwAoIAAgATcAICAAIAE3AEggACABNwBAIAAgATcAaCAAIAE3AGAgACABNwCIASAAIAE3AIABIAAgATcAqAEgACABNwCgASAAIAE3AMgBIAAgATcAwAEgACABNwDoASAAIAE3AOABIAAgATcAiAIgACABNwCAAiAAIAE3AKgCIAAgATcAoAIgACABNwDIAiAAIAE3AMACIAAgATcA6AIgACABNwDgAiAAIAE3AIgDIAAgATcAgAMgACABNwCoAyAAIAE3AKADIAAgATcAyAMgACABNwDAAyAAIAE3AOgDIAAgATcA4AMLoQMBAX4gACAAQRFrLQAAIABBEmstAAAgAEETay0AACAAQRRrLQAAIABBFWstAAAgAEEWay0AACAAQRdrLQAAIABBGGstAAAgAEEZay0AACAAQRprLQAAIABBG2stAAAgAEEcay0A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IAIgAigC/BE2AqQBAkAgA0ECRgRAIAIoAoASIQMgAiACKAKwATYCgBIgAiADNgKwAQwBCyACICwQKwsgAQRAIAIoAtQRIQEgAiACKAKsATYC1BEgAiABNgKsAQsgAigChAEiAQRAIAIoAogBIAIoAowBIAERBQAhASACIAIoApABIAFFcjYCkAELIAIgAigCmAFBAWoiAUEAIAEgAigCnAFHGzYCmAEMAgsgAiABNgKoASACIAIoAvwRNgKkASACICwQKyACIAlBJGoQLw0BC0EAIQMgAigCAA0FIAJBgxE2AgggAkIGNwIADAULIAIgAigC/BFBAWoiGTYC/BEgGSACKAK0AkgNAAsLIAIoApQBQQBKBEBBACEDIAIoApABDQMLQQEhAwwCC0EAIQMgAigCAA0BIAJBthE2AgggAkIHNwIADAELQQAhAyACKAIADQAgAkG0EDYCCCACQgE3AgALQQEhASACKAKUAUEASgRAIAIoApABRSEBCyAJKAJYIgQEQCAJQSRqIAQRAAALIAEgA3ENAgsgAkEANgKAASACKAK4EhASIAJCADcCuBIgAigCqBIiAQRAIAEoAhQiAwRAIAMQHSADEBILIAEQEgsgAkEANgKoEiACKALwERASIAJCADcCDCACQgA3AvARIAJCADcCFCACQgA3AhwgAkEANgIkIAJBADYCBAsgAigCACEBDAELQQAhASACQQA2AgQLIAJBADYCgAEgAigCuBIQEiACQgA3ArgSIAIoAqgSIgMEQCADKAIUIgQEQCAEEB0gBBASCyADEBILIAJBADYCqBIgAigC8BEQEgsgAhASIAEEQCAMKAJgIgNFDQEgAygCDEEATARAIAMoAlAQEgsgA0EANgJQDAELQQAhASAMKAJ0IgNFDQAgAygCMEUNACAMKAJgIgNFBEBBAiEBDAELIAMoAghBAWshBiADKAIQIQgCQCADKAIAQQpNBEAgAyAIIAYgA0EUaiIEKAIAIgNsajYCEAwBCyADQQAgAygCICIEazYCICADQQAgAygCJCIKazYCJCADQQAgAygCKCIFazYCKCADIAggBCAGbGo2AhAgAyADKAIUIAogBkEBdSIEbGo2AhQgAyADKAIYIAQgBWxqNgIYIAMoAhwiCEUNASADIAggA0EsaiIEKAIAIgMgBmxqNgIcCyAEQQAgA2s2AgALIAlBsAFqJAAgAQ0AIAwoAhgiAUUNAAJAQaDfAC0AAA0AQaDfAEEBOgAAQZDfAEGACBAENgIAQQYQJkGU3wBB/QoQBDYCAEEHECZBoN8ALQAADQBBoN8AQQE6AABBkN8AQYAIEAQ2AgBBBhAmQZTfAEH9ChAENgIAQQcQJgsgDCABNgIMIAwgKiArbEECdDYCCEGQ3wAoAgBBAUG8EiAMQQhqIgQQByIDEAggDCArNgIYIAwgKjYCECAMIAM2AgggAEGU3wAoAgBBA0HAEiAEEAc2AgAgAxADIAEQEgwBCyAAQQI2AgALIAxBwAFqJAALvwIBB38gACAAQR9rLQAAIgVBAWoiASAAQR5rLQAAIgJqQQF2IgM6AEAgACABIABBIGstAAAiBmpBAXY6AAAgACACIABBHWstAAAiAWpBAWpBAXYiBDoAQSAAIAM6AAEgACABIABBHGstAAAiA2pBAWpBAXYiBzoAQiAAIAQ6AAIgACAHOgADIAAgBSABQQJqIgRqIAJBAXRqQQJ2Igc6AGAgACAGIAJBAmoiAmogBUEBdGpBAnY6ACAgACADIAIgAUEBdGpqQQJ2IgU6AGEgACAHOgAhIABBGWstAAAhBiAAQRprLQAAIQIgACAAQRtrLQAAIgEgBCADQQF0ampBAnYiBDoAYiAAIAU6ACIgACAGIAEgAkEBdGpqQQJqQQJ2OgBjIAAgAiADIAFBAXRqakECakECdjoAQyAAIAQ6ACMLsAIBCX8gACAALQAfIgMgAC0APyIEakEBakEBdiICOgBiIAAgBCAALQBfIgdqQQFqQQF2OgBgIAAgAjoAQCAAIABBAWstAAAiBkEBaiIBIABBIWstAAAiAmpBAXYiBToAIiAAIAEgA2pBAXYiAToAQiAAIAU6AAAgACABOgAgIAAgAEEgay0AACIBIAZBAmoiBSACQQF0ampBAnYiCDoAIyAAIABBHmstAAAgASAAQR9rLQAAIglBAXRqakECakECdjoAAyAAIAkgAiABQQF0ampBAmpBAnY6AAIgACACIANBAmoiASAGQQF0ampBAnYiAjoAQyAAIAg6AAEgACAEIAVqIANBAXRqQQJ2IgM6AGMgACACOgAhIAAgASAHaiAEQQF0akECdjoAYSAAIAM6AEEL2QEBBn8gACAALQBfIgE6AGMgACABOgBiIAAgAToAYSAAIAE6AGAgACAALQAfIgRBAWoiAyAALQA/IgJqQQF2IgU6ACAgACADIABBAWstAAAiBmpBAXY6AAAgACABIAJqQQFqQQF2IgM6AEAgACAFOgACIAAgAzoAIiAAIAEgBGogAkEBdGpBAmpBAnYiAzoAISAAIAYgAkECaiICaiAEQQF0akECdjoAASAAIAEgAmogAUEBdGpBAnYiAjoAQSAAIAM6AAMgACACOgAjIAAgAToAQyAAIAE6AEILbgEBfyAAIAAtAF8gAEEday0AACAALQA/IABBHmstAAAgAC0AHyAAQR9rLQAAIABBIGstAAAgAEEBay0AAGpqampqampBBGpBA3ZB/wFxQYGChAhsIgE2AGAgACABNgBAIAAgATYAICAAIAE2AAALpAIBBn8gAEHvwwAgAEEhay0AAGsiAiAAQQFrLQAAaiIBIABBIGstAAAiA2otAAA6AAAgACABIABBH2stAAAiBGotAAA6AAEgACABIABBHmstAAAiBWotAAA6AAIgACABIABBHWstAAAiBmotAAA6AAMgACAGIAIgAC0AH2oiAWotAAA6ACMgACABIAVqLQAAOgAiIAAgASAEai0AADoAISAAIAEgA2otAAA6ACAgACAGIAIgAC0AP2oiAWotAAA6AEMgACABIAVqLQAAOgBCIAAgASAEai0AADoAQSAAIAEgA2otAAA6AEAgACAGIAIgAC0AX2oiAmotAAA6AGMgACACIAVqLQAAOgBiIAAgAiAEai0AADoAYSAAIAIgA2otAAA6AGAL4gEBBn8gACAAQRxrLQAAIABBHmstAAAiAkECaiIDIABBHWstAAAiAUEBdGpqQQJ2IgQ6AGMgACABIABBH2stAAAiBUECaiIGIAJBAXRqakECdiICOgBiIAAgAyAAQSBrLQAAIgFqIAVBAXRqQQJ2IgM6AGEgACAGIABBIWstAABqIAFBAXRqQQJ2IgE6AGAgACAEOgBDIAAgAjoAQiAAIAM6AEEgACABOgBAIAAgBDoAIyAAIAI6ACIgACADOgAhIAAgAToAICAAIAQ6AAMgACACOgACIAAgAzoAASAAIAE6AAALpgIBBX8gACAALQBfIAAtAB8iAUECaiIDIAAtAD8iAkEBdGpqQQJ2OgBgIAAgAiAAQQFrLQAAIgRBAmoiBSABQQF0ampBAnYiAToAYSAAIAE6AEAgACAAQSFrLQAAIgIgAyAEQQF0ampBAnYiAToAYiAAIAE6AEEgACABOgAgIAAgBSAAQSBrLQAAIgNqIAJBAXRqQQJ2IgE6AGMgACABOgBCIAAgAToAISAAIAE6AAAgAEEday0AACEFIABBHmstAAAhASAAIAIgAEEfay0AACIEaiADQQF0akECakECdiICOgBDIAAgAjoAIiAAIAI6AAEgACABIANqIARBAXRqQQJqQQJ2IgI6ACMgACACOgACIAAgBCAFaiABQQF0akECakECdjoAAwujAgEFfyAAIABBHWstAAAiAkECaiIFIABBH2stAAAiA2ogAEEeay0AACIBQQF0akECdiIEOgAgIAAgAUECaiIBIABBIGstAABqIANBAXRqQQJ2OgAAIAAgAEEcay0AACIDIAEgAkEBdGpqQQJ2IgE6AEAgACAEOgABIAAgAToAISAAIABBG2stAAAiBCAFIANBAXRqakECdiICOgBgIAAgAToAAiAAIAI6AEEgACACOgAiIAAgAjoAAyAAIABBGmstAAAiAiADIARBAXRqakECakECdiIDOgBhIAAgAEEZay0AACIBIAQgAkEBdGpqQQJqQQJ2IgQ6AGIgACADOgAjIAAgAzoAQiAAIAEgAmogAUEBdGpBAmpBAnY6AGMgACAEOgBDCy8AIAAgARAhIABBIGogAUEEahAhIABBQGsgAUGAAWoQISAAQeAAaiABQYQBahAhC08BAX8gAC8BACICBEAgAiABECALIAAvASAiAgRAIAIgAUEEahAgCyAALwFAIgIEQCACIAFBgAFqECALIAAvAWAiAARAIAAgAUGEAWoQIAsLqQIBBH8jAEEQayICJAAgASgCACIEQfD///8HSQRAAkACQCAEQQtPBEAgBEEPckEBaiIFEDghAyACIAVBgICAgHhyNgIIIAIgAzYCACACIAQ2AgQgAyAEaiEFDAELIAIgBDoACyACIARqIQUgAiEDIARFDQELIAMgAUEEaiAEEBQaCyAFQQA6AAAgAkEMaiACIAARAwAgAigCDBAIIAIoAgwiABADIAIsAAtBAEgEQCACKAIAEBILIAJBEGokACAADwtB2AAQFkHQAGoiA0Hk2gA2AgAgA0GQ2QA2AgBBGRA4IgFBADYCCCABQoyAgIDAATcCACABQQxqIgBBlwopAAA3AAUgAUGSCikAADcADCADIAA2AgQgA0HA2QA2AgAgA0Hg2QBBPBANAAvkEgETfwJAIAEgACgCbCIDayICQQBMDQAgACgCCCIIKAIAIQsgACgCECAAKAJkIgUgA2xBAnRqIQYgACgCFCEJAkAgACgCsAEiBEEASgRAIAAgBEEBayICQRRsakG0AWogAyABIAYgCRAnIARBAUYNAQNAIAAgAkEBayIGQRRsakG0AWogAyABIAkgCRAnIAJBAUshBCAGIQIgBA0ACwwBCyAGIAlGDQAgCSAGIAIgBWxBAnQQFBoLIAgoAlgiBiABIAEgBkobIgYgCCgCVCICIAAoAmwiAyACIANKIgUbIgRMDQAgCCAGIARrIgY2AhAgCCAEIAJrNgIIIAggCCgCUCAIKAJMIgprIgQ2AgwgCSALQQJ0IhAgAiADa2xBACAFG2ogCkECdGohCyAAKAIMIgIoAgAiEUEKTQRAIAIoAhAgAigCFCINIAAoAnRsaiEKAkAgCCgCXARAIAZBAEwEQEEAIQgMAgtBACEJQQAhCANAIAsgCSAQbGoiAyAQIAAoAowCIgIoAiwgAigCICIEIAIoAhhqQQFrIARtIgQgBiAJayICIAIgBEobEEEgACgCjAIgAiADIBAQGyAJaiEJQQAhBQJAIAAoAowCIgNBQGsiDigCACADKAI4Tg0AIAogCCANbGohEyADKAI0IQwgAygCRCESA0AgAygCGEEASg0BQYjhACECAkACQCADKAIEDQBBjOEAIQIgAygCFA0AIAMoAjQgAygCCGxBAEwNASADKAJMIQdBACECA0AgAygCRCACaiAHIAJBAnQiBGooAgA6AAAgAygCTCIHIARqQQA2AgAgAkEBaiICIAMoAjQgAygCCGxIDQALDAELIAMgAigCABEAAAsgAyADKAIYIAMoAhxqNgIYIAMgAygCRCADKAJIajYCRCAOIA4oAgBBAWo2AgBBACECIAxBAEoEQANAIBIgAkECdGoiFCgCACIEQf///3dNBEBBACEHIBQgBEGAgIAITwR/IARBgICAeHFBgICAeCAEQRh2biIHIARB/wFxbEGAgIAEakEYdnIgByAEQQh2Qf8BcWxBgICABGpBEHZBgP4DcXIgByAEQRB2Qf8BcWxBgICABGpBCHZBgID8B3FyBUEACzYCAAsgAkEBaiICIAxHDQALCyASIAwg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b2wAZW1zY3JpcHRlbjo6dmFsAGJhZCBwYXJ0aXRpb24gbGVuZ3RoAHVuc2lnbmVkIGxvbmcAc3RkOjp3c3RyaW5nAGJhc2ljX3N0cmluZwBzdGQ6OnN0cmluZwBzdGQ6OnUxNnN0cmluZwBzdGQ6OnUzMnN0cmluZwBkb3VibGUAZGVjb2RlAEJhZCBjb2RlIHdvcmQAdm9pZABGcmFtZSBzZXR1cCBmYWlsZWQASW1hZ2VEYXRhAFZQOFgAV0VCUABWUDhMAE9LAEFMUEgAUklGRgBlbXNjcmlwdGVuOjptZW1vcnlfdmlldzxzaG9ydD4AZW1zY3JpcHRlbjo6bWVtb3J5X3ZpZXc8dW5zaWduZWQgc2hvcnQ+AGVtc2NyaXB0ZW46Om1lbW9yeV92aWV3PGludD4AZW1zY3JpcHRlbjo6bWVtb3J5X3ZpZXc8dW5zaWduZWQgaW50PgBlbXNjcmlwdGVuOjptZW1vcnlfdmlldzxmbG9hdD4AZW1zY3JpcHRlbjo6bWVtb3J5X3ZpZXc8dWludDhfdD4AZW1zY3JpcHRlbjo6bWVtb3J5X3ZpZXc8aW50OF90PgBlbXNjcmlwdGVuOjptZW1vcnlfdmlldzx1aW50MTZfdD4AZW1zY3JpcHRlbjo6bWVtb3J5X3ZpZXc8aW50MTZfdD4AZW1zY3JpcHRlbjo6bWVtb3J5X3ZpZXc8dWludDMyX3Q+AGVtc2NyaXB0ZW46Om1lbW9yeV92aWV3PGludDMyX3Q+AGVtc2NyaXB0ZW46Om1lbW9yeV92aWV3PGNoYXI+AGVtc2NyaXB0ZW46Om1lbW9yeV92aWV3PHVuc2lnbmVkIGNoYXI+AHN0ZDo6YmFzaWNfc3RyaW5nPHVuc2lnbmVkIGNoYXI+AGVtc2NyaXB0ZW46Om1lbW9yeV92aWV3PHNpZ25lZCBjaGFyPgBlbXNjcmlwdGVuOjptZW1vcnlfdmlldzxsb25nPgBlbXNjcmlwdGVuOjptZW1vcnlfdmlldzx1bnNpZ25lZCBsb25nPgBlbXNjcmlwdGVuOjptZW1vcnlfdmlldzxkb3VibGU+AEluY29ycmVjdCBrZXlmcmFtZSBwYXJhbWV0ZXJzLgBUcnVuY2F0ZWQgaGVhZGVyLgBubyBtZW1vcnkgZHVyaW5nIGZyYW1lIGluaXRpYWxpemF0aW9uLgBOb3QgYSBrZXkgZnJhbWUuAEZyYW1lIG5vdCBkaXNwbGF5YWJsZS4AT3V0cHV0IGFib3J0ZWQuAFByZW1hdHVyZSBlbmQtb2YtZmlsZSBlbmNvdW50ZXJlZC4AUHJlbWF0dXJlIGVuZC1vZi1wYXJ0aXRpb24wIGVuY291bnRlcmVkLgBDb3VsZCBub3QgZGVjb2RlIGFscGhhIGRhdGEuAG51bGwgVlA4SW8gcGFzc2VkIHRvIFZQOEdldEhlYWRlcnMoKQBWUDggAAAAwCgAAHwnAABpaWkA6CsAAGlpAAA4KQAAwCgAAOgrAADoKwAAAAAAAP///////////////////////////////////////////7D2////////////3/H8///////////5/f3////////////0/P//////////6v7+///////////9///////////////2/v//////////7/3+///////////+//7////////////4/v//////////+//+///////////////////////////9/v//////////+/7+///////////+//7////////////+/f/+////////+v/+//7////////+/////////////////////////////////////////////////////////9n/////////////4fzx/f///v/////q+vH6/f/9/v/////+////////////3/7+///////////u/f7+///////////4/v//////////+f7////////////////////////////9////////////9/7////////////////////////////9/v///////////P/////////////////////////////+/v///////////f/////////////////////////////+/f//////////+v/////////////+/////////////////////////////////////////////////////////7r7+v//////////6vv0/v/////////7+/P9/v/+///////9/v//////////7P3+///////////7/f3+/v/////////+/v///////////v7+///////////////////////////+/////////////v7////////////+/////////////////////////////v////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////j/////////////+v78/v/////////4/vn9///////////9/f//////////9v39///////////8/vv+/v/////////+/P//////////+P79///////////9//7+///////////7/v//////////9fv+///////////9/f7////////////7/f///////////P3+/////////////v/////////////8////////////+f/+//////////////7//////////////f//////////+v///////////////////////////////////////////v///////////////////////////4CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgP2I/v/k24CAgICAvYHy/+PV/9uAgIBqfuP81tH//4CAgAFi+P/s4v//gICAtYXu/t3q/5qAgIBOhsr3xrT/24CAgAG5+f/z/4CAgICAuJb3/+zggICAgIBNbtj/7OaAgICAgAFl+//x/4CAgICAqovx/OzR//+AgIAldMTz5P///4CAgAHM/v/1/4CAgICAz6D6/+6AgICAgIBmZ+f/06uAgICAgAGY/P/w/4CAgICAsYfz/+rhgICAgIBQgdP/wuCAgICAgAEB/4CAgICAgICA9gH/gICAgICAgID/gICAgICAgICAgMYj7d/Bu6KgkZs+gy3G3ayw3J383QFEL5LQlafdov/fgAGV8f/d4P//gICAuI3q/d7c/8eAgIBRY7XysL75yv//gAGB6P3WxfLE//+AY3nS+snG/8qAgIAXW6Pyqrv30v//gAHI9v/q/4CAgICAbbLx/+f1//+AgIAsgsn9zcD//4CAgAGE7/vb0f+lgICAXojh+9q+//+AgIAWZK71uqH/x4CAgAG2+f/o64CAgICAfI/x/+PqgICAgIAjTbX7wdP/zYCAgAGd9//s5///gICAeY3r/+Hj//+AgIAtY7z7w9n/4ICAgAEB+//V/4CAgICAywH4//+AgICAgICJAbH/4P+AgICAgP0J+PvP0P/AgICArw3g88G5+cb//4BJEavdobPsp//qgAFf9/3Ut///gICA71r0+tPR//+AgICbTcP4vMP//4CAgAEY7/va2//NgICAyTPb/8S6gICAgIBFLr7vydr/5ICAgAG/+///gICAgICA36X5/9X/gICAgICNfPj//4CAgICAgAEQ+P//gICAgICAviTm/+z/gICAgICVAf+AgICAgICAgAHi/4CAgICAgICA98D/gICAgICAgIDwgP+AgICAgICAgAGG/P//gICAgICA1T76//+AgICAgIA3Xf+AgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMoY1eu6v9yg8K//fia26Km45K7/u4A9Lorbl7Lwqv/YgAFw5vrHv/ef//+Apm3k/NPX/66AgIAnTaLorLT1sv//gAE03PbGx/nc//+AfEq/87fB+t3//4AYR4Lbmqrztv//gAG24fnb8P/ggICAlZbi/NjN/6uAgIAcbKryt8L+3///gAFR5vzMy//AgICAe2bR97zE/+mAgIAUX5nzpK3/y4CAgAHe+P/Y1YCAgICAqK/2/OvN//+AgIAvdNf/09T//4CAgAF57P3U1v//gICAjVTV/MnK/9uAgIAqUKDworn/zYCAgAEB/4CAgICAgICA9AH/gICAgICAgIDuAf+AgICAgICAgOd4MFlzcXiYcJizQH6qdi5GX69Fj1BVUkibZzg6CqvavRENmHIaEaMswxUKrXkYUMMaPixAVZBHCiar1ZAiGqouNxOIoCHORz8UCHJy0AwJ4lEoC2C2VB0QJIa3WYliZWqllEi7ZIKdbyBLUEJmp2NKPijqgCk1CbLxjRoIa0orGpJJpjEXnUEmaaAzNB9zgGhPDBvZ/1cRB1dERyxyMw+6Fy8pDm62txURwkItGWbFvRcSFlhYk5YqLi3EzStht3VVJiOzPSc1yFcaFSvoqzgiM2hyZh1dTSccVas6pVpiQCIWdM4XIiumSWs2IBozAVErH0QZahZAqyThciITFWaEvBBMfD4STl9VOTIwM8FlI5/Xb1kubzyUH6zb5BUSb3BxTVWz/yZ4cigqAcT10QoZbVgrHYym1SUrmj0/HptDLUQB0WRQCCuaATMaR45OThD/gCLFqykoBWbTtwQB3TMyEajRwBcZUoofJKsbpiYs5UNXOqlScxo7sz87WrQ7pl1JmigoFXSP0SInry8PELci3zEtty4RIbcGYg8gtzkuFhiAATYRJUEgSXMcgBeAzSgDCXMzwBIG31clCXM7TUAVL2g3LNoJNjWC4kBaRs0oKRcaOTY5cLgFKSam1R4iGoWYdAoghicTNd0aciBJ/x8JQeoCDwF2SUsgDDPA/6ArM1gfI0NmVTe6VTgVF287zS0lwDcmRnxJZgEiYn1iKlhoVXWvUl9UNVmAZHFlLUtPey8zgFGrATkRBUdmOTUpMSYhDXk5SRoBVSkKQ4pNblovcnMVAgpm/6YXBmUdEApVgGXEGjkSCmZm1SIUK3UUDySjgEQBGmY9RyUiNR/zwEU8RyZJdxzeJUQtgCIBLwv1qz4RE0aSVTc+RiUrJZpko1WgAT8JXIgcQCDJVUsPCQlA/7h3EFYGHAVA/xn4ATgIEYSJ/zd0gDoPFFKHORp5KKQyH4mahRkj2jNnLIODex8GnlYoQIeU4C23gBYaEYPwmg4B0S0QFVtA3gcBxTgVJ5s8ihdm1VMMDTbA/0QvHFUaVVWAgCCSqxILBz+QqwQE9iMbCpKuqwwagL5QI2O0UH42LVV+L1ewMykUIGVLgIt2knSAVTgpD7DsVSUJPkceEXd2/xESimUmPIo3RisajpIkEx6r/2EbFIotPT7bAVG8QCApFHWXjhQVo3ATDD3DgDAEGABBoSoLEQH/Av4DBAb9Bfz7+gf5CPj3AEHAKgu1BQQFBgcICQoKCwwNDg8QERESExQUFRUWFhcXGBkZGhscHR4fICEiIyQlJSYnKCkqKywtLi4vMDEyMzQ1Njc4OTo7PD0+P0BBQkNERUZHSElKS0xMTU5PUFFSU1RVVldYWVtdX2BiZGVmaGpsbnBydHZ6fH6AgoSGiIqMj5GUl5qdBAAFAAYABwAIAAkACgALAAwADQAOAA8AEAARABIAEwAUABUAFgAXABgAGQAaABsAHAAdAB4AHwAgACEAIgAjACQAJQAmACcAKAApACoAKwAsAC0ALgAvADAAMQAyADMANAA1ADYANwA4ADkAOgA8AD4AQABCAEQARgBIAEoATABOAFAAUgBUAFYAWABaAFwAXgBgAGIAZABmAGgAagBsAG4AcAByAHQAdwB6AH0AgACDAIYAiQCMAI8AkgCVAJgAmwCeAKEApACnAKoArQCxALUAuQC9AMEAxQDJAM0A0QDVANkA3QDhAOUA6gDvAPUA+QD+AAMBCAENARIBFwEcAQgHBgQEAgICAQEBAQACCAAAAAQACAAMAIAAhACIAIwAAAEEAQgBDAGAAYQBiAGMAQABBAgFAgMGCQwNCgcLDg8QFwAAFBcAABkXAAAfFwAArZSMALCbjIcAtJ2NhoIA/v7z5sSxmYyFgoEAAAAAAACKC4wLjguSC5oLqgvKCwoMjAyMDYwPjBMAAAAAAAAAABESAAECAwQFEAYHCAkKCwwNDg8CAwcDAwsAAAAAAAAAGAcXGSgGJykWGiYqOAU3ORUbNjolK0gER0kUHDU7RkokLFhFSzQ8A1dZEx1WWiMtRExVWzM9aAJnaRIeZmoiLlRcQ01lazI+eAF3eVNdER9kbEJOdnohL3V7MT9jbVJeAHR8QU8QIGJuMHN9UV9Acn5hb1Bxf2BwAwQDBAQCAgQEBAIBAQBBgDAL4BGAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGCg4SFhoeIiYqLjI2Oj5CRkpOUlZaXmJmam5ydnp+goaKjpKWmp6ipqqusra6vsLGys7S1tre4ubq7vL2+v8DBwsPExcbHyMnKy8zNzs/Q0dLT1NXW19jZ2tvc3d7f4OHi4+Tl5ufo6err7O3u7/Dx8vP09fb3+Pn6+/z9/v8AAQIDBAUGBwgJCgsMDQ4PEBESExQVFhcYGRobHB0eHyAhIiMkJSYnKCkqKywtLi8wMTIzNDU2Nzg5Ojs8PT4/QEFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaW1xdXl9gYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXp7fH1+f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f38AAAAAAAAAAPDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDx8vP09fb3+Pn6+/z9/v8AAQIDBAUGBwgJCgsMDQ4PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PAEHwwwAL4wgBAgMEBQYHCAkKCwwNDg8QERITFBUWFxgZGhscHR4fICEiIyQlJicoKSorLC0uLzAxMjM0NTY3ODk6Ozw9Pj9AQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVpbXF1eX2BhYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ent8fX5/gIGCg4SFhoeIiYqLjI2Oj5CRkpOUlZaXmJmam5ydnp+goaKjpKWmp6ipqqusra6vsLGys7S1tre4ubq7vL2+v8DBwsPExcbHyMnKy8zNzs/Q0dLT1NXW19jZ2tvc3d7f4OHi4+Tl5ufo6err7O3u7/Dx8vP09fb3+Pn6+/z9/v////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////8AAP/+/fz7+vn49/b19PPy8fDv7u3s6+rp6Ofm5eTj4uHg397d3Nva2djX1tXU09LR0M/OzczLysnIx8bFxMPCwcC/vr28u7q5uLe2tbSzsrGwr66trKuqqainpqWko6KhoJ+enZybmpmYl5aVlJOSkZCPjo2Mi4qJiIeGhYSDgoGAf359fHt6eXh3dnV0c3JxcG9ubWxramloZ2ZlZGNiYWBfXl1cW1pZWFdWVVRTUlFQT05NTEtKSUhHRkVEQ0JBQD8+PTw7Ojk4NzY1NDMyMTAvLi0sKyopKCcmJSQjIiEgHx4dHBsaGRgXFhUUExIREA8ODQwLCgkIBwYFBAMCAQABAgMEBQYHCAkKCwwNDg8QERITFBUWFxgZGhscHR4fICEiIyQlJicoKSorLC0uLzAxMjM0NTY3ODk6Ozw9Pj9AQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVpbXF1eX2BhYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ent8fX5/gIGCg4SFhoeIiYqLjI2Oj5CRkpOUlZaXmJmam5ydnp+goaKjpKWmp6ipqqusra6vsLGys7S1tre4ubq7vL2+v8DBwsPExcbHyMnKy8zNzs/Q0dLT1NXW19jZ2tvc3d7f4OHi4+Tl5ufo6err7O3u7/Dx8vP09fb3+Pn6+/z9/v8AAAAAAAEAAAADAAAABwAAAA8AAAAfAAAAPwAAAH8AAAD/AAAA/wEAAP8DAAD/BwAA/w8AAP8fAAD/PwAA/38AAP//AAD//wEA//8DAP//BwD//w8A//8fAP//PwD//38A////AEHgzAALjQ4wUuENhhizA8usX3dqYogcVVw4aCi4sxT4/oVKS7jdSZfz/GSJAlVcAAApStrBfg2rt0BZfVeSVHLKGU5pjNM4Ze4BDF91oTJS9jdUMiy7WrFXqg/nM/Vz2u5faOLMY3WDDplu7acwR8bZwE88FWtJ+gMUTwz7GlQyC5lzHMvXJgY3zG/Yd7ssKi92dd3MJWRhVLMkFYd9CqgUBCJnvx4UgxW0VuMC5XNvscpEQk0mKPuuunPt61AK+7ZqHQvUOg1oO9s1gx4IK5Vrznfw5YFRvDuFeJSUnwA87eUnTlN0M19fMjEyYmFzaWNfc3RyaW5nSWNOU18xMWNoYXJfdHJhaXRzSWNFRU5TXzlhbGxvY2F0b3JJY0VFRUUAAPQsAAA8JwAATlN0M19fMjEyYmFzaWNfc3RyaW5nSWhOU18xMWNoYXJfdHJhaXRzSWhFRU5TXzlhbGxvY2F0b3JJaEVFRUUAAPQsAACEJwAATlN0M19fMjEyYmFzaWNfc3RyaW5nSXdOU18xMWNoYXJfdHJhaXRzSXdFRU5TXzlhbGxvY2F0b3JJd0VFRUUAAPQsAADMJwAATlN0M19fMjEyYmFzaWNfc3RyaW5nSURzTlNfMTFjaGFyX3RyYWl0c0lEc0VFTlNfOWFsbG9jYXRvcklEc0VFRUUAAAD0LAAAFCgAAE5TdDNfXzIxMmJhc2ljX3N0cmluZ0lEaU5TXzExY2hhcl90cmFpdHNJRGlFRU5TXzlhbGxvY2F0b3JJRGlFRUVFAAAA9CwAAGAoAABOMTBlbXNjcmlwdGVuM3ZhbEUAAPQsAACsKAAATjEwZW1zY3JpcHRlbjExbWVtb3J5X3ZpZXdJY0VFAAD0LAAAyCgAAE4xMGVtc2NyaXB0ZW4xMW1lbW9yeV92aWV3SWFFRQAA9CwAAPAoAABOMTBlbXNjcmlwdGVuMTFtZW1vcnlfdmlld0loRUUAAPQsAAAYKQAATjEwZW1zY3JpcHRlbjExbWVtb3J5X3ZpZXdJc0VFAAD0LAAAQCkAAE4xMGVtc2NyaXB0ZW4xMW1lbW9yeV92aWV3SXRFRQAA9CwAAGgpAABOMTBlbXNjcmlwdGVuMTFtZW1vcnlfdmlld0lpRUUAAPQsAACQKQAATjEwZW1zY3JpcHRlbjExbWVtb3J5X3ZpZXdJakVFAAD0LAAAuCkAAE4xMGVtc2NyaXB0ZW4xMW1lbW9yeV92aWV3SWxFRQAA9CwAAOApAABOMTBlbXNjcmlwdGVuMTFtZW1vcnlfdmlld0ltRUUAAPQsAAAIKgAATjEwZW1zY3JpcHRlbjExbWVtb3J5X3ZpZXdJZkVFAAD0LAAAMCoAAE4xMGVtc2NyaXB0ZW4xMW1lbW9yeV92aWV3SWRFRQAA9CwAAFgqAABOMTBfX2N4eGFiaXYxMTZfX3NoaW1fdHlwZV9pbmZvRQAAAAA0LQAAgCoAACQtAABOMTBfX2N4eGFiaXYxMTdfX2NsYXNzX3R5cGVfaW5mb0UAAAA0LQAAsCoAAKQqAABOMTBfX2N4eGFiaXYxMTdfX3BiYXNlX3R5cGVfaW5mb0UAAAA0LQAA4CoAAKQqAABOMTBfX2N4eGFiaXYxMTlfX3BvaW50ZXJfdHlwZV9pbmZvRQA0LQAAECsAAAQrAAAAAAAAhCsAAGMAAABkAAAAZQAAAGYAAABnAAAATjEwX19jeHhhYml2MTIzX19mdW5kYW1lbnRhbF90eXBlX2luZm9FADQtAABcKwAApCoAAHYAAABIKwAAkCsAAGIAAABIKwAAnCsAAGMAAABIKwAAqCsAAGgAAABIKwAAtCsAAGEAAABIKwAAwCsAAHMAAABIKwAAzCsAAHQAAABIKwAA2CsAAGkAAABIKwAA5CsAAGoAAABIKwAA8CsAAGwAAABIKwAA/CsAAG0AAABIKwAACCwAAHgAAABIKwAAFCwAAHkAAABIKwAAICwAAGYAAABIKwAALCwAAGQAAABIKwAAOCwAAE4xMF9fY3h4YWJpdjEyMF9fc2lfY2xhc3NfdHlwZV9pbmZvRQAAAAA0LQAARCwAANQqAABTdDlleGNlcHRpb24AAAAAAAAAAKwsAAA8AAAAaAAAAGkAAABTdDExbG9naWNfZXJyb3IANC0AAJwsAABULQAAAAAAAOAsAAA8AAAAagAAAGkAAABTdDEybGVuZ3RoX2Vycm9yAAAAADQtAADMLAAArCwAAAAAAADUKgAAYwAAAGsAAABlAAAAZgAAAGwAAABtAAAAbgAAAG8AAABTdDl0eXBlX2luZm8AAAAA9CwAABQtAAAAAAAAbCwAAGMAAABwAAAAZQAAAGYAAABsAAAAcQAAAHIAAABzAAAA9CwAAHgsAAAAAAAAVC0AAHQAAAB1AAAAdgBB8NoACyrwMwEAdC0AAHgtAAB8LQAAgC0AAIQtAACILQAAjC0AAJAtAACULQAAmC0=", self.location.href).href;\n      }\n      function getBinary(file) {\n        try {\n          if (file == wasmBinaryFile && wasmBinary) {\n            return new Uint8Array(wasmBinary);\n          }\n          if (readBinary) {\n            return readBinary(file);\n          }\n          throw "both async and sync fetching of the wasm failed";\n        } catch (err3) {\n          abort(err3);\n        }\n      }\n      function getBinaryPromise(binaryFile) {\n        if (!wasmBinary && (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER)) {\n          if (typeof fetch == "function") {\n            return fetch(binaryFile, { credentials: "same-origin" }).then(function(response) {\n              if (!response["ok"]) {\n                throw "failed to load wasm binary file at \'" + binaryFile + "\'";\n              }\n              return response["arrayBuffer"]();\n            }).catch(function() {\n              return getBinary(binaryFile);\n            });\n          }\n        }\n        return Promise.resolve().then(function() {\n          return getBinary(binaryFile);\n        });\n      }\n      function instantiateArrayBuffer(binaryFile, imports, receiver) {\n        return getBinaryPromise(binaryFile).then(function(binary) {\n          return WebAssembly.instantiate(binary, imports);\n        }).then(function(instance) {\n          return instance;\n        }).then(receiver, function(reason) {\n          err2("failed to asynchronously prepare wasm: " + reason);\n          abort(reason);\n        });\n      }\n      function instantiateAsync(binary, binaryFile, imports, callback) {\n        if (!binary && typeof WebAssembly.instantiateStreaming == "function" && !isDataURI(binaryFile) && typeof fetch == "function") {\n          return fetch(binaryFile, { credentials: "same-origin" }).then(function(response) {\n            var result = WebAssembly.instantiateStreaming(response, imports);\n            return result.then(callback, function(reason) {\n              err2("wasm streaming compile failed: " + reason);\n              err2("falling back to ArrayBuffer instantiation");\n              return instantiateArrayBuffer(binaryFile, imports, callback);\n            });\n          });\n        } else {\n          return instantiateArrayBuffer(binaryFile, imports, callback);\n        }\n      }\n      function createWasm() {\n        var info = { "a": wasmImports };\n        function receiveInstance(instance, module) {\n          var exports = instance.exports;\n          Module2["asm"] = exports;\n          wasmMemory = Module2["asm"]["s"];\n          updateMemoryViews();\n          wasmTable = Module2["asm"]["y"];\n          addOnInit(Module2["asm"]["t"]);\n          removeRunDependency();\n          return exports;\n        }\n        addRunDependency();\n        function receiveInstantiationResult(result) {\n          receiveInstance(result["instance"]);\n        }\n        if (Module2["instantiateWasm"]) {\n          try {\n            return Module2["instantiateWasm"](info, receiveInstance);\n          } catch (e) {\n            err2("Module.instantiateWasm callback failed with error: " + e);\n            readyPromiseReject(e);\n          }\n        }\n        instantiateAsync(wasmBinary, wasmBinaryFile, info, receiveInstantiationResult).catch(readyPromiseReject);\n        return {};\n      }\n      function callRuntimeCallbacks(callbacks) {\n        while (callbacks.length > 0) {\n          callbacks.shift()(Module2);\n        }\n      }\n      function ExceptionInfo(excPtr) {\n        this.excPtr = excPtr;\n        this.ptr = excPtr - 24;\n        this.set_type = function(type) {\n          HEAPU32[this.ptr + 4 >> 2] = type;\n        };\n        this.get_type = function() {\n          return HEAPU32[this.ptr + 4 >> 2];\n        };\n        this.set_destructor = function(destructor) {\n          HEAPU32[this.ptr + 8 >> 2] = destructor;\n        };\n        this.get_destructor = function() {\n          return HEAPU32[this.ptr + 8 >> 2];\n        };\n        this.set_refcount = function(refcount) {\n          HEAP32[this.ptr >> 2] = refcount;\n        };\n        this.set_caught = function(caught) {\n          caught = caught ? 1 : 0;\n          HEAP8[this.ptr + 12 >> 0] = caught;\n        };\n        this.get_caught = function() {\n          return HEAP8[this.ptr + 12 >> 0] != 0;\n        };\n        this.set_rethrown = function(rethrown) {\n          rethrown = rethrown ? 1 : 0;\n          HEAP8[this.ptr + 13 >> 0] = rethrown;\n        };\n        this.get_rethrown = function() {\n          return HEAP8[this.ptr + 13 >> 0] != 0;\n        };\n        this.init = function(type, destructor) {\n          this.set_adjusted_ptr(0);\n          this.set_type(type);\n          this.set_destructor(destructor);\n          this.set_refcount(0);\n          this.set_caught(false);\n          this.set_rethrown(false);\n        };\n        this.add_ref = function() {\n          var value = HEAP32[this.ptr >> 2];\n          HEAP32[this.ptr >> 2] = value + 1;\n        };\n        this.release_ref = function() {\n          var prev = HEAP32[this.ptr >> 2];\n          HEAP32[this.ptr >> 2] = prev - 1;\n          return prev === 1;\n        };\n        this.set_adjusted_ptr = function(adjustedPtr) {\n          HEAPU32[this.ptr + 16 >> 2] = adjustedPtr;\n        };\n        this.get_adjusted_ptr = function() {\n          return HEAPU32[this.ptr + 16 >> 2];\n        };\n        this.get_exception_ptr = function() {\n          var isPointer = ___cxa_is_pointer_type(this.get_type());\n          if (isPointer) {\n            return HEAPU32[this.excPtr >> 2];\n          }\n          var adjusted = this.get_adjusted_ptr();\n          if (adjusted !== 0) return adjusted;\n          return this.excPtr;\n        };\n      }\n      function ___cxa_throw(ptr, type, destructor) {\n        var info = new ExceptionInfo(ptr);\n        info.init(type, destructor);\n        throw ptr;\n      }\n      function __embind_register_bigint(primitiveType, name, size, minRange, maxRange) {\n      }\n      function getShiftFromSize(size) {\n        switch (size) {\n          case 1:\n            return 0;\n          case 2:\n            return 1;\n          case 4:\n            return 2;\n          case 8:\n            return 3;\n          default:\n            throw new TypeError("Unknown type size: " + size);\n        }\n      }\n      function embind_init_charCodes() {\n        var codes = new Array(256);\n        for (var i2 = 0; i2 < 256; ++i2) {\n          codes[i2] = String.fromCharCode(i2);\n        }\n        embind_charCodes = codes;\n      }\n      var embind_charCodes = void 0;\n      function readLatin1String(ptr) {\n        var ret = "";\n        var c = ptr;\n        while (HEAPU8[c]) {\n          ret += embind_charCodes[HEAPU8[c++]];\n        }\n        return ret;\n      }\n      var awaitingDependencies = {};\n      var registeredTypes = {};\n      var typeDependencies = {};\n      var char_0 = 48;\n      var char_9 = 57;\n      function makeLegalFunctionName(name) {\n        if (void 0 === name) {\n          return "_unknown";\n        }\n        name = name.replace(/[^a-zA-Z0-9_]/g, "$");\n        var f = name.charCodeAt(0);\n        if (f >= char_0 && f <= char_9) {\n          return "_" + name;\n        }\n        return name;\n      }\n      function createNamedFunction(name, body) {\n        name = makeLegalFunctionName(name);\n        return { [name]: function() {\n          return body.apply(this, arguments);\n        } }[name];\n      }\n      function extendError(baseErrorType, errorName) {\n        var errorClass = createNamedFunction(errorName, function(message) {\n          this.name = errorName;\n          this.message = message;\n          var stack = new Error(message).stack;\n          if (stack !== void 0) {\n            this.stack = this.toString() + "\\n" + stack.replace(/^Error(:[^\\n]*)?\\n/, "");\n          }\n        });\n        errorClass.prototype = Object.create(baseErrorType.prototype);\n        errorClass.prototype.constructor = errorClass;\n        errorClass.prototype.toString = function() {\n          if (this.message === void 0) {\n            return this.name;\n          } else {\n            return this.name + ": " + this.message;\n          }\n        };\n        return errorClass;\n      }\n      var BindingError = void 0;\n      function throwBindingError(message) {\n        throw new BindingError(message);\n      }\n      var InternalError = void 0;\n      function throwInternalError(message) {\n        throw new InternalError(message);\n      }\n      function whenDependentTypesAreResolved(myTypes, dependentTypes, getTypeConverters) {\n        myTypes.forEach(function(type) {\n          typeDependencies[type] = dependentTypes;\n        });\n        function onComplete(typeConverters2) {\n          var myTypeConverters = getTypeConverters(typeConverters2);\n          if (myTypeConverters.length !== myTypes.length) {\n            throwInternalError("Mismatched type converter count");\n          }\n          for (var i2 = 0; i2 < myTypes.length; ++i2) {\n            registerType(myTypes[i2], myTypeConverters[i2]);\n          }\n        }\n        var typeConverters = new Array(dependentTypes.length);\n        var unregisteredTypes = [];\n        var registered = 0;\n        dependentTypes.forEach((dt, i2) => {\n          if (registeredTypes.hasOwnProperty(dt)) {\n            typeConverters[i2] = registeredTypes[dt];\n          } else {\n            unregisteredTypes.push(dt);\n            if (!awaitingDependencies.hasOwnProperty(dt)) {\n              awaitingDependencies[dt] = [];\n            }\n            awaitingDependencies[dt].push(() => {\n              typeConverters[i2] = registeredTypes[dt];\n              ++registered;\n              if (registered === unregisteredTypes.length) {\n                onComplete(typeConverters);\n              }\n            });\n          }\n        });\n        if (0 === unregisteredTypes.length) {\n          onComplete(typeConverters);\n        }\n      }\n      function registerType(rawType, registeredInstance, options = {}) {\n        if (!("argPackAdvance" in registeredInstance)) {\n          throw new TypeError("registerType registeredInstance requires argPackAdvance");\n        }\n        var name = registeredInstance.name;\n        if (!rawType) {\n          throwBindingError(\'type "\' + name + \'" must have a positive integer typeid pointer\');\n        }\n        if (registeredTypes.hasOwnProperty(rawType)) {\n          if (options.ignoreDuplicateRegistrations) {\n            return;\n          } else {\n            throwBindingError("Cannot register type \'" + name + "\' twice");\n          }\n        }\n        registeredTypes[rawType] = registeredInstance;\n        delete typeDependencies[rawType];\n        if (awaitingDependencies.hasOwnProperty(rawType)) {\n          var callbacks = awaitingDependencies[rawType];\n          delete awaitingDependencies[rawType];\n          callbacks.forEach((cb) => cb());\n        }\n      }\n      function __embind_register_bool(rawType, name, size, trueValue, falseValue) {\n        var shift = getShiftFromSize(size);\n        name = readLatin1String(name);\n        registerType(rawType, { name, "fromWireType": function(wt) {\n          return !!wt;\n        }, "toWireType": function(destructors, o) {\n          return o ? trueValue : falseValue;\n        }, "argPackAdvance": 8, "readValueFromPointer": function(pointer) {\n          var heap;\n          if (size === 1) {\n            heap = HEAP8;\n          } else if (size === 2) {\n            heap = HEAP16;\n          } else if (size === 4) {\n            heap = HEAP32;\n          } else {\n            throw new TypeError("Unknown boolean type size: " + name);\n          }\n          return this["fromWireType"](heap[pointer >> shift]);\n        }, destructorFunction: null });\n      }\n      var emval_free_list = [];\n      var emval_handle_array = [{}, { value: void 0 }, { value: null }, { value: true }, { value: false }];\n      function __emval_decref(handle) {\n        if (handle > 4 && 0 === --emval_handle_array[handle].refcount) {\n          emval_handle_array[handle] = void 0;\n          emval_free_list.push(handle);\n        }\n      }\n      function count_emval_handles() {\n        var count = 0;\n        for (var i2 = 5; i2 < emval_handle_array.length; ++i2) {\n          if (emval_handle_array[i2] !== void 0) {\n            ++count;\n          }\n        }\n        return count;\n      }\n      function get_first_emval() {\n        for (var i2 = 5; i2 < emval_handle_array.length; ++i2) {\n          if (emval_handle_array[i2] !== void 0) {\n            return emval_handle_array[i2];\n          }\n        }\n        return null;\n      }\n      function init_emval() {\n        Module2["count_emval_handles"] = count_emval_handles;\n        Module2["get_first_emval"] = get_first_emval;\n      }\n      var Emval = { toValue: (handle) => {\n        if (!handle) {\n          throwBindingError("Cannot use deleted val. handle = " + handle);\n        }\n        return emval_handle_array[handle].value;\n      }, toHandle: (value) => {\n        switch (value) {\n          case void 0:\n            return 1;\n          case null:\n            return 2;\n          case true:\n            return 3;\n          case false:\n            return 4;\n          default: {\n            var handle = emval_free_list.length ? emval_free_list.pop() : emval_handle_array.length;\n            emval_handle_array[handle] = { refcount: 1, value };\n            return handle;\n          }\n        }\n      } };\n      function simpleReadValueFromPointer(pointer) {\n        return this["fromWireType"](HEAP32[pointer >> 2]);\n      }\n      function __embind_register_emval(rawType, name) {\n        name = readLatin1String(name);\n        registerType(rawType, { name, "fromWireType": function(handle) {\n          var rv = Emval.toValue(handle);\n          __emval_decref(handle);\n          return rv;\n        }, "toWireType": function(destructors, value) {\n          return Emval.toHandle(value);\n        }, "argPackAdvance": 8, "readValueFromPointer": simpleReadValueFromPointer, destructorFunction: null });\n      }\n      function floatReadValueFromPointer(name, shift) {\n        switch (shift) {\n          case 2:\n            return function(pointer) {\n              return this["fromWireType"](HEAPF32[pointer >> 2]);\n            };\n          case 3:\n            return function(pointer) {\n              return this["fromWireType"](HEAPF64[pointer >> 3]);\n            };\n          default:\n            throw new TypeError("Unknown float type: " + name);\n        }\n      }\n      function __embind_register_float(rawType, name, size) {\n        var shift = getShiftFromSize(size);\n        name = readLatin1String(name);\n        registerType(rawType, { name, "fromWireType": function(value) {\n          return value;\n        }, "toWireType": function(destructors, value) {\n          return value;\n        }, "argPackAdvance": 8, "readValueFromPointer": floatReadValueFromPointer(name, shift), destructorFunction: null });\n      }\n      function runDestructors(destructors) {\n        while (destructors.length) {\n          var ptr = destructors.pop();\n          var del = destructors.pop();\n          del(ptr);\n        }\n      }\n      function craftInvokerFunction(humanName, argTypes, classType, cppInvokerFunc, cppTargetFunc, isAsync) {\n        var argCount = argTypes.length;\n        if (argCount < 2) {\n          throwBindingError("argTypes array size mismatch! Must at least get return value and \'this\' types!");\n        }\n        argTypes[1] !== null && classType !== null;\n        var needsDestructorStack = false;\n        for (var i2 = 1; i2 < argTypes.length; ++i2) {\n          if (argTypes[i2] !== null && argTypes[i2].destructorFunction === void 0) {\n            needsDestructorStack = true;\n            break;\n          }\n        }\n        var returns = argTypes[0].name !== "void";\n        var expectedArgCount = argCount - 2;\n        var argsWired = new Array(expectedArgCount);\n        var invokerFuncArgs = [];\n        var destructors = [];\n        return function() {\n          if (arguments.length !== expectedArgCount) {\n            throwBindingError("function " + humanName + " called with " + arguments.length + " arguments, expected " + expectedArgCount + " args!");\n          }\n          destructors.length = 0;\n          var thisWired;\n          invokerFuncArgs.length = 1;\n          invokerFuncArgs[0] = cppTargetFunc;\n          for (var i3 = 0; i3 < expectedArgCount; ++i3) {\n            argsWired[i3] = argTypes[i3 + 2]["toWireType"](destructors, arguments[i3]);\n            invokerFuncArgs.push(argsWired[i3]);\n          }\n          var rv = cppInvokerFunc.apply(null, invokerFuncArgs);\n          function onDone(rv2) {\n            if (needsDestructorStack) {\n              runDestructors(destructors);\n            } else {\n              for (var i4 = 2; i4 < argTypes.length; i4++) {\n                var param = i4 === 1 ? thisWired : argsWired[i4 - 2];\n                if (argTypes[i4].destructorFunction !== null) {\n                  argTypes[i4].destructorFunction(param);\n                }\n              }\n            }\n            if (returns) {\n              return argTypes[0]["fromWireType"](rv2);\n            }\n          }\n          return onDone(rv);\n        };\n      }\n      function ensureOverloadTable(proto, methodName, humanName) {\n        if (void 0 === proto[methodName].overloadTable) {\n          var prevFunc = proto[methodName];\n          proto[methodName] = function() {\n            if (!proto[methodName].overloadTable.hasOwnProperty(arguments.length)) {\n              throwBindingError("Function \'" + humanName + "\' called with an invalid number of arguments (" + arguments.length + ") - expects one of (" + proto[methodName].overloadTable + ")!");\n            }\n            return proto[methodName].overloadTable[arguments.length].apply(this, arguments);\n          };\n          proto[methodName].overloadTable = [];\n          proto[methodName].overloadTable[prevFunc.argCount] = prevFunc;\n        }\n      }\n      function exposePublicSymbol(name, value, numArguments) {\n        if (Module2.hasOwnProperty(name)) {\n          if (void 0 === numArguments || void 0 !== Module2[name].overloadTable && void 0 !== Module2[name].overloadTable[numArguments]) {\n            throwBindingError("Cannot register public name \'" + name + "\' twice");\n          }\n          ensureOverloadTable(Module2, name, name);\n          if (Module2.hasOwnProperty(numArguments)) {\n            throwBindingError("Cannot register multiple overloads of a function with the same number of arguments (" + numArguments + ")!");\n          }\n          Module2[name].overloadTable[numArguments] = value;\n        } else {\n          Module2[name] = value;\n          if (void 0 !== numArguments) {\n            Module2[name].numArguments = numArguments;\n          }\n        }\n      }\n      function heap32VectorToArray(count, firstElement) {\n        var array = [];\n        for (var i2 = 0; i2 < count; i2++) {\n          array.push(HEAPU32[firstElement + i2 * 4 >> 2]);\n        }\n        return array;\n      }\n      function replacePublicSymbol(name, value, numArguments) {\n        if (!Module2.hasOwnProperty(name)) {\n          throwInternalError("Replacing nonexistant public symbol");\n        }\n        if (void 0 !== Module2[name].overloadTable && void 0 !== numArguments) {\n          Module2[name].overloadTable[numArguments] = value;\n        } else {\n          Module2[name] = value;\n          Module2[name].argCount = numArguments;\n        }\n      }\n      function dynCallLegacy(sig, ptr, args) {\n        var f = Module2["dynCall_" + sig];\n        return args && args.length ? f.apply(null, [ptr].concat(args)) : f.call(null, ptr);\n      }\n      var wasmTableMirror = [];\n      function getWasmTableEntry(funcPtr) {\n        var func = wasmTableMirror[funcPtr];\n        if (!func) {\n          if (funcPtr >= wasmTableMirror.length) wasmTableMirror.length = funcPtr + 1;\n          wasmTableMirror[funcPtr] = func = wasmTable.get(funcPtr);\n        }\n        return func;\n      }\n      function dynCall(sig, ptr, args) {\n        if (sig.includes("j")) {\n          return dynCallLegacy(sig, ptr, args);\n        }\n        var rtn = getWasmTableEntry(ptr).apply(null, args);\n        return rtn;\n      }\n      function getDynCaller(sig, ptr) {\n        var argCache = [];\n        return function() {\n          argCache.length = 0;\n          Object.assign(argCache, arguments);\n          return dynCall(sig, ptr, argCache);\n        };\n      }\n      function embind__requireFunction(signature, rawFunction) {\n        signature = readLatin1String(signature);\n        function makeDynCaller() {\n          if (signature.includes("j")) {\n            return getDynCaller(signature, rawFunction);\n          }\n          return getWasmTableEntry(rawFunction);\n        }\n        var fp = makeDynCaller();\n        if (typeof fp != "function") {\n          throwBindingError("unknown function pointer with signature " + signature + ": " + rawFunction);\n        }\n        return fp;\n      }\n      var UnboundTypeError = void 0;\n      function getTypeName(type) {\n        var ptr = ___getTypeName(type);\n        var rv = readLatin1String(ptr);\n        _free(ptr);\n        return rv;\n      }\n      function throwUnboundTypeError(message, types) {\n        var unboundTypes = [];\n        var seen = {};\n        function visit(type) {\n          if (seen[type]) {\n            return;\n          }\n          if (registeredTypes[type]) {\n            return;\n          }\n          if (typeDependencies[type]) {\n            typeDependencies[type].forEach(visit);\n            return;\n          }\n          unboundTypes.push(type);\n          seen[type] = true;\n        }\n        types.forEach(visit);\n        throw new UnboundTypeError(message + ": " + unboundTypes.map(getTypeName).join([", "]));\n      }\n      function __embind_register_function(name, argCount, rawArgTypesAddr, signature, rawInvoker, fn, isAsync) {\n        var argTypes = heap32VectorToArray(argCount, rawArgTypesAddr);\n        name = readLatin1String(name);\n        rawInvoker = embind__requireFunction(signature, rawInvoker);\n        exposePublicSymbol(name, function() {\n          throwUnboundTypeError("Cannot call " + name + " due to unbound types", argTypes);\n        }, argCount - 1);\n        whenDependentTypesAreResolved([], argTypes, function(argTypes2) {\n          var invokerArgsArray = [argTypes2[0], null].concat(argTypes2.slice(1));\n          replacePublicSymbol(name, craftInvokerFunction(name, invokerArgsArray, null, rawInvoker, fn), argCount - 1);\n          return [];\n        });\n      }\n      function integerReadValueFromPointer(name, shift, signed) {\n        switch (shift) {\n          case 0:\n            return signed ? function readS8FromPointer(pointer) {\n              return HEAP8[pointer];\n            } : function readU8FromPointer(pointer) {\n              return HEAPU8[pointer];\n            };\n          case 1:\n            return signed ? function readS16FromPointer(pointer) {\n              return HEAP16[pointer >> 1];\n            } : function readU16FromPointer(pointer) {\n              return HEAPU16[pointer >> 1];\n            };\n          case 2:\n            return signed ? function readS32FromPointer(pointer) {\n              return HEAP32[pointer >> 2];\n            } : function readU32FromPointer(pointer) {\n              return HEAPU32[pointer >> 2];\n            };\n          default:\n            throw new TypeError("Unknown integer type: " + name);\n        }\n      }\n      function __embind_register_integer(primitiveType, name, size, minRange, maxRange) {\n        name = readLatin1String(name);\n        var shift = getShiftFromSize(size);\n        var fromWireType = (value) => value;\n        if (minRange === 0) {\n          var bitshift = 32 - 8 * size;\n          fromWireType = (value) => value << bitshift >>> bitshift;\n        }\n        var isUnsignedType = name.includes("unsigned");\n        var checkAssertions = (value, toTypeName) => {\n        };\n        var toWireType;\n        if (isUnsignedType) {\n          toWireType = function(destructors, value) {\n            checkAssertions(value, this.name);\n            return value >>> 0;\n          };\n        } else {\n          toWireType = function(destructors, value) {\n            checkAssertions(value, this.name);\n            return value;\n          };\n        }\n        registerType(primitiveType, { name, "fromWireType": fromWireType, "toWireType": toWireType, "argPackAdvance": 8, "readValueFromPointer": integerReadValueFromPointer(name, shift, minRange !== 0), destructorFunction: null });\n      }\n      function __embind_register_memory_view(rawType, dataTypeIndex, name) {\n        var typeMapping = [Int8Array, Uint8Array, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array];\n        var TA = typeMapping[dataTypeIndex];\n        function decodeMemoryView(handle) {\n          handle = handle >> 2;\n          var heap = HEAPU32;\n          var size = heap[handle];\n          var data = heap[handle + 1];\n          return new TA(heap.buffer, data, size);\n        }\n        name = readLatin1String(name);\n        registerType(rawType, { name, "fromWireType": decodeMemoryView, "argPackAdvance": 8, "readValueFromPointer": decodeMemoryView }, { ignoreDuplicateRegistrations: true });\n      }\n      function __embind_register_std_string(rawType, name) {\n        name = readLatin1String(name);\n        var stdStringIsUTF8 = name === "std::string";\n        registerType(rawType, { name, "fromWireType": function(value) {\n          var length = HEAPU32[value >> 2];\n          var payload = value + 4;\n          var str;\n          if (stdStringIsUTF8) {\n            var decodeStartPtr = payload;\n            for (var i2 = 0; i2 <= length; ++i2) {\n              var currentBytePtr = payload + i2;\n              if (i2 == length || HEAPU8[currentBytePtr] == 0) {\n                var maxRead = currentBytePtr - decodeStartPtr;\n                var stringSegment = UTF8ToString(decodeStartPtr, maxRead);\n                if (str === void 0) {\n                  str = stringSegment;\n                } else {\n                  str += String.fromCharCode(0);\n                  str += stringSegment;\n                }\n                decodeStartPtr = currentBytePtr + 1;\n              }\n            }\n          } else {\n            var a = new Array(length);\n            for (var i2 = 0; i2 < length; ++i2) {\n              a[i2] = String.fromCharCode(HEAPU8[payload + i2]);\n            }\n            str = a.join("");\n          }\n          _free(value);\n          return str;\n        }, "toWireType": function(destructors, value) {\n          if (value instanceof ArrayBuffer) {\n            value = new Uint8Array(value);\n          }\n          var length;\n          var valueIsOfTypeString = typeof value == "string";\n          if (!(valueIsOfTypeString || value instanceof Uint8Array || value instanceof Uint8ClampedArray || value instanceof Int8Array)) {\n            throwBindingError("Cannot pass non-string to std::string");\n          }\n          if (stdStringIsUTF8 && valueIsOfTypeString) {\n            length = lengthBytesUTF8(value);\n          } else {\n            length = value.length;\n          }\n          var base = _malloc(4 + length + 1);\n          var ptr = base + 4;\n          HEAPU32[base >> 2] = length;\n          if (stdStringIsUTF8 && valueIsOfTypeString) {\n            stringToUTF8(value, ptr, length + 1);\n          } else {\n            if (valueIsOfTypeString) {\n              for (var i2 = 0; i2 < length; ++i2) {\n                var charCode = value.charCodeAt(i2);\n                if (charCode > 255) {\n                  _free(ptr);\n                  throwBindingError("String has UTF-16 code units that do not fit in 8 bits");\n                }\n                HEAPU8[ptr + i2] = charCode;\n              }\n            } else {\n              for (var i2 = 0; i2 < length; ++i2) {\n                HEAPU8[ptr + i2] = value[i2];\n              }\n            }\n          }\n          if (destructors !== null) {\n            destructors.push(_free, base);\n          }\n          return base;\n        }, "argPackAdvance": 8, "readValueFromPointer": simpleReadValueFromPointer, destructorFunction: function(ptr) {\n          _free(ptr);\n        } });\n      }\n      function UTF16ToString(ptr, maxBytesToRead) {\n        var str = "";\n        for (var i2 = 0; !(i2 >= maxBytesToRead / 2); ++i2) {\n          var codeUnit = HEAP16[ptr + i2 * 2 >> 1];\n          if (codeUnit == 0) break;\n          str += String.fromCharCode(codeUnit);\n        }\n        return str;\n      }\n      function stringToUTF16(str, outPtr, maxBytesToWrite) {\n        if (maxBytesToWrite === void 0) {\n          maxBytesToWrite = 2147483647;\n        }\n        if (maxBytesToWrite < 2) return 0;\n        maxBytesToWrite -= 2;\n        var startPtr = outPtr;\n        var numCharsToWrite = maxBytesToWrite < str.length * 2 ? maxBytesToWrite / 2 : str.length;\n        for (var i2 = 0; i2 < numCharsToWrite; ++i2) {\n          var codeUnit = str.charCodeAt(i2);\n          HEAP16[outPtr >> 1] = codeUnit;\n          outPtr += 2;\n        }\n        HEAP16[outPtr >> 1] = 0;\n        return outPtr - startPtr;\n      }\n      function lengthBytesUTF16(str) {\n        return str.length * 2;\n      }\n      function UTF32ToString(ptr, maxBytesToRead) {\n        var i2 = 0;\n        var str = "";\n        while (!(i2 >= maxBytesToRead / 4)) {\n          var utf32 = HEAP32[ptr + i2 * 4 >> 2];\n          if (utf32 == 0) break;\n          ++i2;\n          if (utf32 >= 65536) {\n            var ch = utf32 - 65536;\n            str += String.fromCharCode(55296 | ch >> 10, 56320 | ch & 1023);\n          } else {\n            str += String.fromCharCode(utf32);\n          }\n        }\n        return str;\n      }\n      function stringToUTF32(str, outPtr, maxBytesToWrite) {\n        if (maxBytesToWrite === void 0) {\n          maxBytesToWrite = 2147483647;\n        }\n        if (maxBytesToWrite < 4) return 0;\n        var startPtr = outPtr;\n        var endPtr = startPtr + maxBytesToWrite - 4;\n        for (var i2 = 0; i2 < str.length; ++i2) {\n          var codeUnit = str.charCodeAt(i2);\n          if (codeUnit >= 55296 && codeUnit <= 57343) {\n            var trailSurrogate = str.charCodeAt(++i2);\n            codeUnit = 65536 + ((codeUnit & 1023) << 10) | trailSurrogate & 1023;\n          }\n          HEAP32[outPtr >> 2] = codeUnit;\n          outPtr += 4;\n          if (outPtr + 4 > endPtr) break;\n        }\n        HEAP32[outPtr >> 2] = 0;\n        return outPtr - startPtr;\n      }\n      function lengthBytesUTF32(str) {\n        var len = 0;\n        for (var i2 = 0; i2 < str.length; ++i2) {\n          var codeUnit = str.charCodeAt(i2);\n          if (codeUnit >= 55296 && codeUnit <= 57343) ++i2;\n          len += 4;\n        }\n        return len;\n      }\n      function __embind_register_std_wstring(rawType, charSize, name) {\n        name = readLatin1String(name);\n        var decodeString, encodeString, getHeap, lengthBytesUTF, shift;\n        if (charSize === 2) {\n          decodeString = UTF16ToString;\n          encodeString = stringToUTF16;\n          lengthBytesUTF = lengthBytesUTF16;\n          getHeap = () => HEAPU16;\n          shift = 1;\n        } else if (charSize === 4) {\n          decodeString = UTF32ToString;\n          encodeString = stringToUTF32;\n          lengthBytesUTF = lengthBytesUTF32;\n          getHeap = () => HEAPU32;\n          shift = 2;\n        }\n        registerType(rawType, { name, "fromWireType": function(value) {\n          var length = HEAPU32[value >> 2];\n          var HEAP = getHeap();\n          var str;\n          var decodeStartPtr = value + 4;\n          for (var i2 = 0; i2 <= length; ++i2) {\n            var currentBytePtr = value + 4 + i2 * charSize;\n            if (i2 == length || HEAP[currentBytePtr >> shift] == 0) {\n              var maxReadBytes = currentBytePtr - decodeStartPtr;\n              var stringSegment = decodeString(decodeStartPtr, maxReadBytes);\n              if (str === void 0) {\n                str = stringSegment;\n              } else {\n                str += String.fromCharCode(0);\n                str += stringSegment;\n              }\n              decodeStartPtr = currentBytePtr + charSize;\n            }\n          }\n          _free(value);\n          return str;\n        }, "toWireType": function(destructors, value) {\n          if (!(typeof value == "string")) {\n            throwBindingError("Cannot pass non-string to C++ string type " + name);\n          }\n          var length = lengthBytesUTF(value);\n          var ptr = _malloc(4 + length + charSize);\n          HEAPU32[ptr >> 2] = length >> shift;\n          encodeString(value, ptr + 4, length + charSize);\n          if (destructors !== null) {\n            destructors.push(_free, ptr);\n          }\n          return ptr;\n        }, "argPackAdvance": 8, "readValueFromPointer": simpleReadValueFromPointer, destructorFunction: function(ptr) {\n          _free(ptr);\n        } });\n      }\n      function __embind_register_void(rawType, name) {\n        name = readLatin1String(name);\n        registerType(rawType, { isVoid: true, name, "argPackAdvance": 0, "fromWireType": function() {\n          return void 0;\n        }, "toWireType": function(destructors, o) {\n          return void 0;\n        } });\n      }\n      var emval_symbols = {};\n      function getStringOrSymbol(address) {\n        var symbol = emval_symbols[address];\n        if (symbol === void 0) {\n          return readLatin1String(address);\n        }\n        return symbol;\n      }\n      function emval_get_global() {\n        if (typeof globalThis == "object") {\n          return globalThis;\n        }\n        function testGlobal(obj) {\n          obj["$$$embind_global$$$"] = obj;\n          var success = typeof $$$embind_global$$$ == "object" && obj["$$$embind_global$$$"] == obj;\n          if (!success) {\n            delete obj["$$$embind_global$$$"];\n          }\n          return success;\n        }\n        if (typeof $$$embind_global$$$ == "object") {\n          return $$$embind_global$$$;\n        }\n        if (typeof global == "object" && testGlobal(global)) {\n          $$$embind_global$$$ = global;\n        } else if (typeof self == "object" && testGlobal(self)) {\n          $$$embind_global$$$ = self;\n        }\n        if (typeof $$$embind_global$$$ == "object") {\n          return $$$embind_global$$$;\n        }\n        throw Error("unable to get global object.");\n      }\n      function __emval_get_global(name) {\n        if (name === 0) {\n          return Emval.toHandle(emval_get_global());\n        } else {\n          name = getStringOrSymbol(name);\n          return Emval.toHandle(emval_get_global()[name]);\n        }\n      }\n      function __emval_incref(handle) {\n        if (handle > 4) {\n          emval_handle_array[handle].refcount += 1;\n        }\n      }\n      function requireRegisteredType(rawType, humanName) {\n        var impl = registeredTypes[rawType];\n        if (void 0 === impl) {\n          throwBindingError(humanName + " has unknown type " + getTypeName(rawType));\n        }\n        return impl;\n      }\n      function craftEmvalAllocator(argCount) {\n        var argsList = new Array(argCount + 1);\n        return function(constructor, argTypes, args) {\n          argsList[0] = constructor;\n          for (var i2 = 0; i2 < argCount; ++i2) {\n            var argType = requireRegisteredType(HEAPU32[argTypes + i2 * 4 >> 2], "parameter " + i2);\n            argsList[i2 + 1] = argType["readValueFromPointer"](args);\n            args += argType["argPackAdvance"];\n          }\n          var obj = new (constructor.bind.apply(constructor, argsList))();\n          return Emval.toHandle(obj);\n        };\n      }\n      var emval_newers = {};\n      function __emval_new(handle, argCount, argTypes, args) {\n        handle = Emval.toValue(handle);\n        var newer = emval_newers[argCount];\n        if (!newer) {\n          newer = craftEmvalAllocator(argCount);\n          emval_newers[argCount] = newer;\n        }\n        return newer(handle, argTypes, args);\n      }\n      function _abort() {\n        abort("");\n      }\n      function _emscripten_memcpy_big(dest, src, num) {\n        HEAPU8.copyWithin(dest, src, src + num);\n      }\n      function getHeapMax() {\n        return 2147483648;\n      }\n      function emscripten_realloc_buffer(size) {\n        var b = wasmMemory.buffer;\n        try {\n          wasmMemory.grow(size - b.byteLength + 65535 >>> 16);\n          updateMemoryViews();\n          return 1;\n        } catch (e) {\n        }\n      }\n      function _emscripten_resize_heap(requestedSize) {\n        var oldSize = HEAPU8.length;\n        requestedSize = requestedSize >>> 0;\n        var maxHeapSize = getHeapMax();\n        if (requestedSize > maxHeapSize) {\n          return false;\n        }\n        let alignUp = (x2, multiple) => x2 + (multiple - x2 % multiple) % multiple;\n        for (var cutDown = 1; cutDown <= 4; cutDown *= 2) {\n          var overGrownHeapSize = oldSize * (1 + 0.2 / cutDown);\n          overGrownHeapSize = Math.min(overGrownHeapSize, requestedSize + 100663296);\n          var newSize = Math.min(maxHeapSize, alignUp(Math.max(requestedSize, overGrownHeapSize), 65536));\n          var replacement = emscripten_realloc_buffer(newSize);\n          if (replacement) {\n            return true;\n          }\n        }\n        return false;\n      }\n      embind_init_charCodes();\n      BindingError = Module2["BindingError"] = extendError(Error, "BindingError");\n      InternalError = Module2["InternalError"] = extendError(Error, "InternalError");\n      init_emval();\n      UnboundTypeError = Module2["UnboundTypeError"] = extendError(Error, "UnboundTypeError");\n      var wasmImports = { "n": ___cxa_throw, "o": __embind_register_bigint, "l": __embind_register_bool, "r": __embind_register_emval, "k": __embind_register_float, "c": __embind_register_function, "b": __embind_register_integer, "a": __embind_register_memory_view, "g": __embind_register_std_string, "f": __embind_register_std_wstring, "m": __embind_register_void, "d": __emval_decref, "e": __emval_get_global, "i": __emval_incref, "h": __emval_new, "j": _abort, "q": _emscripten_memcpy_big, "p": _emscripten_resize_heap };\n      createWasm();\n      var _malloc = function() {\n        return (_malloc = Module2["asm"]["u"]).apply(null, arguments);\n      };\n      var _free = function() {\n        return (_free = Module2["asm"]["v"]).apply(null, arguments);\n      };\n      var ___getTypeName = Module2["___getTypeName"] = function() {\n        return (___getTypeName = Module2["___getTypeName"] = Module2["asm"]["w"]).apply(null, arguments);\n      };\n      Module2["__embind_initialize_bindings"] = function() {\n        return (Module2["__embind_initialize_bindings"] = Module2["asm"]["x"]).apply(null, arguments);\n      };\n      var ___cxa_is_pointer_type = function() {\n        return (___cxa_is_pointer_type = Module2["asm"]["z"]).apply(null, arguments);\n      };\n      var calledRun;\n      dependenciesFulfilled = function runCaller() {\n        if (!calledRun) run();\n        if (!calledRun) dependenciesFulfilled = runCaller;\n      };\n      function run() {\n        if (runDependencies > 0) {\n          return;\n        }\n        preRun();\n        if (runDependencies > 0) {\n          return;\n        }\n        function doRun() {\n          if (calledRun) return;\n          calledRun = true;\n          Module2["calledRun"] = true;\n          if (ABORT) return;\n          initRuntime();\n          readyPromiseResolve(Module2);\n          if (Module2["onRuntimeInitialized"]) Module2["onRuntimeInitialized"]();\n          postRun();\n        }\n        if (Module2["setStatus"]) {\n          Module2["setStatus"]("Running...");\n          setTimeout(function() {\n            setTimeout(function() {\n              Module2["setStatus"]("");\n            }, 1);\n            doRun();\n          }, 1);\n        } else {\n          doRun();\n        }\n      }\n      if (Module2["preInit"]) {\n        if (typeof Module2["preInit"] == "function") Module2["preInit"] = [Module2["preInit"]];\n        while (Module2["preInit"].length > 0) {\n          Module2["preInit"].pop()();\n        }\n      }\n      run();\n      return Module2.ready;\n    };\n  })();\n  let emscriptenModule;\n  async function init(module, moduleOptionOverrides) {\n    let actualModule = module;\n    let actualOptions = moduleOptionOverrides;\n    if (arguments.length === 1 && !(module instanceof WebAssembly.Module)) {\n      actualModule = void 0;\n      actualOptions = module;\n    }\n    emscriptenModule = initEmscriptenModule(Module, actualModule, actualOptions);\n  }\n  async function decode(buffer) {\n    if (!emscriptenModule)\n      init();\n    const module = await emscriptenModule;\n    const result = module.decode(buffer);\n    if (!result)\n      throw new Error("Decoding error");\n    return result;\n  }\n  async function unpackPcSogs(fileBytes, extraFiles) {\n    const json = JSON.parse(new TextDecoder().decode(fileBytes));\n    if (json.quats.encoding !== "quaternion_packed") {\n      throw new Error("Unsupported quaternion encoding");\n    }\n    const numSplats = json.means.shape[0];\n    const maxSplats = computeMaxSplats(numSplats);\n    const packedArray = new Uint32Array(maxSplats * 4);\n    const extra = {};\n    const means = await Promise.all([\n      decodeImageRgba(extraFiles[json.means.files[0]]),\n      decodeImageRgba(extraFiles[json.means.files[1]])\n    ]);\n    for (let i2 = 0; i2 < numSplats; ++i2) {\n      const i4 = i2 * 4;\n      const fx = (means[0][i4 + 0] + (means[1][i4 + 0] << 8)) / 65535;\n      const fy = (means[0][i4 + 1] + (means[1][i4 + 1] << 8)) / 65535;\n      const fz = (means[0][i4 + 2] + (means[1][i4 + 2] << 8)) / 65535;\n      let x2 = json.means.mins[0] + (json.means.maxs[0] - json.means.mins[0]) * fx;\n      let y = json.means.mins[1] + (json.means.maxs[1] - json.means.mins[1]) * fy;\n      let z = json.means.mins[2] + (json.means.maxs[2] - json.means.mins[2]) * fz;\n      x2 = Math.sign(x2) * (Math.exp(Math.abs(x2)) - 1);\n      y = Math.sign(y) * (Math.exp(Math.abs(y)) - 1);\n      z = Math.sign(z) * (Math.exp(Math.abs(z)) - 1);\n      setPackedSplatCenter(packedArray, i2, x2, y, z);\n    }\n    const scales = await decodeImageRgba(extraFiles[json.scales.files[0]]);\n    for (let i2 = 0; i2 < numSplats; ++i2) {\n      const i4 = i2 * 4;\n      const fx = scales[i4 + 0] / 255;\n      const fy = scales[i4 + 1] / 255;\n      const fz = scales[i4 + 2] / 255;\n      const x2 = json.scales.mins[0] + (json.scales.maxs[0] - json.scales.mins[0]) * fx;\n      const y = json.scales.mins[1] + (json.scales.maxs[1] - json.scales.mins[1]) * fy;\n      const z = json.scales.mins[2] + (json.scales.maxs[2] - json.scales.mins[2]) * fz;\n      setPackedSplatScales(packedArray, i2, Math.exp(x2), Math.exp(y), Math.exp(z));\n    }\n    const quats = await decodeImageRgba(extraFiles[json.quats.files[0]]);\n    const SQRT2 = Math.sqrt(2);\n    for (let i2 = 0; i2 < numSplats; ++i2) {\n      const i4 = i2 * 4;\n      const r0 = (quats[i4 + 0] / 255 - 0.5) * SQRT2;\n      const r1 = (quats[i4 + 1] / 255 - 0.5) * SQRT2;\n      const r2 = (quats[i4 + 2] / 255 - 0.5) * SQRT2;\n      const rr = Math.sqrt(Math.max(0, 1 - r0 * r0 - r1 * r1 - r2 * r2));\n      const rOrder = quats[i4 + 3] - 252;\n      const quatX = rOrder === 0 ? r0 : rOrder === 1 ? rr : r1;\n      const quatY = rOrder <= 1 ? r1 : rOrder === 2 ? rr : r2;\n      const quatZ = rOrder <= 2 ? r2 : rr;\n      const quatW = rOrder === 0 ? rr : r0;\n      setPackedSplatQuat(packedArray, i2, quatX, quatY, quatZ, quatW);\n    }\n    const sh0 = await decodeImageRgba(extraFiles[json.sh0.files[0]]);\n    const SH_C02 = 0.28209479177387814;\n    for (let i2 = 0; i2 < numSplats; ++i2) {\n      const i4 = i2 * 4;\n      const f0 = sh0[i4 + 0] / 255;\n      const f1 = sh0[i4 + 1] / 255;\n      const f2 = sh0[i4 + 2] / 255;\n      const f3 = sh0[i4 + 3] / 255;\n      const dc0 = json.sh0.mins[0] + (json.sh0.maxs[0] - json.sh0.mins[0]) * f0;\n      const dc1 = json.sh0.mins[1] + (json.sh0.maxs[1] - json.sh0.mins[1]) * f1;\n      const dc2 = json.sh0.mins[2] + (json.sh0.maxs[2] - json.sh0.mins[2]) * f2;\n      const opa = json.sh0.mins[3] + (json.sh0.maxs[3] - json.sh0.mins[3]) * f3;\n      const r = SH_C02 * dc0 + 0.5;\n      const g = SH_C02 * dc1 + 0.5;\n      const b = SH_C02 * dc2 + 0.5;\n      const a = 1 / (1 + Math.exp(-opa));\n      setPackedSplatRgba(packedArray, i2, r, g, b, a);\n    }\n    if (json.shN) {\n      extra.sh1 = new Uint32Array(numSplats * 2);\n      extra.sh2 = new Uint32Array(numSplats * 4);\n      extra.sh3 = new Uint32Array(numSplats * 4);\n      const sh1 = new Float32Array(9);\n      const sh2 = new Float32Array(15);\n      const sh3 = new Float32Array(21);\n      const [centroids, labels] = await Promise.all([\n        decodeImage(extraFiles[json.shN.files[0]]),\n        decodeImage(extraFiles[json.shN.files[1]])\n      ]);\n      for (let i2 = 0; i2 < numSplats; ++i2) {\n        const i4 = i2 * 4;\n        const label = labels.rgba[i4 + 0] + (labels.rgba[i4 + 1] << 8);\n        const col = (label & 63) * 15;\n        const row = label >>> 6;\n        const offset = row * centroids.width + col;\n        for (let d = 0; d < 3; ++d) {\n          for (let k = 0; k < 3; ++k) {\n            sh1[k * 3 + d] = json.shN.mins + (json.shN.maxs - json.shN.mins) * centroids.rgba[(offset + k) * 4 + d] / 255;\n          }\n          for (let k = 0; k < 5; ++k) {\n            sh2[k * 3 + d] = json.shN.mins + (json.shN.maxs - json.shN.mins) * centroids.rgba[(offset + 3 + k) * 4 + d] / 255;\n          }\n          for (let k = 0; k < 7; ++k) {\n            sh3[k * 3 + d] = json.shN.mins + (json.shN.maxs - json.shN.mins) * centroids.rgba[(offset + 8 + k) * 4 + d] / 255;\n          }\n        }\n        encodeSh1Rgb(extra.sh1, i2, sh1);\n        encodeSh2Rgb(extra.sh2, i2, sh2);\n        encodeSh3Rgb(extra.sh3, i2, sh3);\n      }\n    }\n    return { packedArray, numSplats, extra };\n  }\n  async function decodeImage(fileBytes) {\n    const { data: rgba, width, height } = await decode(fileBytes);\n    return { rgba, width, height };\n  }\n  async function decodeImageRgba(fileBytes) {\n    const { rgba } = await decodeImage(fileBytes);\n    return rgba;\n  }\n  const _PlyReader = class _PlyReader {\n    // Create a PlyReader from a Uint8Array/ArrayBuffer, no parsing done yet\n    constructor({ fileBytes }) {\n      this.header = "";\n      this.littleEndian = true;\n      this.elements = {};\n      this.comments = [];\n      this.data = null;\n      this.numSplats = 0;\n      this.fileBytes = fileBytes instanceof ArrayBuffer ? new Uint8Array(fileBytes) : fileBytes;\n    }\n    // Identify and parse the PLY text header (assumed to be <64KB in size).\n    // this.elements will contain all the elements in the file, typically\n    // "vertex" contains the Gsplat data.\n    async parseHeader() {\n      const bufferStream = new ReadableStream({\n        start: (controller) => {\n          controller.enqueue(this.fileBytes.slice(0, 65536));\n          controller.close();\n        }\n      });\n      const decoder = bufferStream.pipeThrough(new TextDecoderStream()).getReader();\n      this.header = "";\n      const headerTerminator = "end_header\\n";\n      while (true) {\n        const { value, done } = await decoder.read();\n        if (done) {\n          throw new Error("Failed to read header");\n        }\n        this.header += value;\n        const endHeader = this.header.indexOf(headerTerminator);\n        if (endHeader >= 0) {\n          this.header = this.header.slice(0, endHeader + headerTerminator.length);\n          break;\n        }\n      }\n      const headerLen = new TextEncoder().encode(this.header).length;\n      this.data = new DataView(this.fileBytes.buffer, headerLen);\n      this.elements = {};\n      let curElement = null;\n      this.comments = [];\n      this.header.trim().split("\\n").forEach((line, lineIndex) => {\n        const trimmedLine = line.trim();\n        if (lineIndex === 0) {\n          if (trimmedLine !== "ply") {\n            throw new Error("Invalid PLY header");\n          }\n          return;\n        }\n        if (trimmedLine.length === 0) {\n          return;\n        }\n        const fields = trimmedLine.split(" ");\n        switch (fields[0]) {\n          case "format":\n            if (fields[1] === "binary_little_endian") {\n              this.littleEndian = true;\n            } else if (fields[1] === "binary_big_endian") {\n              this.littleEndian = false;\n            } else {\n              throw new Error(`Unsupported PLY format: ${fields[1]}`);\n            }\n            if (fields[2] !== "1.0") {\n              throw new Error(`Unsupported PLY version: ${fields[2]}`);\n            }\n            break;\n          case "end_header":\n            break;\n          case "comment":\n            this.comments.push(trimmedLine.slice("comment ".length));\n            break;\n          case "element": {\n            const name = fields[1];\n            curElement = {\n              name,\n              count: Number.parseInt(fields[2]),\n              properties: {}\n            };\n            this.elements[name] = curElement;\n            break;\n          }\n          case "property":\n            if (curElement == null) {\n              throw new Error("Property must be inside an element");\n            }\n            if (fields[1] === "list") {\n              curElement.properties[fields[4]] = {\n                isList: true,\n                type: fields[3],\n                countType: fields[2]\n              };\n            } else {\n              curElement.properties[fields[2]] = {\n                isList: false,\n                type: fields[1]\n              };\n            }\n            break;\n        }\n      });\n      if (this.elements.vertex) {\n        this.numSplats = this.elements.vertex.count;\n      }\n    }\n    parseData(elementCallback) {\n      let offset = 0;\n      const data = this.data;\n      if (data == null) {\n        throw new Error("No data to parse");\n      }\n      for (const elementName in this.elements) {\n        const element = this.elements[elementName];\n        const { count, properties } = element;\n        const item = {};\n        const parsers = [];\n        for (const [propertyName, property] of Object.entries(properties)) {\n          if (!property.isList) {\n            item[propertyName] = 0;\n            parsers.push(() => {\n              item[propertyName] = PARSE_FIELD[property.type](\n                data,\n                offset,\n                this.littleEndian\n              );\n              offset += FIELD_BYTES[property.type];\n            });\n          } else {\n            item[propertyName] = [];\n            parsers.push(() => {\n              const list = item[propertyName];\n              list.length = PARSE_FIELD[property.countType](\n                data,\n                offset,\n                this.littleEndian\n              );\n              offset += FIELD_BYTES[property.countType];\n              for (let i2 = 0; i2 < list.length; i2++) {\n                list[i2] = PARSE_FIELD[property.type](\n                  data,\n                  offset,\n                  this.littleEndian\n                );\n                offset += FIELD_BYTES[property.type];\n              }\n            });\n          }\n        }\n        const callback = elementCallback(element) ?? (() => {\n        });\n        for (let index = 0; index < count; index++) {\n          for (const parser of parsers) {\n            parser();\n          }\n          callback(index, item);\n        }\n      }\n    }\n    // Parse all the Gsplat data in the PLY file in go, invoking the given\n    // callbacks for each Gsplat.\n    parseSplats(splatCallback, shCallback) {\n      if (this.elements.vertex == null) {\n        throw new Error("No vertex element found");\n      }\n      let isSuperSplat = false;\n      const ssChunks = [];\n      let numSh = 0;\n      let sh1Props = [];\n      let sh2Props = [];\n      let sh3Props = [];\n      let sh1 = void 0;\n      let sh2 = void 0;\n      let sh3 = void 0;\n      function prepareSh() {\n        const num_f_rest = NUM_SH_TO_NUM_F_REST[numSh];\n        sh1Props = new Array(3).fill(null).flatMap(\n          (_, k) => [0, 1, 2].map((_2, d) => `f_rest_${k + d * num_f_rest / 3}`)\n        );\n        sh2Props = new Array(5).fill(null).flatMap(\n          (_, k) => [0, 1, 2].map((_2, d) => `f_rest_${3 + k + d * num_f_rest / 3}`)\n        );\n        sh3Props = new Array(7).fill(null).flatMap(\n          (_, k) => [0, 1, 2].map((_2, d) => `f_rest_${8 + k + d * num_f_rest / 3}`)\n        );\n        sh1 = numSh >= 1 ? new Float32Array(3 * 3) : void 0;\n        sh2 = numSh >= 2 ? new Float32Array(5 * 3) : void 0;\n        sh3 = numSh >= 3 ? new Float32Array(7 * 3) : void 0;\n      }\n      function ssShCallback(index, item) {\n        if (!sh1) {\n          throw new Error("Missing sh1");\n        }\n        for (const [i2, key] of sh1Props.entries()) {\n          sh1[i2] = item[key] * 8 / 255 - 4;\n        }\n        if (sh2) {\n          for (const [i2, key] of sh2Props.entries()) {\n            sh2[i2] = item[key] * 8 / 255 - 4;\n          }\n        }\n        if (sh3) {\n          for (const [i2, key] of sh3Props.entries()) {\n            sh3[i2] = item[key] * 8 / 255 - 4;\n          }\n        }\n        shCallback == null ? void 0 : shCallback(index, sh1, sh2, sh3);\n      }\n      function initSuperSplat(element) {\n        const {\n          min_x,\n          min_y,\n          min_z,\n          max_x,\n          max_y,\n          max_z,\n          min_scale_x,\n          min_scale_y,\n          min_scale_z,\n          max_scale_x,\n          max_scale_y,\n          max_scale_z\n        } = element.properties;\n        if (!min_x || !min_y || !min_z || !max_x || !max_y || !max_z || !min_scale_x || !min_scale_y || !min_scale_z || !max_scale_x || !max_scale_y || !max_scale_z) {\n          throw new Error("Missing PLY chunk properties");\n        }\n        isSuperSplat = true;\n        return (index, item) => {\n          const {\n            min_x: min_x2,\n            min_y: min_y2,\n            min_z: min_z2,\n            max_x: max_x2,\n            max_y: max_y2,\n            max_z: max_z2,\n            min_scale_x: min_scale_x2,\n            min_scale_y: min_scale_y2,\n            min_scale_z: min_scale_z2,\n            max_scale_x: max_scale_x2,\n            max_scale_y: max_scale_y2,\n            max_scale_z: max_scale_z2,\n            min_r,\n            min_g,\n            min_b,\n            max_r,\n            max_g,\n            max_b\n          } = item;\n          ssChunks.push({\n            min_x: min_x2,\n            min_y: min_y2,\n            min_z: min_z2,\n            max_x: max_x2,\n            max_y: max_y2,\n            max_z: max_z2,\n            min_scale_x: min_scale_x2,\n            min_scale_y: min_scale_y2,\n            min_scale_z: min_scale_z2,\n            max_scale_x: max_scale_x2,\n            max_scale_y: max_scale_y2,\n            max_scale_z: max_scale_z2,\n            min_r,\n            min_g,\n            min_b,\n            max_r,\n            max_g,\n            max_b\n          });\n        };\n      }\n      function decodeSuperSplat(element) {\n        if (shCallback && element.name === "sh") {\n          numSh = getNumSh(element.properties);\n          prepareSh();\n          return ssShCallback;\n        }\n        if (element.name !== "vertex") {\n          return null;\n        }\n        const { packed_position, packed_rotation, packed_scale, packed_color } = element.properties;\n        if (!packed_position || !packed_rotation || !packed_scale || !packed_color) {\n          throw new Error(\n            "Missing PLY properties: packed_position, packed_rotation, packed_scale, packed_color"\n          );\n        }\n        const SQRT2 = Math.sqrt(2);\n        return (index, item) => {\n          const chunk = ssChunks[index >>> 8];\n          if (chunk == null) {\n            throw new Error("Missing PLY chunk");\n          }\n          const {\n            min_x,\n            min_y,\n            min_z,\n            max_x,\n            max_y,\n            max_z,\n            min_scale_x,\n            min_scale_y,\n            min_scale_z,\n            max_scale_x,\n            max_scale_y,\n            max_scale_z,\n            min_r,\n            min_g,\n            min_b,\n            max_r,\n            max_g,\n            max_b\n          } = chunk;\n          const { packed_position: packed_position2, packed_rotation: packed_rotation2, packed_scale: packed_scale2, packed_color: packed_color2 } = item;\n          const x2 = (packed_position2 >>> 21 & 2047) / 2047 * (max_x - min_x) + min_x;\n          const y = (packed_position2 >>> 11 & 1023) / 1023 * (max_y - min_y) + min_y;\n          const z = (packed_position2 & 2047) / 2047 * (max_z - min_z) + min_z;\n          const r0 = ((packed_rotation2 >>> 20 & 1023) / 1023 - 0.5) * SQRT2;\n          const r1 = ((packed_rotation2 >>> 10 & 1023) / 1023 - 0.5) * SQRT2;\n          const r2 = ((packed_rotation2 & 1023) / 1023 - 0.5) * SQRT2;\n          const rr = Math.sqrt(Math.max(0, 1 - r0 * r0 - r1 * r1 - r2 * r2));\n          const rOrder = packed_rotation2 >>> 30;\n          const quatX = rOrder === 0 ? r0 : rOrder === 1 ? rr : r1;\n          const quatY = rOrder <= 1 ? r1 : rOrder === 2 ? rr : r2;\n          const quatZ = rOrder <= 2 ? r2 : rr;\n          const quatW = rOrder === 0 ? rr : r0;\n          const scaleX = Math.exp(\n            (packed_scale2 >>> 21 & 2047) / 2047 * (max_scale_x - min_scale_x) + min_scale_x\n          );\n          const scaleY = Math.exp(\n            (packed_scale2 >>> 11 & 1023) / 1023 * (max_scale_y - min_scale_y) + min_scale_y\n          );\n          const scaleZ = Math.exp(\n            (packed_scale2 & 2047) / 2047 * (max_scale_z - min_scale_z) + min_scale_z\n          );\n          const r = (packed_color2 >>> 24 & 255) / 255 * ((max_r ?? 1) - (min_r ?? 0)) + (min_r ?? 0);\n          const g = (packed_color2 >>> 16 & 255) / 255 * ((max_g ?? 1) - (min_g ?? 0)) + (min_g ?? 0);\n          const b = (packed_color2 >>> 8 & 255) / 255 * ((max_b ?? 1) - (min_b ?? 0)) + (min_b ?? 0);\n          const opacity = (packed_color2 & 255) / 255;\n          splatCallback(\n            index,\n            x2,\n            y,\n            z,\n            scaleX,\n            scaleY,\n            scaleZ,\n            quatX,\n            quatY,\n            quatZ,\n            quatW,\n            opacity,\n            r,\n            g,\n            b\n          );\n        };\n      }\n      const elementCallback = (element) => {\n        if (element.name === "chunk") {\n          return initSuperSplat(element);\n        }\n        if (isSuperSplat) {\n          return decodeSuperSplat(element);\n        }\n        if (element.name !== "vertex") {\n          return null;\n        }\n        const {\n          x: x2,\n          y,\n          z,\n          scale_0,\n          scale_1,\n          scale_2,\n          rot_0,\n          rot_1,\n          rot_2,\n          rot_3,\n          opacity,\n          f_dc_0,\n          f_dc_1,\n          f_dc_2,\n          red,\n          green,\n          blue,\n          alpha\n        } = element.properties;\n        if (!x2 || !y || !z) {\n          throw new Error("Missing PLY properties: x, y, z");\n        }\n        const hasScales = scale_0 && scale_1 && scale_2;\n        const hasRots = rot_0 && rot_1 && rot_2 && rot_3;\n        const alphaDiv = alpha != null ? FIELD_SCALE[alpha.type] : 1;\n        const redDiv = red != null ? FIELD_SCALE[red.type] : 1;\n        const greenDiv = green != null ? FIELD_SCALE[green.type] : 1;\n        const blueDiv = blue != null ? FIELD_SCALE[blue.type] : 1;\n        numSh = getNumSh(element.properties);\n        prepareSh();\n        return (index, item) => {\n          const scaleX = hasScales ? Math.exp(item.scale_0) : _PlyReader.defaultPointScale;\n          const scaleY = hasScales ? Math.exp(item.scale_1) : _PlyReader.defaultPointScale;\n          const scaleZ = hasScales ? Math.exp(item.scale_2) : _PlyReader.defaultPointScale;\n          const quatX = hasRots ? item.rot_1 : 0;\n          const quatY = hasRots ? item.rot_2 : 0;\n          const quatZ = hasRots ? item.rot_3 : 0;\n          const quatW = hasRots ? item.rot_0 : 1;\n          const op = opacity != null ? 1 / (1 + Math.exp(-item.opacity)) : alpha != null ? item.alpha / alphaDiv : 1;\n          const r = f_dc_0 != null ? item.f_dc_0 * SH_C0$1 + 0.5 : red != null ? item.red / redDiv : 1;\n          const g = f_dc_1 != null ? item.f_dc_1 * SH_C0$1 + 0.5 : green != null ? item.green / greenDiv : 1;\n          const b = f_dc_2 != null ? item.f_dc_2 * SH_C0$1 + 0.5 : blue != null ? item.blue / blueDiv : 1;\n          splatCallback(\n            index,\n            item.x,\n            item.y,\n            item.z,\n            scaleX,\n            scaleY,\n            scaleZ,\n            quatX,\n            quatY,\n            quatZ,\n            quatW,\n            op,\n            r,\n            g,\n            b\n          );\n          if (shCallback && sh1) {\n            if (sh1) {\n              for (const [i2, key] of sh1Props.entries()) {\n                sh1[i2] = item[key];\n              }\n            }\n            if (sh2) {\n              for (const [i2, key] of sh2Props.entries()) {\n                sh2[i2] = item[key];\n              }\n            }\n            if (sh3) {\n              for (const [i2, key] of sh3Props.entries()) {\n                sh3[i2] = item[key];\n              }\n            }\n            shCallback(index, sh1, sh2, sh3);\n          }\n        };\n      };\n      this.parseData(elementCallback);\n    }\n    // Inject RGBA values into original PLY file, which can be used to modify\n    // the color/opacity of the Gsplats and write out the modified PLY file.\n    injectRgba(rgba) {\n      let offset = 0;\n      const data = this.data;\n      if (data == null) {\n        throw new Error("No parsed data");\n      }\n      if (rgba.length !== this.numSplats * 4) {\n        throw new Error("Invalid RGBA array length");\n      }\n      for (const elementName in this.elements) {\n        const element = this.elements[elementName];\n        const { count, properties } = element;\n        const parsers = [];\n        let rgbaOffset = 0;\n        const isVertex = elementName === "vertex";\n        if (isVertex) {\n          for (const name of ["opacity", "f_dc_0", "f_dc_1", "f_dc_2"]) {\n            if (!properties[name] || properties[name].type !== "float") {\n              throw new Error(`Can\'t injectRgba due to property: ${name}`);\n            }\n          }\n        }\n        for (const [propertyName, property] of Object.entries(properties)) {\n          if (!property.isList) {\n            if (isVertex) {\n              if (propertyName === "f_dc_0" || propertyName === "f_dc_1" || propertyName === "f_dc_2") {\n                const component = Number.parseInt(\n                  propertyName.slice("f_dc_".length)\n                );\n                parsers.push(() => {\n                  const value = (rgba[rgbaOffset + component] / 255 - 0.5) / SH_C0$1;\n                  SET_FIELD[property.type](\n                    data,\n                    offset,\n                    this.littleEndian,\n                    value\n                  );\n                });\n              } else if (propertyName === "opacity") {\n                parsers.push(() => {\n                  const value = Math.max(\n                    -100,\n                    Math.min(\n                      100,\n                      -Math.log(1 / (rgba[rgbaOffset + 3] / 255) - 1)\n                    )\n                  );\n                  SET_FIELD[property.type](\n                    data,\n                    offset,\n                    this.littleEndian,\n                    value\n                  );\n                });\n              }\n            }\n            parsers.push(() => {\n              offset += FIELD_BYTES[property.type];\n            });\n          } else {\n            parsers.push(() => {\n              const length = PARSE_FIELD[property.countType](\n                data,\n                offset,\n                this.littleEndian\n              );\n              offset += FIELD_BYTES[property.countType];\n              offset += length * FIELD_BYTES[property.type];\n            });\n          }\n        }\n        for (let index = 0; index < count; index++) {\n          for (const parser of parsers) {\n            parser();\n          }\n          if (isVertex) {\n            rgbaOffset += 4;\n          }\n        }\n      }\n    }\n  };\n  _PlyReader.defaultPointScale = 1e-3;\n  let PlyReader = _PlyReader;\n  const SH_C0$1 = 0.28209479177387814;\n  const PARSE_FIELD = {\n    char: (data, offset, littleEndian) => {\n      return data.getInt8(offset);\n    },\n    uchar: (data, offset, littleEndian) => {\n      return data.getUint8(offset);\n    },\n    short: (data, offset, littleEndian) => {\n      return data.getInt16(offset, littleEndian);\n    },\n    ushort: (data, offset, littleEndian) => {\n      return data.getUint16(offset, littleEndian);\n    },\n    int: (data, offset, littleEndian) => {\n      return data.getInt32(offset, littleEndian);\n    },\n    uint: (data, offset, littleEndian) => {\n      return data.getUint32(offset, littleEndian);\n    },\n    float: (data, offset, littleEndian) => {\n      return data.getFloat32(offset, littleEndian);\n    },\n    double: (data, offset, littleEndian) => {\n      return data.getFloat64(offset, littleEndian);\n    }\n  };\n  const SET_FIELD = {\n    char: (data, offset, littleEndian, value) => {\n      data.setInt8(offset, value);\n    },\n    uchar: (data, offset, littleEndian, value) => {\n      data.setUint8(offset, value);\n    },\n    short: (data, offset, littleEndian, value) => {\n      data.setInt16(offset, value, littleEndian);\n    },\n    ushort: (data, offset, littleEndian, value) => {\n      data.setUint16(offset, value, littleEndian);\n    },\n    int: (data, offset, littleEndian, value) => {\n      data.setInt32(offset, value, littleEndian);\n    },\n    uint: (data, offset, littleEndian, value) => {\n      data.setUint32(offset, value, littleEndian);\n    },\n    float: (data, offset, littleEndian, value) => {\n      data.setFloat32(offset, value, littleEndian);\n    },\n    double: (data, offset, littleEndian, value) => {\n      data.setFloat64(offset, value, littleEndian);\n    }\n  };\n  const FIELD_BYTES = {\n    char: 1,\n    uchar: 1,\n    short: 2,\n    ushort: 2,\n    int: 4,\n    uint: 4,\n    float: 4,\n    double: 8\n  };\n  const FIELD_SCALE = {\n    char: 127,\n    uchar: 255,\n    short: 32767,\n    ushort: 65535,\n    int: 2147483647,\n    uint: 4294967295,\n    float: 1,\n    double: 1\n  };\n  const NUM_F_REST_TO_NUM_SH = {\n    0: 0,\n    9: 1,\n    24: 2,\n    45: 3\n  };\n  const NUM_SH_TO_NUM_F_REST = {\n    0: 0,\n    1: 9,\n    2: 24,\n    3: 45\n  };\n  function getNumSh(properties) {\n    let num_f_rest = 0;\n    while (properties[`f_rest_${num_f_rest}`]) {\n      num_f_rest += 1;\n    }\n    const numSh = NUM_F_REST_TO_NUM_SH[num_f_rest];\n    if (numSh == null) {\n      throw new Error(`Unsupported number of SH coefficients: ${num_f_rest}`);\n    }\n    return numSh;\n  }\n  const Gsplat = { type: "Gsplat" };\n  const TPackedSplats = { type: "PackedSplats" };\n  const readPackedSplat = (packedSplats, index) => new ReadPackedSplat({ packedSplats, index });\n  const readPackedSplatRange = (packedSplats, index, base, count) => new ReadPackedSplatRange({ packedSplats, index, base, count });\n  const splitGsplat = (gsplat) => new SplitGsplat({ gsplat });\n  const combineGsplat = ({\n    gsplat,\n    flags,\n    index,\n    center,\n    scales,\n    quaternion,\n    rgba,\n    rgb,\n    opacity,\n    x: x2,\n    y,\n    z,\n    r,\n    g,\n    b\n  }) => {\n    return new CombineGsplat({\n      gsplat,\n      flags,\n      index,\n      center,\n      scales,\n      quaternion,\n      rgba,\n      rgb,\n      opacity,\n      x: x2,\n      y,\n      z,\n      r,\n      g,\n      b\n    });\n  };\n  const transformGsplat = (gsplat, {\n    scale,\n    rotate,\n    translate,\n    recolor\n  }) => {\n    return new TransformGsplat({ gsplat, scale, rotate, translate, recolor });\n  };\n  const defineGsplat = unindent(`\n  struct Gsplat {\n    vec3 center;\n    uint flags;\n    vec3 scales;\n    int index;\n    vec4 quaternion;\n    vec4 rgba;\n  };\n  const uint GSPLAT_FLAG_ACTIVE = 1u << 0u;\n\n  bool isGsplatActive(uint flags) {\n    return (flags & GSPLAT_FLAG_ACTIVE) != 0u;\n  }\n`);\n  const definePackedSplats = unindent(`\n  struct PackedSplats {\n    usampler2DArray texture;\n    int numSplats;\n  };\n`);\n  const defineReadPackedSplat = unindent(`\n  bool readPackedSplat(usampler2DArray texture, int numSplats, int index, out Gsplat gsplat) {\n    if ((index >= 0) && (index < numSplats)) {\n      uvec4 packed = texelFetch(texture, splatTexCoord(index), 0);\n      unpackSplat(packed, gsplat.center, gsplat.scales, gsplat.quaternion, gsplat.rgba);\n      return true;\n    } else {\n      return false;\n    }\n  }\n`);\n  class ReadPackedSplat extends Dyno {\n    constructor({\n      packedSplats,\n      index\n    }) {\n      super({\n        inTypes: { packedSplats: TPackedSplats, index: "int" },\n        outTypes: { gsplat: Gsplat },\n        inputs: { packedSplats, index },\n        globals: () => [defineGsplat, definePackedSplats, defineReadPackedSplat],\n        statements: ({ inputs, outputs }) => {\n          const { gsplat } = outputs;\n          if (!gsplat) {\n            return [];\n          }\n          const { packedSplats: packedSplats2, index: index2 } = inputs;\n          let statements;\n          if (packedSplats2 && index2) {\n            statements = unindentLines(`\n            if (readPackedSplat(${packedSplats2}.texture, ${packedSplats2}.numSplats, ${index2}, ${gsplat})) {\n              bool zeroSize = all(equal(${gsplat}.scales, vec3(0.0, 0.0, 0.0)));\n              ${gsplat}.flags = zeroSize ? 0u : GSPLAT_FLAG_ACTIVE;\n            } else {\n              ${gsplat}.flags = 0u;\n            }\n          `);\n          } else {\n            statements = [`${gsplat}.flags = 0u;`];\n          }\n          statements.push(`${gsplat}.index = ${index2 ?? "0"};`);\n          return statements;\n        }\n      });\n    }\n    dynoOut() {\n      return new DynoOutput(this, "gsplat");\n    }\n  }\n  class ReadPackedSplatRange extends Dyno {\n    constructor({\n      packedSplats,\n      index,\n      base,\n      count\n    }) {\n      super({\n        inTypes: {\n          packedSplats: TPackedSplats,\n          index: "int",\n          base: "int",\n          count: "int"\n        },\n        outTypes: { gsplat: Gsplat },\n        inputs: { packedSplats, index, base, count },\n        globals: () => [defineGsplat, definePackedSplats, defineReadPackedSplat],\n        statements: ({ inputs, outputs }) => {\n          const { gsplat } = outputs;\n          if (!gsplat) {\n            return [];\n          }\n          const { packedSplats: packedSplats2, index: index2, base: base2, count: count2 } = inputs;\n          let statements;\n          if (packedSplats2 && index2 && base2 && count2) {\n            statements = unindentLines(`\n            ${gsplat}.flags = 0u;\n            if ((${index2} >= ${base2}) && (${index2} < (${base2} + ${count2}))) {\n              if (readPackedSplat(${packedSplats2}.texture, ${packedSplats2}.numSplats, ${index2}, ${gsplat})) {\n                bool zeroSize = all(equal(${gsplat}.scales, vec3(0.0, 0.0, 0.0)));\n                ${gsplat}.flags = zeroSize ? 0u : GSPLAT_FLAG_ACTIVE;\n              }\n            }\n          `);\n          } else {\n            statements = [`${gsplat}.flags = 0u;`];\n          }\n          statements.push(`${gsplat}.index = ${index2 ?? "0"};`);\n          return statements;\n        }\n      });\n    }\n    dynoOut() {\n      return new DynoOutput(this, "gsplat");\n    }\n  }\n  class SplitGsplat extends Dyno {\n    constructor({ gsplat }) {\n      super({\n        inTypes: { gsplat: Gsplat },\n        outTypes: {\n          flags: "uint",\n          active: "bool",\n          index: "int",\n          center: "vec3",\n          scales: "vec3",\n          quaternion: "vec4",\n          rgba: "vec4",\n          rgb: "vec3",\n          opacity: "float",\n          x: "float",\n          y: "float",\n          z: "float",\n          r: "float",\n          g: "float",\n          b: "float"\n        },\n        inputs: { gsplat },\n        globals: () => [defineGsplat],\n        statements: ({ inputs, outputs }) => {\n          const { gsplat: gsplat2 } = inputs;\n          const {\n            flags,\n            active,\n            index,\n            center,\n            scales,\n            quaternion,\n            rgba,\n            rgb,\n            opacity,\n            x: x2,\n            y,\n            z,\n            r,\n            g,\n            b\n          } = outputs;\n          return [\n            !flags ? null : `${flags} = ${gsplat2 ? `${gsplat2}.flags` : "0u"};`,\n            !active ? null : `${active} = isGsplatActive(${gsplat2 ? `${gsplat2}.flags` : "0u"});`,\n            !index ? null : `${index} = ${gsplat2 ? `${gsplat2}.index` : "0"};`,\n            !center ? null : `${center} = ${gsplat2 ? `${gsplat2}.center` : "vec3(0.0, 0.0, 0.0)"};`,\n            !scales ? null : `${scales} = ${gsplat2 ? `${gsplat2}.scales` : "vec3(0.0, 0.0, 0.0)"};`,\n            !quaternion ? null : `${quaternion} = ${gsplat2 ? `${gsplat2}.quaternion` : "vec4(0.0, 0.0, 0.0, 1.0)"};`,\n            !rgba ? null : `${rgba} = ${gsplat2 ? `${gsplat2}.rgba` : "vec4(0.0, 0.0, 0.0, 0.0)"};`,\n            !rgb ? null : `${rgb} = ${gsplat2 ? `${gsplat2}.rgba.rgb` : "vec3(0.0, 0.0, 0.0)"};`,\n            !opacity ? null : `${opacity} = ${gsplat2 ? `${gsplat2}.rgba.a` : "0.0"};`,\n            !x2 ? null : `${x2} = ${gsplat2 ? `${gsplat2}.center.x` : "0.0"};`,\n            !y ? null : `${y} = ${gsplat2 ? `${gsplat2}.center.y` : "0.0"};`,\n            !z ? null : `${z} = ${gsplat2 ? `${gsplat2}.center.z` : "0.0"};`,\n            !r ? null : `${r} = ${gsplat2 ? `${gsplat2}.rgba.r` : "0.0"};`,\n            !g ? null : `${g} = ${gsplat2 ? `${gsplat2}.rgba.g` : "0.0"};`,\n            !b ? null : `${b} = ${gsplat2 ? `${gsplat2}.rgba.b` : "0.0"};`\n          ].filter(Boolean);\n        }\n      });\n    }\n  }\n  class CombineGsplat extends Dyno {\n    constructor({\n      gsplat,\n      flags,\n      index,\n      center,\n      scales,\n      quaternion,\n      rgba,\n      rgb,\n      opacity,\n      x: x2,\n      y,\n      z,\n      r,\n      g,\n      b\n    }) {\n      super({\n        inTypes: {\n          gsplat: Gsplat,\n          flags: "uint",\n          index: "int",\n          center: "vec3",\n          scales: "vec3",\n          quaternion: "vec4",\n          rgba: "vec4",\n          rgb: "vec3",\n          opacity: "float",\n          x: "float",\n          y: "float",\n          z: "float",\n          r: "float",\n          g: "float",\n          b: "float"\n        },\n        outTypes: { gsplat: Gsplat },\n        inputs: {\n          gsplat,\n          flags,\n          index,\n          center,\n          scales,\n          quaternion,\n          rgba,\n          rgb,\n          opacity,\n          x: x2,\n          y,\n          z,\n          r,\n          g,\n          b\n        },\n        globals: () => [defineGsplat],\n        statements: ({ inputs, outputs }) => {\n          const { gsplat: outGsplat } = outputs;\n          if (!outGsplat) {\n            return [];\n          }\n          const {\n            gsplat: gsplat2,\n            flags: flags2,\n            index: index2,\n            center: center2,\n            scales: scales2,\n            quaternion: quaternion2,\n            rgba: rgba2,\n            rgb: rgb2,\n            opacity: opacity2,\n            x: x22,\n            y: y2,\n            z: z2,\n            r: r2,\n            g: g2,\n            b: b2\n          } = inputs;\n          return [\n            `${outGsplat}.flags = ${flags2 ?? (gsplat2 ? `${gsplat2}.flags` : "0u")};`,\n            `${outGsplat}.index = ${index2 ?? (gsplat2 ? `${gsplat2}.index` : "0")};`,\n            `${outGsplat}.center = ${center2 ?? (gsplat2 ? `${gsplat2}.center` : "vec3(0.0, 0.0, 0.0)")};`,\n            `${outGsplat}.scales = ${scales2 ?? (gsplat2 ? `${gsplat2}.scales` : "vec3(0.0, 0.0, 0.0)")};`,\n            `${outGsplat}.quaternion = ${quaternion2 ?? (gsplat2 ? `${gsplat2}.quaternion` : "vec4(0.0, 0.0, 0.0, 1.0)")};`,\n            `${outGsplat}.rgba = ${rgba2 ?? (gsplat2 ? `${gsplat2}.rgba` : "vec4(0.0, 0.0, 0.0, 0.0)")};`,\n            !rgb2 ? null : `${outGsplat}.rgba.rgb = ${rgb2};`,\n            !opacity2 ? null : `${outGsplat}.rgba.a = ${opacity2};`,\n            !x22 ? null : `${outGsplat}.center.x = ${x22};`,\n            !y2 ? null : `${outGsplat}.center.y = ${y2};`,\n            !z2 ? null : `${outGsplat}.center.z = ${z2};`,\n            !r2 ? null : `${outGsplat}.rgba.r = ${r2};`,\n            !g2 ? null : `${outGsplat}.rgba.g = ${g2};`,\n            !b2 ? null : `${outGsplat}.rgba.b = ${b2};`\n          ].filter(Boolean);\n        }\n      });\n    }\n    dynoOut() {\n      return new DynoOutput(this, "gsplat");\n    }\n  }\n  unindent(`\n  vec3 gsplatNormal(vec3 scales, vec4 quaternion) {\n    float minScale = min(scales.x, min(scales.y, scales.z));\n    vec3 normal;\n    if (scales.z == minScale) {\n      normal = vec3(0.0, 0.0, 1.0);\n    } else if (scales.y == minScale) {\n      normal = vec3(0.0, 1.0, 0.0);\n    } else {\n      normal = vec3(1.0, 0.0, 0.0);\n    }\n    return quatVec(quaternion, normal);\n  }\n`);\n  class TransformGsplat extends Dyno {\n    constructor({\n      gsplat,\n      scale,\n      rotate,\n      translate,\n      recolor\n    }) {\n      super({\n        inTypes: {\n          gsplat: Gsplat,\n          scale: "float",\n          rotate: "vec4",\n          translate: "vec3",\n          recolor: "vec4"\n        },\n        outTypes: { gsplat: Gsplat },\n        inputs: { gsplat, scale, rotate, translate, recolor },\n        globals: () => [defineGsplat],\n        statements: ({ inputs, outputs, compile }) => {\n          const { gsplat: gsplat2 } = outputs;\n          if (!gsplat2 || !inputs.gsplat) {\n            return [];\n          }\n          const { scale: scale2, rotate: rotate2, translate: translate2, recolor: recolor2 } = inputs;\n          const indent = compile.indent;\n          const statements = [\n            `${gsplat2} = ${inputs.gsplat};`,\n            `if (isGsplatActive(${gsplat2}.flags)) {`,\n            scale2 ? `${indent}${gsplat2}.center *= ${scale2};` : null,\n            rotate2 ? `${indent}${gsplat2}.center = quatVec(${rotate2}, ${gsplat2}.center);` : null,\n            translate2 ? `${indent}${gsplat2}.center += ${translate2};` : null,\n            scale2 ? `${indent}${gsplat2}.scales *= ${scale2};` : null,\n            rotate2 ? `${indent}${gsplat2}.quaternion = quatQuat(${rotate2}, ${gsplat2}.quaternion);` : null,\n            recolor2 ? `${indent}${gsplat2}.rgba *= ${recolor2};` : null,\n            "}"\n          ].filter(Boolean);\n          return statements;\n        }\n      });\n    }\n    dynoOut() {\n      return new DynoOutput(this, "gsplat");\n    }\n  }\n  const outputPackedSplat = (gsplat) => new OutputPackedSplat({ gsplat });\n  class OutputPackedSplat extends Dyno {\n    constructor({ gsplat }) {\n      super({\n        inTypes: { gsplat: Gsplat },\n        inputs: { gsplat },\n        globals: () => [defineGsplat],\n        statements: ({ inputs, outputs }) => {\n          const { output } = outputs;\n          if (!output) {\n            return [];\n          }\n          const { gsplat: gsplat2 } = inputs;\n          if (gsplat2) {\n            return unindentLines(`\n            if (isGsplatActive(${gsplat2}.flags)) {\n              ${output} = packSplat(${gsplat2}.center, ${gsplat2}.scales, ${gsplat2}.quaternion, ${gsplat2}.rgba);\n            } else {\n              ${output} = uvec4(0u, 0u, 0u, 0u);\n            }\n          `);\n          }\n          return [`${output} = uvec4(0u, 0u, 0u, 0u);`];\n        }\n      });\n    }\n    dynoOut() {\n      return new DynoOutput(this, "output");\n    }\n  }\n  class OutputRgba8 extends Dyno {\n    constructor({ rgba8 }) {\n      super({\n        inTypes: { rgba8: "vec4" },\n        inputs: { rgba8 },\n        statements: ({ inputs, outputs }) => [\n          `target = ${inputs.rgba8 ?? "vec4(0.0, 0.0, 0.0, 0.0)"};`\n        ]\n      });\n    }\n    dynoOut() {\n      return new DynoOutput(this, "rgba8");\n    }\n  }\n  class DynoUniform extends Dyno {\n    constructor({\n      key,\n      type,\n      count,\n      value,\n      update,\n      globals\n    }) {\n      key = key ?? "value";\n      super({\n        outTypes: { [key]: type },\n        update: () => {\n          if (update) {\n            const value2 = update(this.value);\n            if (value2 !== void 0) {\n              this.value = value2;\n            }\n          }\n          this.uniform.value = this.value;\n        },\n        generate: ({ inputs, outputs }) => {\n          const allGlobals = (globals == null ? void 0 : globals({ inputs, outputs })) ?? [];\n          const uniforms = {};\n          const name = outputs[key];\n          if (name) {\n            allGlobals.push(`uniform ${dynoDeclare(name, type, count)};`);\n            uniforms[name] = this.uniform;\n          }\n          return { globals: allGlobals, uniforms };\n        }\n      });\n      this.type = type;\n      this.count = count;\n      this.value = value;\n      this.uniform = { value };\n      this.outKey = key;\n    }\n    dynoOut() {\n      return new DynoOutput(this, this.outKey);\n    }\n  }\n  class DynoInt extends DynoUniform {\n    constructor({\n      key,\n      value,\n      update\n    }) {\n      super({ key, type: "int", value, update });\n    }\n  }\n  class DynoFloat extends DynoUniform {\n    constructor({\n      key,\n      value,\n      update\n    }) {\n      super({ key, type: "float", value, update });\n    }\n  }\n  class DynoVec3 extends DynoUniform {\n    constructor({\n      key,\n      value,\n      update\n    }) {\n      super({ key, type: "vec3", value, update });\n    }\n  }\n  class DynoVec4 extends DynoUniform {\n    constructor({\n      key,\n      value,\n      update\n    }) {\n      super({ key, type: "vec4", value, update });\n    }\n  }\n  class DynoUsampler2DArray extends DynoUniform {\n    constructor({\n      key,\n      value,\n      update\n    }) {\n      super({ key, type: "usampler2DArray", value, update });\n    }\n  }\n  class DynoProgram {\n    constructor({\n      graph,\n      inputs,\n      outputs,\n      template\n    }) {\n      this.graph = graph;\n      this.template = template;\n      this.inputs = inputs ?? {};\n      this.outputs = outputs ?? {};\n      const compile = new Compilation({ indent: this.template.indent });\n      for (const key in this.outputs) {\n        if (this.outputs[key]) {\n          compile.declares.add(this.outputs[key]);\n        }\n      }\n      const statements = graph.compile({\n        inputs: this.inputs,\n        outputs: this.outputs,\n        compile\n      });\n      this.shader = template.generate({ globals: compile.globals, statements });\n      this.uniforms = compile.uniforms;\n      this.updaters = compile.updaters;\n    }\n    prepareMaterial() {\n      return getMaterial(this);\n    }\n    update() {\n      for (const updater of this.updaters) {\n        updater();\n      }\n    }\n  }\n  class DynoProgramTemplate {\n    constructor(template) {\n      const globals = template.match(/^([ \\t]*)\\{\\{\\s*GLOBALS\\s*\\}\\}/m);\n      const statements = template.match(/^([ \\t]*)\\{\\{\\s*STATEMENTS\\s*\\}\\}/m);\n      if (!globals || !statements) {\n        throw new Error(\n          "Template must contain {{ GLOBALS }} and {{ STATEMENTS }}"\n        );\n      }\n      this.before = template.substring(0, globals.index);\n      this.between = template.substring(\n        globals.index + globals[0].length,\n        statements.index\n      );\n      this.after = template.substring(\n        statements.index + statements[0].length\n      );\n      this.indent = statements[1];\n    }\n    generate({\n      globals,\n      statements\n    }) {\n      return this.before + Array.from(globals).join("\\n\\n") + this.between + statements.map((s) => this.indent + s).join("\\n") + this.after;\n    }\n  }\n  const programMaterial = /* @__PURE__ */ new Map();\n  function getMaterial(program) {\n    let material = programMaterial.get(program);\n    if (material) {\n      return material;\n    }\n    material = new RawShaderMaterial({\n      glslVersion: GLSL3,\n      vertexShader: IDENT_VERTEX_SHADER,\n      fragmentShader: program.shader,\n      uniforms: program.uniforms\n    });\n    programMaterial.set(program, material);\n    return material;\n  }\n  function addOutputType(a, b, operation = "add") {\n    const error = () => {\n      throw new Error(`Invalid ${operation} types: ${a}, ${b}`);\n    };\n    if (a === b) return a;\n    if (a === "int") {\n      if (isIntType(b)) return b;\n      error();\n    }\n    if (b === "int") {\n      if (isIntType(a)) return a;\n      error();\n    }\n    if (a === "uint") {\n      if (isUintType(b)) return b;\n      error();\n    }\n    if (b === "uint") {\n      if (isUintType(a)) return a;\n      error();\n    }\n    if (a === "float") {\n      if (isAllFloatType(b)) return b;\n      error();\n    }\n    if (b === "float") {\n      if (isAllFloatType(a)) return a;\n      error();\n    }\n    throw new Error(`Invalid ${operation} types: ${a}, ${b}`);\n  }\n  function subOutputType(a, b) {\n    return addOutputType(a, b, "sub");\n  }\n  function mulOutputType(a, b) {\n    const error = () => {\n      throw new Error(`Invalid mul types: ${a}, ${b}`);\n    };\n    const result = (value) => value;\n    if (a === "int") {\n      if (isIntType(b)) return result(b);\n      error();\n    }\n    if (b === "int") {\n      if (isIntType(a)) return result(a);\n      error();\n    }\n    if (a === "uint") {\n      if (isUintType(b)) return result(b);\n      error();\n    }\n    if (b === "uint") {\n      if (isUintType(a)) return result(a);\n      error();\n    }\n    if (a === "float") {\n      if (isAllFloatType(b)) return result(b);\n      error();\n    }\n    if (b === "float") {\n      if (isAllFloatType(a)) return result(a);\n      error();\n    }\n    if (isIntType(a) || isUintType(a) || isIntType(b) || isUintType(b)) {\n      if (a === b) return result(a);\n      error();\n    }\n    if (a === "vec2") {\n      if (b === "vec2" || isMat2(b)) return result("vec2");\n      if (b === "mat3x2") return result("vec3");\n      if (b === "mat4x2") return result("vec4");\n      error();\n    }\n    if (a === "vec3") {\n      if (b === "mat2x3") return result("vec2");\n      if (b === "vec3" || isMat3(b)) return result("vec3");\n      if (b === "mat4x3") return result("vec4");\n      error();\n    }\n    if (a === "vec4") {\n      if (b === "mat2x4") return result("vec2");\n      if (b === "mat3x4") return result("vec3");\n      if (b === "vec4" || isMat4(b)) return result("vec4");\n      error();\n    }\n    if (b === "vec2") {\n      if (isMat2(a)) return result("vec2");\n      if (a === "mat2x3") return result("vec3");\n      if (a === "mat2x4") return result("vec4");\n      error();\n    }\n    if (b === "vec3") {\n      if (a === "mat3x2") return result("vec2");\n      if (isMat3(a)) return result("vec3");\n      if (a === "mat3x4") return result("vec4");\n      error();\n    }\n    if (b === "vec4") {\n      if (a === "mat4x2") return result("vec2");\n      if (a === "mat4x3") return result("vec3");\n      if (isMat4(a)) return result("vec4");\n      error();\n    }\n    if (isMat2(a)) {\n      if (isMat2(b)) return result("mat2");\n      if (b === "mat3x2") return result("mat3x2");\n      if (b === "mat4x2") return result("mat4x2");\n      error();\n    }\n    if (a === "mat2x3") {\n      if (isMat2(b)) return result("mat2x3");\n      if (b === "mat3x2") return result("mat3");\n      if (b === "mat4x2") return result("mat4x3");\n      error();\n    }\n    if (a === "mat2x4") {\n      if (isMat2(b)) return result("mat2x4");\n      if (b === "mat3x2") return result("mat3x4");\n      if (b === "mat4x2") return result("mat4");\n      error();\n    }\n    if (a === "mat3x2") {\n      if (b === "mat2x3") return result("mat2");\n      if (isMat3(b)) return result("mat3x2");\n      if (b === "mat4x3") return result("mat4x2");\n      error();\n    }\n    if (isMat3(a)) {\n      if (b === "mat2x3") return result("mat2x3");\n      if (isMat3(b)) return result("mat3");\n      if (b === "mat4x3") return result("mat4x3");\n      error();\n    }\n    if (a === "mat3x4") {\n      if (b === "mat2x3") return result("mat2x4");\n      if (isMat3(b)) return result("mat3x4");\n      if (b === "mat4x3") return result("mat4");\n      error();\n    }\n    if (a === "mat4x2") {\n      if (b === "mat2x4") return result("mat2");\n      if (b === "mat3x4") return result("mat3x2");\n      if (isMat4(b)) return result("mat4x2");\n      error();\n    }\n    if (a === "mat4x3") {\n      if (b === "mat2x4") return result("mat2x3");\n      if (b === "mat3x4") return result("mat3");\n      if (isMat4(b)) return result("mat4x3");\n      error();\n    }\n    if (isMat4(a)) {\n      if (b === "mat2x4") return result("mat2x4");\n      if (b === "mat3x4") return result("mat3x4");\n      if (isMat4(b)) return result("mat4");\n      error();\n    }\n    throw new Error(`Invalid mul types: ${a}, ${b}`);\n  }\n  const add = (a, b) => new Add({ a, b });\n  const sub = (a, b) => new Sub({ a, b });\n  const mul = (a, b) => new Mul({ a, b });\n  class Add extends BinaryOp {\n    constructor({ a, b }) {\n      super({ a, b, outKey: "sum", outTypeFunc: addOutputType });\n      this.statements = ({ inputs, outputs }) => {\n        return [`${outputs.sum} = ${inputs.a} + ${inputs.b};`];\n      };\n    }\n  }\n  class Sub extends BinaryOp {\n    constructor({ a, b }) {\n      super({ a, b, outKey: "difference", outTypeFunc: subOutputType });\n      this.statements = ({ inputs, outputs }) => {\n        return [`${outputs.difference} = ${inputs.a} - ${inputs.b};`];\n      };\n    }\n  }\n  class Mul extends BinaryOp {\n    constructor({ a, b }) {\n      super({ a, b, outKey: "product", outTypeFunc: mulOutputType });\n      this.statements = ({ inputs, outputs }) => {\n        return [`${outputs.product} = ${inputs.a} * ${inputs.b};`];\n      };\n    }\n  }\n  const normalize = (a) => new Normalize({ a });\n  const extendVec = (a, b) => new ExtendVec({ a, b });\n  class Normalize extends UnaryOp {\n    constructor({ a }) {\n      super({ a, outTypeFunc: (aType) => aType, outKey: "normalize" });\n      this.statements = ({ inputs, outputs }) => [\n        `${outputs.normalize} = normalize(${inputs.a});`\n      ];\n    }\n  }\n  function extendVecOutputType(type) {\n    if (type === "float") return "vec2";\n    if (type === "vec2") return "vec3";\n    if (type === "vec3") return "vec4";\n    throw new Error("Invalid type");\n  }\n  class ExtendVec extends BinaryOp {\n    constructor({ a, b }) {\n      const type = valType(a);\n      const outType = extendVecOutputType(type);\n      super({ a, b, outKey: "extend", outTypeFunc: () => outType });\n      this.statements = ({ inputs, outputs }) => [\n        `${outputs.extend} = ${outType}(${inputs.a}, ${inputs.b});`\n      ];\n    }\n  }\n  const transformPos = (position, {\n    scale,\n    scales,\n    rotate,\n    translate\n  }) => {\n    return new TransformPosition({ position, scale, scales, rotate, translate }).outputs.position;\n  };\n  const transformDir = (dir, {\n    scale,\n    scales,\n    rotate\n  }) => {\n    return new TransformDir({ dir, scale, scales, rotate }).outputs.dir;\n  };\n  class TransformPosition extends Dyno {\n    constructor({\n      position,\n      scale,\n      scales,\n      rotate,\n      translate\n    }) {\n      super({\n        inTypes: {\n          position: "vec3",\n          scale: "float",\n          scales: "vec3",\n          rotate: "vec4",\n          translate: "vec3"\n        },\n        outTypes: { position: "vec3" },\n        inputs: { position, scale, scales, rotate, translate },\n        statements: ({ inputs, outputs }) => {\n          const { position: position2 } = outputs;\n          if (!position2) {\n            return [];\n          }\n          const { scale: scale2, scales: scales2, rotate: rotate2, translate: translate2 } = inputs;\n          return [\n            `${position2} = ${inputs.position ?? "vec3(0.0, 0.0, 0.0)"};`,\n            !scale2 ? null : `${position2} *= ${scale2};`,\n            !scales2 ? null : `${position2} *= ${scales2};`,\n            !rotate2 ? null : `${position2} = quatVec(${rotate2}, ${position2});`,\n            !translate2 ? null : `${position2} += ${translate2};`\n          ].filter(Boolean);\n        }\n      });\n    }\n  }\n  class TransformDir extends Dyno {\n    constructor({\n      dir,\n      scale,\n      scales,\n      rotate\n    }) {\n      super({\n        inTypes: { dir: "vec3", scale: "float", scales: "vec3", rotate: "vec4" },\n        outTypes: { dir: "vec3" },\n        inputs: { dir, scale, scales, rotate },\n        statements: ({ inputs, outputs }) => {\n          const { dir: dir2 } = outputs;\n          if (!dir2) {\n            return [];\n          }\n          const { scale: scale2, scales: scales2, rotate: rotate2 } = inputs;\n          return [\n            `${dir2} = ${inputs.dir ?? "vec3(0.0, 0.0, 0.0)"};`,\n            !scale2 ? null : `${dir2} *= ${scale2};`,\n            !scales2 ? null : `${dir2} *= ${scales2};`,\n            !rotate2 ? null : `${dir2} = quatVec(${rotate2}, ${dir2});`\n          ].filter(Boolean);\n        }\n      });\n    }\n  }\n  var computeUvec4_default = "precision highp float;\\nprecision highp int;\\nprecision highp sampler2D;\\nprecision highp usampler2D;\\nprecision highp isampler2D;\\nprecision highp sampler2DArray;\\nprecision highp usampler2DArray;\\nprecision highp isampler2DArray;\\nprecision highp sampler3D;\\nprecision highp usampler3D;\\nprecision highp isampler3D;\\n\\n#include <splatDefines>\\n\\nuniform uint targetLayer;\\nuniform int targetBase;\\nuniform int targetCount;\\n\\nout uvec4 target;\\n\\n{{ GLOBALS }}\\n\\nvoid produceSplat(int index) {\\n    {{ STATEMENTS }}\\n}\\n\\nvoid main() {\\n    int targetIndex = int(targetLayer << SPLAT_TEX_LAYER_BITS) + int(uint(gl_FragCoord.y) << SPLAT_TEX_WIDTH_BITS) + int(gl_FragCoord.x);\\n    int index = targetIndex - targetBase;\\n\\n    if ((index >= 0) && (index < targetCount)) {\\n        produceSplat(index);\\n    } else {\\n        target = uvec4(0u, 0u, 0u, 0u);\\n    }\\n}";\n  const _PackedSplats = class _PackedSplats {\n    constructor(options = {}) {\n      this.maxSplats = 0;\n      this.numSplats = 0;\n      this.packedArray = null;\n      this.isInitialized = false;\n      this.target = null;\n      this.source = null;\n      this.needsUpdate = true;\n      this.extra = {};\n      this.dyno = new DynoPackedSplats({ packedSplats: this });\n      this.initialized = Promise.resolve(this);\n      this.reinitialize(options);\n    }\n    reinitialize(options) {\n      this.isInitialized = false;\n      if (options.url || options.fileBytes || options.construct) {\n        this.initialized = this.asyncInitialize(options).then(() => {\n          this.isInitialized = true;\n          return this;\n        });\n      } else {\n        this.initialize(options);\n        this.isInitialized = true;\n        this.initialized = Promise.resolve(this);\n      }\n    }\n    initialize(options) {\n      if (options.packedArray) {\n        this.packedArray = options.packedArray;\n        this.maxSplats = Math.floor(this.packedArray.length / 4);\n        this.maxSplats = Math.floor(this.maxSplats / SPLAT_TEX_WIDTH) * SPLAT_TEX_WIDTH;\n        this.numSplats = Math.min(\n          this.maxSplats,\n          options.numSplats ?? Number.POSITIVE_INFINITY\n        );\n      } else {\n        this.maxSplats = options.maxSplats ?? 0;\n        this.numSplats = 0;\n      }\n      this.extra = options.extra ?? {};\n    }\n    async asyncInitialize(options) {\n      const { url, fileBytes, construct } = options;\n      if (url) {\n        const loader = new SplatLoader();\n        loader.packedSplats = this;\n        await loader.loadAsync(url);\n      } else if (fileBytes) {\n        const unpacked = await unpackSplats({\n          input: fileBytes,\n          fileType: options.fileType,\n          pathOrUrl: options.fileName ?? url\n        });\n        this.initialize(unpacked);\n      }\n      if (construct) {\n        const maybePromise = construct(this);\n        if (maybePromise instanceof Promise) {\n          await maybePromise;\n        }\n      }\n    }\n    // Call this when you are finished with the PackedSplats and want to free\n    // any buffers it holds.\n    dispose() {\n      if (this.target) {\n        this.target.dispose();\n        this.target = null;\n      }\n      if (this.source) {\n        this.source.dispose();\n        this.source = null;\n      }\n    }\n    // Ensures that this.packedArray can fit numSplats Gsplats. If it\'s too small,\n    // resize exponentially and copy over the original data.\n    //\n    // Typically you don\'t need to call this, because calling this.setSplat(index, ...)\n    // and this.pushSplat(...) will automatically call ensureSplats() so we have\n    // enough splats.\n    ensureSplats(numSplats) {\n      const targetSize = numSplats <= this.maxSplats ? this.maxSplats : (\n        // Grow exponentially to avoid frequent reallocations\n        Math.max(numSplats, 2 * this.maxSplats)\n      );\n      const currentSize = !this.packedArray ? 0 : this.packedArray.length / 4;\n      if (!this.packedArray || targetSize > currentSize) {\n        this.maxSplats = getTextureSize(targetSize).maxSplats;\n        const newArray = new Uint32Array(this.maxSplats * 4);\n        if (this.packedArray) {\n          newArray.set(this.packedArray);\n        }\n        this.packedArray = newArray;\n      }\n      return this.packedArray;\n    }\n    // Ensure the extra array for the given level is large enough to hold numSplats\n    ensureSplatsSh(level, numSplats) {\n      let wordsPerSplat;\n      let key;\n      if (level === 0) {\n        return this.ensureSplats(numSplats);\n      }\n      if (level === 1) {\n        wordsPerSplat = 2;\n        key = "sh1";\n      } else if (level === 2) {\n        wordsPerSplat = 4;\n        key = "sh2";\n      } else if (level === 3) {\n        wordsPerSplat = 4;\n        key = "sh3";\n      } else {\n        throw new Error(`Invalid level: ${level}`);\n      }\n      let maxSplats = !this.extra[key] ? 0 : this.extra[key].length / wordsPerSplat;\n      const targetSize = numSplats <= maxSplats ? maxSplats : Math.max(numSplats, 2 * maxSplats);\n      if (!this.extra[key] || targetSize > maxSplats) {\n        maxSplats = getTextureSize(targetSize).maxSplats;\n        const newArray = new Uint32Array(maxSplats * wordsPerSplat);\n        if (this.extra[key]) {\n          newArray.set(this.extra[key]);\n        }\n        this.extra[key] = newArray;\n      }\n      return this.extra[key];\n    }\n    // Unpack the 16-byte Gsplat data at index into the Three.js components\n    // center: THREE.Vector3, scales: THREE.Vector3, quaternion: THREE.Quaternion,\n    // opacity: number 0..1, color: THREE.Color 0..1.\n    getSplat(index) {\n      if (!this.packedArray || index >= this.numSplats) {\n        throw new Error("Invalid index");\n      }\n      return unpackSplat(this.packedArray, index);\n    }\n    // Set all PackedSplat components at index with the provided Gsplat attributes\n    // (can be the same objects returned by getSplat). Ensures there is capacity\n    // for at least index+1 Gsplats.\n    setSplat(index, center, scales, quaternion, opacity, color) {\n      const packedSplats = this.ensureSplats(index + 1);\n      setPackedSplat(\n        packedSplats,\n        index,\n        center.x,\n        center.y,\n        center.z,\n        scales.x,\n        scales.y,\n        scales.z,\n        quaternion.x,\n        quaternion.y,\n        quaternion.z,\n        quaternion.w,\n        opacity,\n        color.r,\n        color.g,\n        color.b\n      );\n      this.numSplats = Math.max(this.numSplats, index + 1);\n    }\n    // Effectively calls this.setSplat(this.numSplats++, center, ...), useful on\n    // construction where you just want to iterate and create a collection of Gsplats.\n    pushSplat(center, scales, quaternion, opacity, color) {\n      const packedSplats = this.ensureSplats(this.numSplats + 1);\n      setPackedSplat(\n        packedSplats,\n        this.numSplats,\n        center.x,\n        center.y,\n        center.z,\n        scales.x,\n        scales.y,\n        scales.z,\n        quaternion.x,\n        quaternion.y,\n        quaternion.z,\n        quaternion.w,\n        opacity,\n        color.r,\n        color.g,\n        color.b\n      );\n      ++this.numSplats;\n    }\n    // Iterate over Gsplats index 0..=(this.numSplats-1), unpack each Gsplat\n    // and invoke the callback function with the Gsplat attributes.\n    forEachSplat(callback) {\n      if (!this.packedArray || !this.numSplats) {\n        return;\n      }\n      for (let i2 = 0; i2 < this.numSplats; ++i2) {\n        const unpacked = unpackSplat(this.packedArray, i2);\n        callback(\n          i2,\n          unpacked.center,\n          unpacked.scales,\n          unpacked.quaternion,\n          unpacked.opacity,\n          unpacked.color\n        );\n      }\n    }\n    // Ensures our PackedSplats.target render target has enough space to generate\n    // maxSplats total Gsplats, and reallocate if not large enough.\n    ensureGenerate(maxSplats) {\n      if (this.target && (maxSplats ?? 1) <= this.maxSplats) {\n        return false;\n      }\n      this.dispose();\n      const textureSize = getTextureSize(maxSplats ?? 1);\n      const { width, height, depth } = textureSize;\n      this.maxSplats = textureSize.maxSplats;\n      this.target = new WebGLArrayRenderTarget(width, height, depth, {\n        depthBuffer: false,\n        stencilBuffer: false,\n        generateMipmaps: false,\n        magFilter: NearestFilter,\n        minFilter: NearestFilter\n      });\n      this.target.texture.format = RGBAIntegerFormat;\n      this.target.texture.type = UnsignedIntType;\n      this.target.texture.internalFormat = "RGBA32UI";\n      this.target.scissorTest = true;\n      return true;\n    }\n    // Given an array of splatCounts (.numSplats for each\n    // SplatGenerator/SplatMesh in the scene), compute a\n    // "mapping layout" in the composite array of generated outputs.\n    generateMapping(splatCounts) {\n      let maxSplats = 0;\n      const mapping = splatCounts.map((numSplats) => {\n        const base = maxSplats;\n        const rounded = Math.ceil(numSplats / SPLAT_TEX_WIDTH) * SPLAT_TEX_WIDTH;\n        maxSplats += rounded;\n        return { base, count: numSplats };\n      });\n      return { maxSplats, mapping };\n    }\n    // Returns a THREE.DataArrayTexture representing the PackedSplats content as\n    // a Uint32x4 data array texture (2048 x 2048 x depth in size)\n    getTexture() {\n      if (this.target) {\n        return this.target.texture;\n      }\n      if (this.source || this.packedArray) {\n        const source = this.maybeUpdateSource();\n        return source;\n      }\n      return _PackedSplats.getEmpty();\n    }\n    // Check if source texture needs to be created/updated\n    maybeUpdateSource() {\n      if (!this.packedArray) {\n        throw new Error("No packed splats");\n      }\n      if (this.needsUpdate || !this.source) {\n        this.needsUpdate = false;\n        if (this.source) {\n          const { width, height, depth } = this.source.image;\n          if (this.maxSplats !== width * height * depth) {\n            this.source.dispose();\n            this.source = null;\n          }\n        }\n        if (!this.source) {\n          const { width, height, depth } = getTextureSize(this.maxSplats);\n          this.source = new DataArrayTexture(\n            this.packedArray,\n            width,\n            height,\n            depth\n          );\n          this.source.format = RGBAIntegerFormat;\n          this.source.type = UnsignedIntType;\n          this.source.internalFormat = "RGBA32UI";\n          this.source.needsUpdate = true;\n        } else if (this.packedArray.buffer !== this.source.image.data.buffer) {\n          this.source.image.data = new Uint8Array(this.packedArray.buffer);\n        }\n        this.source.needsUpdate = true;\n      }\n      return this.source;\n    }\n    // Can be used where you need an uninitialized THREE.DataArrayTexture like\n    // a uniform you will update with the result of this.getTexture() later.\n    static getEmpty() {\n      if (!_PackedSplats.emptySource) {\n        const { width, height, depth, maxSplats } = getTextureSize(1);\n        const emptyArray = new Uint32Array(maxSplats * 4);\n        _PackedSplats.emptySource = new DataArrayTexture(\n          emptyArray,\n          width,\n          height,\n          depth\n        );\n        _PackedSplats.emptySource.format = RGBAIntegerFormat;\n        _PackedSplats.emptySource.type = UnsignedIntType;\n        _PackedSplats.emptySource.internalFormat = "RGBA32UI";\n        _PackedSplats.emptySource.needsUpdate = true;\n      }\n      return _PackedSplats.emptySource;\n    }\n    // Get a program and THREE.RawShaderMaterial for a given GsplatGenerator,\n    // generating it if necessary and caching the result.\n    prepareProgramMaterial(generator) {\n      let program = _PackedSplats.generatorProgram.get(generator);\n      if (!program) {\n        const graph = dynoBlock(\n          { index: "int" },\n          { output: "uvec4" },\n          ({ index }) => {\n            generator.inputs.index = index;\n            const gsplat = generator.outputs.gsplat;\n            const output = outputPackedSplat(gsplat);\n            return { output };\n          }\n        );\n        if (!_PackedSplats.programTemplate) {\n          _PackedSplats.programTemplate = new DynoProgramTemplate(\n            computeUvec4_default\n          );\n        }\n        program = new DynoProgram({\n          graph,\n          inputs: { index: "index" },\n          outputs: { output: "target" },\n          template: _PackedSplats.programTemplate\n        });\n        Object.assign(program.uniforms, {\n          targetLayer: { value: 0 },\n          targetBase: { value: 0 },\n          targetCount: { value: 0 }\n        });\n        _PackedSplats.generatorProgram.set(generator, program);\n      }\n      const material = program.prepareMaterial();\n      _PackedSplats.mesh.material = material;\n      return { program, material };\n    }\n    saveRenderState(renderer) {\n      return {\n        xrEnabled: renderer.xr.enabled,\n        autoClear: renderer.autoClear\n      };\n    }\n    resetRenderState(renderer, state) {\n      renderer.setRenderTarget(null);\n      renderer.xr.enabled = state.xrEnabled;\n      renderer.autoClear = state.autoClear;\n    }\n    // Executes a dyno program specified by generator which is any DynoBlock that\n    // maps { index: "int" } to { gsplat: Gsplat }. This is called in\n    // SparkRenderer.updateInternal() to re-generate Gsplats in the scene for\n    // SplatGenerator instances whose version is newer than what was generated\n    // for it last time.\n    generate({\n      generator,\n      base,\n      count,\n      renderer\n    }) {\n      if (!this.target) {\n        throw new Error("Target must be initialized with ensureSplats");\n      }\n      if (base + count > this.maxSplats) {\n        throw new Error("Base + count exceeds maxSplats");\n      }\n      const { program, material } = this.prepareProgramMaterial(generator);\n      program.update();\n      const renderState = this.saveRenderState(renderer);\n      const nextBase = Math.ceil((base + count) / SPLAT_TEX_WIDTH) * SPLAT_TEX_WIDTH;\n      const layerSize = SPLAT_TEX_WIDTH * SPLAT_TEX_HEIGHT;\n      material.uniforms.targetBase.value = base;\n      material.uniforms.targetCount.value = count;\n      while (base < nextBase) {\n        const layer = Math.floor(base / layerSize);\n        material.uniforms.targetLayer.value = layer;\n        const layerBase = layer * layerSize;\n        const layerYStart = Math.floor((base - layerBase) / SPLAT_TEX_WIDTH);\n        const layerYEnd = Math.min(\n          SPLAT_TEX_HEIGHT,\n          Math.ceil((nextBase - layerBase) / SPLAT_TEX_WIDTH)\n        );\n        this.target.scissor.set(\n          0,\n          layerYStart,\n          SPLAT_TEX_WIDTH,\n          layerYEnd - layerYStart\n        );\n        renderer.setRenderTarget(this.target, layer);\n        renderer.xr.enabled = false;\n        renderer.autoClear = false;\n        renderer.render(_PackedSplats.scene, _PackedSplats.camera);\n        base += SPLAT_TEX_WIDTH * (layerYEnd - layerYStart);\n      }\n      this.resetRenderState(renderer, renderState);\n      return { nextBase };\n    }\n  };\n  _PackedSplats.emptySource = null;\n  _PackedSplats.programTemplate = null;\n  _PackedSplats.generatorProgram = /* @__PURE__ */ new Map();\n  _PackedSplats.geometry = new PlaneGeometry(2, 2);\n  _PackedSplats.mesh = new Mesh(\n    _PackedSplats.geometry,\n    new RawShaderMaterial({ visible: false })\n  );\n  _PackedSplats.scene = new Scene().add(_PackedSplats.mesh);\n  _PackedSplats.camera = new Camera();\n  let PackedSplats = _PackedSplats;\n  class DynoPackedSplats extends DynoUniform {\n    constructor({ packedSplats } = {}) {\n      super({\n        key: "packedSplats",\n        type: TPackedSplats,\n        globals: () => [definePackedSplats],\n        value: {\n          texture: PackedSplats.getEmpty(),\n          numSplats: 0\n        },\n        update: (value) => {\n          var _a2, _b2;\n          value.texture = ((_a2 = this.packedSplats) == null ? void 0 : _a2.getTexture()) ?? PackedSplats.getEmpty();\n          value.numSplats = ((_b2 = this.packedSplats) == null ? void 0 : _b2.numSplats) ?? 0;\n          return value;\n        }\n      });\n      this.packedSplats = packedSplats;\n    }\n  }\n  var computeVec4_default = "precision highp float;\\nprecision highp int;\\nprecision highp sampler2D;\\nprecision highp usampler2D;\\nprecision highp isampler2D;\\nprecision highp sampler2DArray;\\nprecision highp usampler2DArray;\\nprecision highp isampler2DArray;\\nprecision highp sampler3D;\\nprecision highp usampler3D;\\nprecision highp isampler3D;\\n\\n#include <splatDefines>\\n\\nuniform uint targetLayer;\\nuniform int targetBase;\\nuniform int targetCount;\\n\\nout vec4 target;\\n\\n{{ GLOBALS }}\\n\\nvoid computeReadback(int index) {\\n    {{ STATEMENTS }}\\n}\\n\\nvoid main() {\\n    int targetIndex = int(targetLayer << SPLAT_TEX_LAYER_BITS) + int(uint(gl_FragCoord.y) << SPLAT_TEX_WIDTH_BITS) + int(gl_FragCoord.x);\\n    int index = targetIndex - targetBase;\\n\\n    if ((index >= 0) && (index < targetCount)) {\\n        computeReadback(index);\\n    } else {\\n        target = vec4(0.0, 0.0, 0.0, 0.0);\\n    }\\n}";\n  const _Readback = class _Readback {\n    constructor({ renderer } = {}) {\n      this.renderer = renderer;\n      this.capacity = 0;\n      this.count = 0;\n    }\n    dispose() {\n      if (this.target) {\n        this.target.dispose();\n        this.target = void 0;\n      }\n    }\n    // Ensure we have a buffer large enough for the readback of count indices.\n    // Pass in previous bufer of the desired type.\n    ensureBuffer(count, buffer) {\n      const roundedCount = Math.ceil(Math.max(1, count) / SPLAT_TEX_WIDTH) * SPLAT_TEX_WIDTH;\n      const bytes = roundedCount * 4;\n      if (buffer.byteLength >= bytes) {\n        return buffer;\n      }\n      const newBuffer = new ArrayBuffer(bytes);\n      if (buffer instanceof ArrayBuffer) {\n        return newBuffer;\n      }\n      const ctor = buffer.constructor;\n      return new ctor(newBuffer);\n    }\n    // Ensure our render target is large enough for the readback of capacity indices.\n    ensureCapacity(capacity) {\n      const { width, height, depth, maxSplats } = getTextureSize(capacity);\n      if (!this.target || maxSplats > this.capacity) {\n        this.dispose();\n        this.capacity = maxSplats;\n        this.target = new WebGLArrayRenderTarget(width, height, depth, {\n          depthBuffer: false,\n          stencilBuffer: false,\n          generateMipmaps: false,\n          magFilter: NearestFilter,\n          minFilter: NearestFilter\n        });\n        this.target.texture.format = RGBAFormat;\n        this.target.texture.type = UnsignedByteType;\n        this.target.texture.internalFormat = "RGBA8";\n        this.target.scissorTest = true;\n      }\n    }\n    // Get a program and THREE.RawShaderMaterial for a given Rgba8Readback,\n    // generating it if necessary and caching the result.\n    prepareProgramMaterial(reader) {\n      let program = _Readback.readbackProgram.get(reader);\n      if (!program) {\n        const graph = dynoBlock(\n          { index: "int" },\n          { rgba8: "vec4" },\n          ({ index }) => {\n            reader.inputs.index = index;\n            const rgba8 = new OutputRgba8({ rgba8: reader.outputs.rgba8 });\n            return { rgba8 };\n          }\n        );\n        if (!_Readback.programTemplate) {\n          _Readback.programTemplate = new DynoProgramTemplate(computeVec4_default);\n        }\n        program = new DynoProgram({\n          graph,\n          inputs: { index: "index" },\n          outputs: { rgba8: "target" },\n          template: _Readback.programTemplate\n        });\n        Object.assign(program.uniforms, {\n          targetLayer: { value: 0 },\n          targetBase: { value: 0 },\n          targetCount: { value: 0 }\n        });\n        _Readback.readbackProgram.set(reader, program);\n      }\n      const material = program.prepareMaterial();\n      _Readback.mesh.material = material;\n      return { program, material };\n    }\n    saveRenderState(renderer) {\n      return {\n        xrEnabled: renderer.xr.enabled,\n        autoClear: renderer.autoClear\n      };\n    }\n    resetRenderState(renderer, state) {\n      renderer.setRenderTarget(null);\n      renderer.xr.enabled = state.xrEnabled;\n      renderer.autoClear = state.autoClear;\n    }\n    process({\n      count,\n      material\n    }) {\n      const renderer = this.renderer;\n      if (!renderer) {\n        throw new Error("No renderer");\n      }\n      if (!this.target) {\n        throw new Error("No target");\n      }\n      const layerSize = SPLAT_TEX_WIDTH * SPLAT_TEX_HEIGHT;\n      material.uniforms.targetBase.value = 0;\n      material.uniforms.targetCount.value = count;\n      let baseIndex = 0;\n      while (baseIndex < count) {\n        const layer = Math.floor(baseIndex / layerSize);\n        const layerBase = layer * layerSize;\n        const layerYEnd = Math.min(\n          SPLAT_TEX_HEIGHT,\n          Math.ceil((count - layerBase) / SPLAT_TEX_WIDTH)\n        );\n        material.uniforms.targetLayer.value = layer;\n        this.target.scissor.set(0, 0, SPLAT_TEX_WIDTH, layerYEnd);\n        renderer.setRenderTarget(this.target, layer);\n        renderer.xr.enabled = false;\n        renderer.autoClear = false;\n        renderer.render(_Readback.scene, _Readback.camera);\n        baseIndex += SPLAT_TEX_WIDTH * layerYEnd;\n      }\n      this.count = count;\n    }\n    async read({\n      readback\n    }) {\n      const renderer = this.renderer;\n      if (!renderer) {\n        throw new Error("No renderer");\n      }\n      if (!this.target) {\n        throw new Error("No target");\n      }\n      const roundedCount = Math.ceil(this.count / SPLAT_TEX_WIDTH) * SPLAT_TEX_WIDTH;\n      if (readback.byteLength < roundedCount * 4) {\n        throw new Error(\n          `Readback buffer too small: ${readback.byteLength} < ${roundedCount * 4}`\n        );\n      }\n      const readbackUint8 = new Uint8Array(\n        readback instanceof ArrayBuffer ? readback : readback.buffer\n      );\n      const layerSize = SPLAT_TEX_WIDTH * SPLAT_TEX_HEIGHT;\n      let baseIndex = 0;\n      const promises = [];\n      while (baseIndex < this.count) {\n        const layer = Math.floor(baseIndex / layerSize);\n        const layerBase = layer * layerSize;\n        const layerYEnd = Math.min(\n          SPLAT_TEX_HEIGHT,\n          Math.ceil((this.count - layerBase) / SPLAT_TEX_WIDTH)\n        );\n        renderer.setRenderTarget(this.target, layer);\n        const readbackSize = SPLAT_TEX_WIDTH * layerYEnd * 4;\n        const subReadback = readbackUint8.subarray(\n          layerBase * 4,\n          layerBase * 4 + readbackSize\n        );\n        const promise = renderer == null ? void 0 : renderer.readRenderTargetPixelsAsync(\n          this.target,\n          0,\n          0,\n          SPLAT_TEX_WIDTH,\n          layerYEnd,\n          subReadback\n        );\n        promises.push(promise);\n        baseIndex += SPLAT_TEX_WIDTH * layerYEnd;\n      }\n      return Promise.all(promises).then(() => readback);\n    }\n    // Perform render operation to run the Rgba8Readback program\n    // but don\'t perform the readback yet.\n    render({\n      reader,\n      count,\n      renderer\n    }) {\n      this.renderer = renderer || this.renderer;\n      if (!this.renderer) {\n        throw new Error("No renderer");\n      }\n      this.ensureCapacity(count);\n      const { program, material } = this.prepareProgramMaterial(reader);\n      program.update();\n      const renderState = this.saveRenderState(this.renderer);\n      this.process({ count, material });\n      this.resetRenderState(this.renderer, renderState);\n    }\n    // Perform a readback of the render target, returning a buffer of the\n    // given type.\n    async readback({\n      readback\n    }) {\n      if (!this.renderer) {\n        throw new Error("No renderer");\n      }\n      const renderState = this.saveRenderState(this.renderer);\n      const promise = this.read({ readback });\n      this.resetRenderState(this.renderer, renderState);\n      return promise;\n    }\n    // Perform a render and readback operation for the given Rgba8Readback,\n    // and readback buffer (call ensureBuffer first).\n    async renderReadback({\n      reader,\n      count,\n      renderer,\n      readback\n    }) {\n      this.renderer = renderer || this.renderer;\n      if (!this.renderer) {\n        throw new Error("No renderer");\n      }\n      this.ensureCapacity(count);\n      const { program, material } = this.prepareProgramMaterial(reader);\n      program.update();\n      const renderState = this.saveRenderState(this.renderer);\n      this.process({ count, material });\n      const promise = this.read({ readback });\n      this.resetRenderState(this.renderer, renderState);\n      return promise;\n    }\n    getTexture() {\n      var _a2;\n      return (_a2 = this.target) == null ? void 0 : _a2.texture;\n    }\n  };\n  _Readback.programTemplate = null;\n  _Readback.readbackProgram = /* @__PURE__ */ new Map();\n  _Readback.geometry = new PlaneGeometry(2, 2);\n  _Readback.mesh = new Mesh(\n    _Readback.geometry,\n    new RawShaderMaterial({ visible: false })\n  );\n  _Readback.scene = new Scene().add(_Readback.mesh);\n  _Readback.camera = new Camera();\n  let Readback = _Readback;\n  const _RgbaArray = class _RgbaArray {\n    constructor(options = {}) {\n      this.capacity = 0;\n      this.count = 0;\n      this.array = null;\n      this.readback = null;\n      this.source = null;\n      this.needsUpdate = true;\n      this.dyno = new DynoUniform({\n        key: "rgbaArray",\n        type: TRgbaArray,\n        globals: () => [defineRgbaArray],\n        value: {\n          texture: _RgbaArray.getEmpty(),\n          count: 0\n        },\n        update: (value) => {\n          var _a2;\n          value.texture = ((_a2 = this.readback) == null ? void 0 : _a2.getTexture()) ?? this.source ?? _RgbaArray.getEmpty();\n          value.count = this.count;\n          return value;\n        }\n      });\n      if (options.array) {\n        this.array = options.array;\n        this.capacity = Math.floor(this.array.length / 4);\n        this.capacity = Math.floor(this.capacity / SPLAT_TEX_WIDTH) * SPLAT_TEX_WIDTH;\n        this.count = Math.min(\n          this.capacity,\n          options.count ?? Number.POSITIVE_INFINITY\n        );\n      } else {\n        this.capacity = options.capacity ?? 0;\n        this.count = 0;\n      }\n    }\n    // Free up resources\n    dispose() {\n      if (this.readback) {\n        this.readback.dispose();\n        this.readback = null;\n      }\n      if (this.source) {\n        this.source.dispose();\n        this.source = null;\n      }\n    }\n    // Ensure that our array is large enough to hold capacity RGBA8 values.\n    ensureCapacity(capacity) {\n      var _a2;\n      if (!this.array || capacity > (((_a2 = this.array) == null ? void 0 : _a2.length) ?? 0) / 4) {\n        this.capacity = getTextureSize(capacity).maxSplats;\n        const newArray = new Uint8Array(this.capacity * 4);\n        if (this.array) {\n          newArray.set(this.array);\n        }\n        this.array = newArray;\n      }\n      return this.array;\n    }\n    // Get the THREE.DataArrayTexture from either the readback or the source.\n    getTexture() {\n      var _a2;\n      let texture = (_a2 = this.readback) == null ? void 0 : _a2.getTexture();\n      if (this.source || this.array) {\n        texture = this.maybeUpdateSource();\n      }\n      return texture ?? _RgbaArray.getEmpty();\n    }\n    // Create or get a THREE.DataArrayTexture from the data array.\n    maybeUpdateSource() {\n      if (!this.array) {\n        throw new Error("No array");\n      }\n      if (this.needsUpdate || !this.source) {\n        this.needsUpdate = false;\n        if (this.source) {\n          const { width, height, depth } = this.source.image;\n          if (this.capacity !== width * height * depth) {\n            this.source.dispose();\n            this.source = null;\n          }\n        }\n        if (!this.source) {\n          const { width, height, depth } = getTextureSize(this.capacity);\n          this.source = new DataArrayTexture(\n            this.array,\n            width,\n            height,\n            depth\n          );\n          this.source.format = RGBAFormat;\n          this.source.type = UnsignedByteType;\n          this.source.internalFormat = "RGBA8";\n          this.source.needsUpdate = true;\n        } else if (this.array.buffer !== this.source.image.data.buffer) {\n          this.source.image.data = new Uint8Array(this.array.buffer);\n        }\n        this.source.needsUpdate = true;\n      }\n      return this.source;\n    }\n    // Generate the RGBA8 values from a Rgba8Readback dyno program.\n    render({\n      reader,\n      count,\n      renderer\n    }) {\n      if (!this.readback) {\n        this.readback = new Readback({ renderer });\n      }\n      this.readback.render({ reader, count, renderer });\n      this.capacity = this.readback.capacity;\n      this.count = this.readback.count;\n    }\n    // Extract the RGBA8 values from a PackedSplats collection.\n    fromPackedSplats({\n      packedSplats,\n      base,\n      count,\n      renderer\n    }) {\n      const { dynoSplats, dynoBase, dynoCount, reader } = _RgbaArray.makeDynos();\n      dynoSplats.packedSplats = packedSplats;\n      dynoBase.value = base;\n      dynoCount.value = count;\n      this.render({ reader, count, renderer });\n      return this;\n    }\n    // Read back the RGBA8 values from the readback buffer.\n    async read() {\n      if (!this.readback) {\n        throw new Error("No readback");\n      }\n      if (!this.array || this.array.length < this.count * 4) {\n        this.array = new Uint8Array(this.capacity * 4);\n      }\n      const result = await this.readback.readback({ readback: this.array });\n      return result.subarray(0, this.count * 4);\n    }\n    // Can be used where you need an uninitialized THREE.DataArrayTexture like\n    // a uniform you will update with the result of this.getTexture() later.\n    static getEmpty() {\n      if (!_RgbaArray.emptySource) {\n        const emptyArray = new Uint8Array(1 * 4);\n        _RgbaArray.emptySource = new DataArrayTexture(emptyArray, 1, 1, 1);\n        _RgbaArray.emptySource.format = RGBAFormat;\n        _RgbaArray.emptySource.type = UnsignedByteType;\n        _RgbaArray.emptySource.internalFormat = "RGBA8";\n        _RgbaArray.emptySource.needsUpdate = true;\n      }\n      return _RgbaArray.emptySource;\n    }\n    // Create a dyno program that can extract RGBA8 values from a PackedSplats\n    static makeDynos() {\n      if (!_RgbaArray.dynos) {\n        const dynoSplats = new DynoPackedSplats();\n        const dynoBase = new DynoInt({ value: 0 });\n        const dynoCount = new DynoInt({ value: 0 });\n        const reader = dynoBlock(\n          { index: "int" },\n          { rgba8: "vec4" },\n          ({ index }) => {\n            if (!index) {\n              throw new Error("index is undefined");\n            }\n            index = add(index, dynoBase);\n            const gsplat = readPackedSplatRange(\n              dynoSplats,\n              index,\n              dynoBase,\n              dynoCount\n            );\n            return { rgba8: splitGsplat(gsplat).outputs.rgba };\n          }\n        );\n        _RgbaArray.dynos = { dynoSplats, dynoBase, dynoCount, reader };\n      }\n      return _RgbaArray.dynos;\n    }\n  };\n  _RgbaArray.emptySource = null;\n  _RgbaArray.dynos = null;\n  let RgbaArray = _RgbaArray;\n  const TRgbaArray = { type: "RgbaArray" };\n  const defineRgbaArray = unindent(`\n  struct RgbaArray {\n    sampler2DArray texture;\n    int count;\n  };\n`);\n  function readRgbaArray(rgba, index) {\n    const dyno2 = new Dyno({\n      inTypes: { rgba: TRgbaArray, index: "int" },\n      outTypes: { rgba: "vec4" },\n      inputs: { rgba, index },\n      globals: () => [defineRgbaArray],\n      statements: ({ inputs, outputs }) => unindentLines(`\n        if ((index >= 0) && (index < ${inputs.rgba}.count)) {\n          ${outputs.rgba} = texelFetch(${inputs.rgba}.texture, splatTexCoord(index), 0);\n        } else {\n          ${outputs.rgba} = vec4(0.0, 0.0, 0.0, 0.0);\n        }\n      `)\n    });\n    return dyno2.outputs.rgba;\n  }\n  function sdfTypeToNumber(type) {\n    switch (type) {\n      case "all":\n        return 0;\n      case "plane":\n        return 1;\n      case "sphere":\n        return 2;\n      case "box":\n        return 3;\n      case "ellipsoid":\n        return 4;\n      case "cylinder":\n        return 5;\n      case "capsule":\n        return 6;\n      case "infinite_cone":\n        return 7;\n      default:\n        throw new Error(`Unknown SDF type: ${type}`);\n    }\n  }\n  function rgbaBlendModeToNumber(mode) {\n    switch (mode) {\n      case "multiply":\n        return 0;\n      case "set_rgb":\n        return 1;\n      case "add_rgba":\n        return 2;\n      default:\n        throw new Error(`Unknown blend mode: ${mode}`);\n    }\n  }\n  class SplatEditSdf extends Object3D {\n    constructor(options = {}) {\n      super();\n      const { type, invert, opacity, color, displace, radius } = options;\n      this.type = type ?? "sphere";\n      this.invert = invert ?? false;\n      this.opacity = opacity ?? 1;\n      this.color = color ?? new Color(1, 1, 1);\n      this.displace = displace ?? new Vector3(0, 0, 0);\n      this.radius = radius ?? 0;\n    }\n  }\n  const _SplatEdit = class _SplatEdit extends Object3D {\n    constructor(options = {}) {\n      const {\n        name,\n        rgbaBlendMode = "multiply",\n        sdfSmooth = 0,\n        softEdge = 0,\n        invert = false,\n        sdfs = null\n      } = options;\n      super();\n      this.rgbaBlendMode = rgbaBlendMode;\n      this.sdfSmooth = sdfSmooth;\n      this.softEdge = softEdge;\n      this.invert = invert;\n      this.sdfs = sdfs;\n      this.ordering = _SplatEdit.nextOrdering++;\n      this.name = name ?? `Edit ${this.ordering}`;\n    }\n    addSdf(sdf) {\n      if (this.sdfs == null) {\n        this.sdfs = [];\n      }\n      if (!this.sdfs.includes(sdf)) {\n        this.sdfs.push(sdf);\n      }\n    }\n    removeSdf(sdf) {\n      if (this.sdfs == null) {\n        return;\n      }\n      this.sdfs = this.sdfs.filter((s) => s !== sdf);\n    }\n  };\n  _SplatEdit.nextOrdering = 1;\n  let SplatEdit = _SplatEdit;\n  class SplatEdits {\n    constructor({ maxSdfs, maxEdits }) {\n      this.maxSdfs = Math.max(16, maxSdfs ?? 0);\n      this.numSdfs = 0;\n      this.sdfData = new Uint32Array(this.maxSdfs * 8 * 4);\n      this.sdfFloatData = new Float32Array(this.sdfData.buffer);\n      this.sdfTexture = this.newSdfTexture(this.sdfData, this.maxSdfs);\n      this.dynoSdfArray = new DynoUniform({\n        key: "sdfArray",\n        type: SdfArray,\n        globals: () => [defineSdfArray],\n        value: {\n          numSdfs: 0,\n          sdfTexture: this.sdfTexture\n        },\n        update: (uniform) => {\n          uniform.numSdfs = this.numSdfs;\n          uniform.sdfTexture = this.sdfTexture;\n          return uniform;\n        }\n      });\n      this.maxEdits = Math.max(16, maxEdits ?? 0);\n      this.numEdits = 0;\n      this.editData = new Uint32Array(this.maxEdits * 4);\n      this.editFloatData = new Float32Array(this.editData.buffer);\n      this.dynoNumEdits = new DynoInt({ value: 0 });\n      this.dynoEdits = this.newEdits(this.editData, this.maxEdits);\n    }\n    newSdfTexture(data, maxSdfs) {\n      const texture = new DataTexture(\n        data,\n        8,\n        maxSdfs,\n        RGBAIntegerFormat,\n        UnsignedIntType\n      );\n      texture.internalFormat = "RGBA32UI";\n      texture.needsUpdate = true;\n      return texture;\n    }\n    newEdits(data, maxEdits) {\n      return new DynoUniform({\n        key: "edits",\n        type: "uvec4",\n        count: maxEdits,\n        globals: () => [defineEdit],\n        value: data\n      });\n    }\n    // Ensure our SDF texture and edits uniform array have enough capacity.\n    // Reallocate if not.\n    ensureCapacity({\n      maxSdfs,\n      maxEdits\n    }) {\n      let dynoUpdated = false;\n      if (maxSdfs > this.sdfTexture.image.height) {\n        this.sdfTexture.dispose();\n        this.maxSdfs = Math.max(this.maxSdfs * 2, maxSdfs);\n        this.sdfData = new Uint32Array(this.maxSdfs * 8 * 4);\n        this.sdfFloatData = new Float32Array(this.sdfData.buffer);\n        this.sdfTexture = this.newSdfTexture(this.sdfData, this.maxSdfs);\n      }\n      if (maxEdits > (this.dynoEdits.count ?? 0)) {\n        this.maxEdits = Math.max(this.maxEdits * 2, maxEdits);\n        this.editData = new Uint32Array(this.maxEdits * 4);\n        this.editFloatData = new Float32Array(this.editData.buffer);\n        this.dynoEdits = this.newEdits(this.editData, this.maxEdits);\n        dynoUpdated = true;\n      }\n      return dynoUpdated;\n    }\n    updateEditData(offset, value) {\n      const updated = this.editData[offset] !== value;\n      this.editData[offset] = value;\n      return updated;\n    }\n    updateEditFloatData(offset, value) {\n      tempFloat32[0] = value;\n      const updated = this.editFloatData[offset] !== tempFloat32[0];\n      if (updated) {\n        this.editFloatData[offset] = tempFloat32[0];\n      }\n      return updated;\n    }\n    encodeEdit(editIndex, {\n      sdfFirst,\n      sdfCount,\n      invert,\n      rgbaBlendMode,\n      softEdge,\n      sdfSmooth\n    }) {\n      const base = editIndex * 4;\n      let updated = false;\n      updated = this.updateEditData(base + 0, rgbaBlendMode | (invert ? 1 << 8 : 0)) || updated;\n      updated = this.updateEditData(base + 1, sdfFirst | sdfCount << 16) || updated;\n      updated = this.updateEditFloatData(base + 2, softEdge) || updated;\n      updated = this.updateEditFloatData(base + 3, sdfSmooth) || updated;\n      return updated;\n    }\n    updateSdfData(offset, value) {\n      const updated = this.sdfData[offset] !== value;\n      this.sdfData[offset] = value;\n      return updated;\n    }\n    updateSdfFloatData(offset, value) {\n      tempFloat32[0] = value;\n      const updated = this.sdfFloatData[offset] !== tempFloat32[0];\n      if (updated) {\n        this.sdfFloatData[offset] = tempFloat32[0];\n      }\n      return updated;\n    }\n    encodeSdf(sdfIndex, {\n      sdfType,\n      invert,\n      center,\n      quaternion,\n      scale,\n      sizes\n    }, values) {\n      const base = sdfIndex * (8 * 4);\n      const flags = sdfType | (invert ? 1 << 8 : 0);\n      let updated = false;\n      updated = this.updateSdfFloatData(base + 0, (center == null ? void 0 : center.x) ?? 0) || updated;\n      updated = this.updateSdfFloatData(base + 1, (center == null ? void 0 : center.y) ?? 0) || updated;\n      updated = this.updateSdfFloatData(base + 2, (center == null ? void 0 : center.z) ?? 0) || updated;\n      updated = this.updateSdfData(base + 3, flags) || updated;\n      updated = this.updateSdfFloatData(base + 4, (quaternion == null ? void 0 : quaternion.x) ?? 0) || updated;\n      updated = this.updateSdfFloatData(base + 5, (quaternion == null ? void 0 : quaternion.y) ?? 0) || updated;\n      updated = this.updateSdfFloatData(base + 6, (quaternion == null ? void 0 : quaternion.z) ?? 0) || updated;\n      updated = this.updateSdfFloatData(base + 7, (quaternion == null ? void 0 : quaternion.w) ?? 0) || updated;\n      updated = this.updateSdfFloatData(base + 8, (scale == null ? void 0 : scale.x) ?? 0) || updated;\n      updated = this.updateSdfFloatData(base + 9, (scale == null ? void 0 : scale.y) ?? 0) || updated;\n      updated = this.updateSdfFloatData(base + 10, (scale == null ? void 0 : scale.z) ?? 0) || updated;\n      updated = this.updateSdfData(base + 11, 0) || updated;\n      updated = this.updateSdfFloatData(base + 12, (sizes == null ? void 0 : sizes.x) ?? 0) || updated;\n      updated = this.updateSdfFloatData(base + 13, (sizes == null ? void 0 : sizes.y) ?? 0) || updated;\n      updated = this.updateSdfFloatData(base + 14, (sizes == null ? void 0 : sizes.z) ?? 0) || updated;\n      updated = this.updateSdfFloatData(base + 15, (sizes == null ? void 0 : sizes.w) ?? 0) || updated;\n      const nValues = Math.min(4, values.length);\n      for (let i2 = 0; i2 < nValues; ++i2) {\n        const vBase = base + 16 + i2 * 4;\n        updated = this.updateSdfFloatData(vBase + 0, values[i2].x) || updated;\n        updated = this.updateSdfFloatData(vBase + 1, values[i2].y) || updated;\n        updated = this.updateSdfFloatData(vBase + 2, values[i2].z) || updated;\n        updated = this.updateSdfFloatData(vBase + 3, values[i2].w) || updated;\n      }\n      return updated;\n    }\n    // Update the SDFs and edits from an array of SplatEdits and their\n    // associated SplatEditSdfs, updating it for the dyno shader program.\n    update(edits) {\n      const sdfCount = edits.reduce((total, { sdfs }) => total + sdfs.length, 0);\n      const dynoUpdated = this.ensureCapacity({\n        maxEdits: edits.length,\n        maxSdfs: sdfCount\n      });\n      const values = [new Vector4(), new Vector4()];\n      const center = new Vector3();\n      const quaternion = new Quaternion();\n      const scale = new Vector3();\n      const sizes = new Vector4();\n      let sdfIndex = 0;\n      let updated = dynoUpdated;\n      if (edits.length !== this.dynoNumEdits.value) {\n        this.dynoNumEdits.value = edits.length;\n        this.numEdits = edits.length;\n        updated = true;\n      }\n      for (const [editIndex, { edit, sdfs }] of edits.entries()) {\n        updated = this.encodeEdit(editIndex, {\n          sdfFirst: sdfIndex,\n          sdfCount: sdfs.length,\n          invert: edit.invert,\n          rgbaBlendMode: rgbaBlendModeToNumber(edit.rgbaBlendMode),\n          softEdge: edit.softEdge,\n          sdfSmooth: edit.sdfSmooth\n        }) || updated;\n        let sdfUpdated = false;\n        for (const sdf of sdfs) {\n          sizes.set(sdf.scale.x, sdf.scale.y, sdf.scale.z, sdf.radius);\n          sdf.scale.setScalar(1);\n          sdf.updateMatrixWorld();\n          const worldToSdf = sdf.matrixWorld.clone().invert();\n          worldToSdf.decompose(center, quaternion, scale);\n          sdf.scale.set(sizes.x, sizes.y, sizes.z);\n          sdf.updateMatrixWorld();\n          values[0].set(sdf.color.r, sdf.color.g, sdf.color.b, sdf.opacity);\n          values[1].set(sdf.displace.x, sdf.displace.y, sdf.displace.z, 1);\n          sdfUpdated = this.encodeSdf(\n            sdfIndex,\n            {\n              sdfType: sdfTypeToNumber(sdf.type),\n              invert: sdf.invert,\n              center,\n              quaternion,\n              scale,\n              sizes\n            },\n            values\n          ) || sdfUpdated;\n          sdfIndex += 1;\n        }\n        this.numSdfs = sdfIndex;\n        if (sdfUpdated) {\n          this.sdfTexture.needsUpdate = true;\n        }\n        updated || (updated = sdfUpdated);\n      }\n      return { updated, dynoUpdated };\n    }\n    // Modify a Gsplat in a dyno shader program using the current edits and SDFs.\n    modify(gsplat) {\n      return applyGsplatRgbaDisplaceEdits(\n        gsplat,\n        this.dynoSdfArray,\n        this.dynoNumEdits,\n        this.dynoEdits\n      );\n    }\n  }\n  const SdfArray = { type: "SdfArray" };\n  const defineSdfArray = unindent(`\n  struct SdfArray {\n    int numSdfs;\n    usampler2D sdfTexture;\n  };\n\n  void unpackSdfArray(\n    usampler2D sdfTexture, int sdfIndex, out uint flags,\n    out vec3 center, out vec4 quaternion, out vec3 scale, out vec4 sizes,\n    int numValues, out vec4 values[4]\n  ) {\n    uvec4 temp = texelFetch(sdfTexture, ivec2(0, sdfIndex), 0);\n    flags = temp.w;\n    center = vec3(uintBitsToFloat(temp.x), uintBitsToFloat(temp.y), uintBitsToFloat(temp.z));\n\n    temp = texelFetch(sdfTexture, ivec2(1, sdfIndex), 0);\n    quaternion = vec4(uintBitsToFloat(temp.x), uintBitsToFloat(temp.y), uintBitsToFloat(temp.z), uintBitsToFloat(temp.w));\n\n    temp = texelFetch(sdfTexture, ivec2(2, sdfIndex), 0);\n    scale = vec3(uintBitsToFloat(temp.x), uintBitsToFloat(temp.y), uintBitsToFloat(temp.z));\n\n    temp = texelFetch(sdfTexture, ivec2(3, sdfIndex), 0);\n    sizes = vec4(uintBitsToFloat(temp.x), uintBitsToFloat(temp.y), uintBitsToFloat(temp.z), uintBitsToFloat(temp.w));\n\n    for (int i = 0; i < numValues; ++i) {\n      temp = texelFetch(sdfTexture, ivec2(4 + i, sdfIndex), 0);\n      values[i] = vec4(uintBitsToFloat(temp.x), uintBitsToFloat(temp.y), uintBitsToFloat(temp.z), uintBitsToFloat(temp.w));\n    }\n  }\n\n  const uint SDF_FLAG_TYPE = 0xFFu;\n  const uint SDF_FLAG_INVERT = 1u << 8u;\n\n  const uint SDF_TYPE_ALL = 0u;\n  const uint SDF_TYPE_PLANE = 1u;\n  const uint SDF_TYPE_SPHERE = 2u;\n  const uint SDF_TYPE_BOX = 3u;\n  const uint SDF_TYPE_ELLIPSOID = 4u;\n  const uint SDF_TYPE_CYLINDER = 5u;\n  const uint SDF_TYPE_CAPSULE = 6u;\n  const uint SDF_TYPE_INFINITE_CONE = 7u;\n\n  float evaluateSdfArray(\n    usampler2D sdfTexture, int numSdfs, int sdfFirst, int sdfCount, vec3 pos,\n    float smoothK, int numValues, out vec4 outValues[4]\n  ) {\n    float distanceAccum = (smoothK == 0.0) ? 1.0 / 0.0 : 0.0;\n    float maxExp = -1.0 / 0.0;\n    for (int i = 0; i < numValues; ++i) {\n        outValues[i] = vec4(0.0);\n    }\n\n    uint flags;\n    vec3 center, scale;\n    vec4 quaternion, sizes;\n    vec4 values[4];\n\n    int sdfLast = min(sdfFirst + sdfCount, numSdfs);\n    for (int index = sdfFirst; index < sdfLast; ++index) {\n      unpackSdfArray(sdfTexture, index, flags, center, quaternion, scale, sizes, numValues, values);\n      uint sdfType = flags & SDF_FLAG_TYPE;\n      vec3 sdfPos = quatVec(quaternion, pos * scale) + center;\n\n      float distance;\n      switch (sdfType) {\n        case SDF_TYPE_ALL:\n          distance = -1.0 / 0.0;\n          break;\n        case SDF_TYPE_PLANE: {\n          distance = sdfPos.z;\n          break;\n        }\n        case SDF_TYPE_SPHERE: {\n          distance = length(sdfPos) - sizes.w;\n          break;\n        }\n        case SDF_TYPE_BOX: {\n          vec3 q = abs(sdfPos) - sizes.xyz + sizes.w;\n          distance = length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0) - sizes.w;\n          break;\n        }\n        case SDF_TYPE_ELLIPSOID: {\n          vec3 sizes = sizes.xyz;\n          float k0 = length(sdfPos / sizes);\n          float k1 = length(sdfPos / dot(sizes, sizes));\n          distance = k0 * (k0 - 1.0) / k1;\n          break;\n        }\n        case SDF_TYPE_CYLINDER: {\n          vec2 d = abs(vec2(length(sdfPos.xz), sdfPos.y)) - sizes.wy;\n          distance = min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n          break;\n        }\n        case SDF_TYPE_CAPSULE: {\n          sdfPos.y -= clamp(sdfPos.y, -0.5 * sizes.y, 0.5 * sizes.y);\n          distance = length(sdfPos) - sizes.w;\n          break;\n        }\n        case SDF_TYPE_INFINITE_CONE: {\n          float angle = 0.25 * PI * sizes.w;\n          vec2 c = vec2(sin(angle), cos(angle));\n          vec2 q = vec2(length(sdfPos.xy), -sdfPos.z);\n          float d = length(q - c * max(dot(q, c), 0.0));\n          distance = d * (((q.x * c.y - q.y * c.x) < 0.0) ? -1.0 : 1.0);\n          break;\n        }\n      }\n\n      if ((flags & SDF_FLAG_INVERT) != 0u) {\n        distance = -distance;\n      }\n\n      if (smoothK == 0.0) {\n        if (distance < distanceAccum) {\n          distanceAccum = distance;\n          for (int i = 0; i < numValues; ++i) {\n            outValues[i] = values[i];\n          }\n        }\n      } else {\n        float scaledDistance = -distance / smoothK;\n        if (scaledDistance > maxExp) {\n          float scale = exp(maxExp - scaledDistance);\n          distanceAccum *= scale;\n          for (int i = 0; i < numValues; ++i) {\n            outValues[i] *= scale;\n          }\n          maxExp = scaledDistance;\n        }\n\n        float weight = exp(scaledDistance - maxExp);\n        distanceAccum += weight;\n        for (int i = 0; i < numValues; ++i) {\n          outValues[i] += weight * values[i];\n        }\n      }\n    }\n\n    if (smoothK == 0.0) {\n      return distanceAccum;\n    } else {\n      // Very distant SDFs may result in 0 accumulation\n      if (distanceAccum == 0.0) {\n        return 1.0 / 0.0;\n      }\n      for (int i = 0; i < numValues; ++i) {\n        outValues[i] /= distanceAccum;\n      }\n      return (-log(distanceAccum) - maxExp) * smoothK;\n    }\n  }\n\n  float modulateSdfArray(\n    usampler2D sdfTexture, int numSdfs, int sdfFirst, int sdfCount, vec3 pos,\n    float smoothK, int numValues, out vec4 values[4],\n    float softEdge, bool invert\n  ) {\n    float distance = evaluateSdfArray(sdfTexture, numSdfs, sdfFirst, sdfCount, pos, smoothK, numValues, values);\n    if (invert) {\n      distance = -distance;\n    }\n\n    return (softEdge == 0.0) ? ((distance < 0.0) ? 1.0 : 0.0)\n      : clamp(-distance / softEdge + 0.5, 0.0, 1.0);\n  }\n`);\n  const defineEdit = unindent(`\n  const uint EDIT_FLAG_BLEND = 0xFFu;\n  const uint EDIT_BLEND_MULTIPLY = 0u;\n  const uint EDIT_BLEND_SET_RGB = 1u;\n  const uint EDIT_BLEND_ADD_RGBA = 2u;\n  const uint EDIT_FLAG_INVERT = 0x100u;\n\n  void decodeEdit(\n    uvec4 packedEdit, out int sdfFirst, out int sdfCount,\n    out bool invert, out uint rgbaBlendMode, out float softEdge, out float sdfSmooth\n  ) {\n    rgbaBlendMode = packedEdit.x & EDIT_FLAG_BLEND;\n    invert = (packedEdit.x & EDIT_FLAG_INVERT) != 0u;\n\n    sdfFirst = int(packedEdit.y & 0xFFFFu);\n    sdfCount = int(packedEdit.y >> 16u);\n\n    softEdge = uintBitsToFloat(packedEdit.z);\n    sdfSmooth = uintBitsToFloat(packedEdit.w);\n  }\n\n  void applyRgbaDisplaceEdit(\n    usampler2D sdfTexture, int numSdfs, int sdfFirst, int sdfCount, inout vec3 pos,\n    float smoothK, float softEdge, bool invert, uint rgbaBlendMode, inout vec4 rgba\n  ) {\n    vec4 values[4];\n    float modulate = modulateSdfArray(sdfTexture, numSdfs, sdfFirst, sdfCount, pos, smoothK, 2, values, softEdge, invert);\n    // On Android, moving values[0] is necessary to work around a compiler bug.\n    vec4 sdfRgba = values[0];\n    vec4 sdfDisplaceScale = values[1];\n\n    vec4 target;\n    switch (rgbaBlendMode) {\n      case EDIT_BLEND_MULTIPLY:\n        target = rgba * sdfRgba;\n        break;\n      case EDIT_BLEND_SET_RGB:\n        target = vec4(sdfRgba.rgb, rgba.a * sdfRgba.a);\n        break;\n      case EDIT_BLEND_ADD_RGBA:\n        target = rgba + sdfRgba;\n        break;\n      default:\n        // Debug output if blend mode not set\n        target = vec4(fract(pos), 1.0);\n    }\n    rgba = mix(rgba, target, modulate);\n    pos += sdfDisplaceScale.xyz * modulate;\n  }\n\n  void applyPackedRgbaDisplaceEdit(uvec4 packedEdit, usampler2D sdfTexture, int numSdfs, inout vec3 pos, inout vec4 rgba) {\n    int sdfFirst, sdfCount;\n    bool invert;\n    uint rgbaBlendMode;\n    float softEdge, sdfSmooth;\n    decodeEdit(packedEdit, sdfFirst, sdfCount, invert, rgbaBlendMode, softEdge, sdfSmooth);\n    applyRgbaDisplaceEdit(sdfTexture, numSdfs, sdfFirst, sdfCount, pos, sdfSmooth, softEdge, invert, rgbaBlendMode, rgba);\n  }\n`);\n  function applyGsplatRgbaDisplaceEdits(gsplat, sdfArray, numEdits, rgbaDisplaceEdits) {\n    const dyno2 = new Dyno({\n      inTypes: {\n        gsplat: Gsplat,\n        sdfArray: SdfArray,\n        numEdits: "int",\n        rgbaDisplaceEdits: "uvec4"\n      },\n      outTypes: { gsplat: Gsplat },\n      globals: () => [defineSdfArray, defineEdit],\n      inputs: { gsplat, sdfArray, numEdits, rgbaDisplaceEdits },\n      statements: ({ inputs, outputs }) => {\n        const { sdfArray: sdfArray2, numEdits: numEdits2, rgbaDisplaceEdits: rgbaDisplaceEdits2 } = inputs;\n        const { gsplat: gsplat2 } = outputs;\n        return unindentLines(`\n        ${gsplat2} = ${inputs.gsplat};\n        if (isGsplatActive(${gsplat2}.flags)) {\n          for (int editIndex = 0; editIndex < ${numEdits2}; ++editIndex) {\n            applyPackedRgbaDisplaceEdit(\n              ${rgbaDisplaceEdits2}[editIndex], ${sdfArray2}.sdfTexture, ${sdfArray2}.numSdfs,\n              ${gsplat2}.center, ${gsplat2}.rgba\n            );\n          }\n        }\n      `);\n      }\n    });\n    return dyno2.outputs.gsplat;\n  }\n  const tempFloat32 = new Float32Array(1);\n  class SplatTransformer {\n    // Create the dyno uniforms that parameterize the transform, setting them\n    // to initial values that are different from any valid transform.\n    constructor() {\n      this.scale = new DynoFloat({ value: Number.NEGATIVE_INFINITY });\n      this.rotate = new DynoVec4({\n        value: new Quaternion(\n          Number.POSITIVE_INFINITY,\n          Number.POSITIVE_INFINITY,\n          Number.POSITIVE_INFINITY,\n          Number.POSITIVE_INFINITY\n        )\n      });\n      this.translate = new DynoVec3({\n        value: new Vector3(\n          Number.POSITIVE_INFINITY,\n          Number.POSITIVE_INFINITY,\n          Number.POSITIVE_INFINITY\n        )\n      });\n    }\n    // Apply the transform to a Vec3 position in a dyno program.\n    apply(position) {\n      return transformPos(position, {\n        scale: this.scale,\n        rotate: this.rotate,\n        translate: this.translate\n      });\n    }\n    applyDir(dir) {\n      return transformDir(dir, {\n        rotate: this.rotate\n      });\n    }\n    // Apply the transform to a Gsplat in a dyno program.\n    applyGsplat(gsplat) {\n      return transformGsplat(gsplat, {\n        scale: this.scale,\n        rotate: this.rotate,\n        translate: this.translate\n      });\n    }\n    // Update the uniforms to match the given transform matrix.\n    updateFromMatrix(transform) {\n      const scale = new Vector3();\n      const quaternion = new Quaternion();\n      const position = new Vector3();\n      transform.decompose(position, quaternion, scale);\n      const newScale = (scale.x + scale.y + scale.z) / 3;\n      let updated = false;\n      if (newScale !== this.scale.value) {\n        this.scale.value = newScale;\n        updated = true;\n      }\n      if (!position.equals(this.translate.value)) {\n        this.translate.value.copy(position);\n        updated = true;\n      }\n      if (!quaternion.equals(this.rotate.value)) {\n        this.rotate.value.copy(quaternion);\n        updated = true;\n      }\n      return updated;\n    }\n    // Update this transform to match the object\'s to-world transform.\n    update(object) {\n      object.updateMatrixWorld();\n      return this.updateFromMatrix(object.matrixWorld);\n    }\n  }\n  class SplatGenerator extends Object3D {\n    constructor({\n      numSplats,\n      generator,\n      construct,\n      update\n    }) {\n      super();\n      this.numSplats = numSplats ?? 0;\n      this.generator = generator;\n      this.frameUpdate = update;\n      this.version = 0;\n      if (construct) {\n        const constructed = construct(this);\n        Object.assign(this, constructed);\n      }\n    }\n    updateVersion() {\n      this.version += 1;\n    }\n    set needsUpdate(value) {\n      if (value) {\n        this.updateVersion();\n      }\n    }\n  }\n  const _SplatMesh = class _SplatMesh extends SplatGenerator {\n    constructor(options = {}) {\n      const transform = new SplatTransformer();\n      const viewToWorld = new SplatTransformer();\n      const worldToView = new SplatTransformer();\n      const viewToObject = new SplatTransformer();\n      const recolor = new DynoVec4({\n        value: new Vector4(\n          Number.NEGATIVE_INFINITY,\n          Number.NEGATIVE_INFINITY,\n          Number.NEGATIVE_INFINITY,\n          Number.NEGATIVE_INFINITY\n        )\n      });\n      const time = new DynoFloat({ value: 0 });\n      const deltaTime = new DynoFloat({ value: 0 });\n      const context = {\n        transform,\n        viewToWorld,\n        worldToView,\n        viewToObject,\n        recolor,\n        time,\n        deltaTime\n      };\n      super({\n        update: ({ time: time2, deltaTime: deltaTime2, viewToWorld: viewToWorld2, globalEdits }) => this.update({ time: time2, deltaTime: deltaTime2, viewToWorld: viewToWorld2, globalEdits })\n      });\n      this.isInitialized = false;\n      this.recolor = new Color(1, 1, 1);\n      this.opacity = 1;\n      this.enableViewToObject = false;\n      this.enableViewToWorld = false;\n      this.enableWorldToView = false;\n      this.skinning = null;\n      this.edits = null;\n      this.rgbaDisplaceEdits = null;\n      this.splatRgba = null;\n      this.maxSh = 3;\n      this.packedSplats = options.packedSplats ?? new PackedSplats();\n      this.numSplats = this.packedSplats.numSplats;\n      this.editable = options.editable ?? true;\n      this.onFrame = options.onFrame;\n      this.context = context;\n      this.objectModifier = options.objectModifier;\n      this.worldModifier = options.worldModifier;\n      this.updateGenerator();\n      if (options.url || options.fileBytes || options.constructSplats || options.packedSplats && !options.packedSplats.isInitialized) {\n        this.initialized = this.asyncInitialize(options).then(async () => {\n          this.updateGenerator();\n          this.isInitialized = true;\n          if (options.onLoad) {\n            const maybePromise = options.onLoad(this);\n            if (maybePromise instanceof Promise) {\n              await maybePromise;\n            }\n          }\n          return this;\n        });\n      } else {\n        this.isInitialized = true;\n        this.initialized = Promise.resolve(this);\n        if (options.onLoad) {\n          const maybePromise = options.onLoad(this);\n          if (maybePromise instanceof Promise) {\n            this.initialized = maybePromise.then(() => this);\n          }\n        }\n      }\n    }\n    async asyncInitialize(options) {\n      const { url, fileBytes, fileType, fileName, maxSplats, constructSplats } = options;\n      if (url || fileBytes || constructSplats) {\n        const packedSplatsOptions = {\n          url,\n          fileBytes,\n          fileType,\n          fileName,\n          maxSplats,\n          construct: constructSplats\n        };\n        this.packedSplats.reinitialize(packedSplatsOptions);\n      }\n      if (this.packedSplats) {\n        await this.packedSplats.initialized;\n        this.numSplats = this.packedSplats.numSplats;\n        this.updateGenerator();\n      }\n    }\n    static async staticInitialize() {\n      await __wbg_init();\n      _SplatMesh.isStaticInitialized = true;\n    }\n    // Creates a new Gsplat with the provided parameters (all values in "float" space,\n    // i.e. 0-1 for opacity and color) and adds it to the end of the packedSplats,\n    // increasing numSplats by 1. If necessary, reallocates the buffer with an exponential\n    // doubling strategy to fit the new data, so it\'s fairly efficient to just\n    // pushSplat(...) each Gsplat you want to create in a loop.\n    pushSplat(center, scales, quaternion, opacity, color) {\n      this.packedSplats.pushSplat(center, scales, quaternion, opacity, color);\n    }\n    // This method iterates over all Gsplats in this instance\'s packedSplats,\n    // invoking the provided callback with index: number in 0..=(this.numSplats-1) and\n    // center: THREE.Vector3, scales: THREE.Vector3, quaternion: THREE.Quaternion,\n    // opacity: number (0..1), and color: THREE.Color (rgb values in 0..1).\n    // Note that the objects passed in as center etc. are the same for every callback\n    // invocation: these objects are reused for efficiency. Changing these values has\n    // no effect as they are decoded/unpacked copies of the underlying data. To update\n    // the packedSplats, call .packedSplats.setSplat(index, center, scales,\n    // quaternion, opacity, color).\n    forEachSplat(callback) {\n      this.packedSplats.forEachSplat(callback);\n    }\n    // Call this when you are finished with the SplatMesh and want to free\n    // any buffers it holds (via packedSplats).\n    dispose() {\n      this.packedSplats.dispose();\n    }\n    constructGenerator(context) {\n      const { transform, viewToObject, recolor } = context;\n      const generator = dynoBlock(\n        { index: "int" },\n        { gsplat: Gsplat },\n        ({ index }) => {\n          if (!index) {\n            throw new Error("index is undefined");\n          }\n          let gsplat = readPackedSplat(this.packedSplats.dyno, index);\n          if (this.maxSh >= 1) {\n            const { sh1Texture, sh2Texture, sh3Texture } = this.ensureShTextures();\n            if (sh1Texture) {\n              const viewCenterInObject = viewToObject.translate;\n              const { center } = splitGsplat(gsplat).outputs;\n              const viewDir = normalize(sub(center, viewCenterInObject));\n              let rgb = evaluateSH1(gsplat, sh1Texture, viewDir);\n              if (this.maxSh >= 2 && sh2Texture) {\n                rgb = add(rgb, evaluateSH2(gsplat, sh2Texture, viewDir));\n              }\n              if (this.maxSh >= 3 && sh3Texture) {\n                rgb = add(rgb, evaluateSH3(gsplat, sh3Texture, viewDir));\n              }\n              let { rgba } = splitGsplat(gsplat).outputs;\n              rgba = add(rgba, extendVec(rgb, dynoConst("float", 0)));\n              gsplat = combineGsplat({ gsplat, rgba });\n            }\n          }\n          if (this.splatRgba) {\n            const rgba = readRgbaArray(this.splatRgba.dyno, index);\n            gsplat = combineGsplat({ gsplat, rgba });\n          }\n          if (this.skinning) {\n            gsplat = this.skinning.modify(gsplat);\n          }\n          if (this.objectModifier) {\n            gsplat = this.objectModifier.apply({ gsplat }).gsplat;\n          }\n          gsplat = transform.applyGsplat(gsplat);\n          const recolorRgba = mul(recolor, splitGsplat(gsplat).outputs.rgba);\n          gsplat = combineGsplat({ gsplat, rgba: recolorRgba });\n          if (this.rgbaDisplaceEdits) {\n            gsplat = this.rgbaDisplaceEdits.modify(gsplat);\n          }\n          if (this.worldModifier) {\n            gsplat = this.worldModifier.apply({ gsplat }).gsplat;\n          }\n          return { gsplat };\n        }\n      );\n      this.generator = generator;\n    }\n    // Call this whenever something changes in the Gsplat processing pipeline,\n    // for example changing maxSh or updating objectModifier or worldModifier.\n    // Compiled generators are cached for efficiency and re-use when the same\n    // pipeline structure emerges after successive changes.\n    updateGenerator() {\n      this.constructGenerator(this.context);\n    }\n    // This is called automatically by SparkRenderer and you should not have to\n    // call it. It updates parameters for the generated pipeline and calls\n    // updateGenerator() if the pipeline needs to change.\n    update({\n      time,\n      viewToWorld,\n      deltaTime,\n      globalEdits\n    }) {\n      var _a2;\n      this.numSplats = this.packedSplats.numSplats;\n      this.context.time.value = time;\n      this.context.deltaTime.value = deltaTime;\n      _SplatMesh.dynoTime.value = time;\n      const { transform, viewToObject, recolor } = this.context;\n      let updated = transform.update(this);\n      if (this.context.viewToWorld.updateFromMatrix(viewToWorld) && this.enableViewToWorld) {\n        updated = true;\n      }\n      const worldToView = viewToWorld.clone().invert();\n      if (this.context.worldToView.updateFromMatrix(worldToView) && this.enableWorldToView) {\n        updated = true;\n      }\n      const objectToWorld = new Matrix4().compose(\n        transform.translate.value,\n        transform.rotate.value,\n        new Vector3().setScalar(transform.scale.value)\n      );\n      const worldToObject = objectToWorld.invert();\n      const viewToObjectMatrix = worldToObject.multiply(viewToWorld);\n      if (viewToObject.updateFromMatrix(viewToObjectMatrix) && (this.enableViewToObject || this.packedSplats.extra.sh1)) {\n        updated = true;\n      }\n      const newRecolor = new Vector4(\n        this.recolor.r,\n        this.recolor.g,\n        this.recolor.b,\n        this.opacity\n      );\n      if (!newRecolor.equals(recolor.value)) {\n        recolor.value.copy(newRecolor);\n        updated = true;\n      }\n      const edits = this.editable ? (this.edits ?? []).concat(globalEdits) : [];\n      if (this.editable && !this.edits) {\n        this.traverseVisible((node) => {\n          if (node instanceof SplatEdit) {\n            edits.push(node);\n          }\n        });\n      }\n      edits.sort((a, b) => a.ordering - b.ordering);\n      const editsSdfs = edits.map((edit) => {\n        if (edit.sdfs != null) {\n          return { edit, sdfs: edit.sdfs };\n        }\n        const sdfs = [];\n        edit.traverseVisible((node) => {\n          if (node instanceof SplatEditSdf) {\n            sdfs.push(node);\n          }\n        });\n        return { edit, sdfs };\n      });\n      if (editsSdfs.length > 0 && !this.rgbaDisplaceEdits) {\n        const edits2 = editsSdfs.length;\n        const sdfs = editsSdfs.reduce(\n          (total, edit) => total + edit.sdfs.length,\n          0\n        );\n        this.rgbaDisplaceEdits = new SplatEdits({\n          maxEdits: edits2,\n          maxSdfs: sdfs\n        });\n        this.updateGenerator();\n      }\n      if (this.rgbaDisplaceEdits) {\n        const editResult = this.rgbaDisplaceEdits.update(editsSdfs);\n        updated || (updated = editResult.updated);\n        if (editResult.dynoUpdated) {\n          this.updateGenerator();\n        }\n      }\n      if (updated) {\n        this.updateVersion();\n      }\n      (_a2 = this.onFrame) == null ? void 0 : _a2.call(this, { mesh: this, time, deltaTime });\n    }\n    // This method conforms to the standard THREE.Raycaster API, performing object-ray\n    // intersections using this method to populate the provided intersects[] array\n    // with each intersection point.\n    raycast(raycaster, intersects) {\n      if (!this.packedSplats.packedArray || !this.packedSplats.numSplats) {\n        return;\n      }\n      const { near, far, ray } = raycaster;\n      const worldToMesh = this.matrixWorld.clone().invert();\n      const worldToMeshRot = new Matrix3().setFromMatrix4(worldToMesh);\n      const origin = ray.origin.clone().applyMatrix4(worldToMesh);\n      const direction = ray.direction.clone().applyMatrix3(worldToMeshRot);\n      const scales = new Vector3();\n      worldToMesh.decompose(new Vector3(), new Quaternion(), scales);\n      (scales.x * scales.y * scales.z) ** (1 / 3);\n      const RAYCAST_ELLIPSOID = true;\n      const distances = raycast_splats(\n        origin.x,\n        origin.y,\n        origin.z,\n        direction.x,\n        direction.y,\n        direction.z,\n        near,\n        far,\n        this.packedSplats.numSplats,\n        this.packedSplats.packedArray,\n        RAYCAST_ELLIPSOID\n      );\n      for (const distance of distances) {\n        const point = ray.direction.clone().multiplyScalar(distance).add(ray.origin);\n        intersects.push({\n          distance,\n          point,\n          object: this\n        });\n      }\n    }\n    ensureShTextures() {\n      if (!this.packedSplats.extra.sh1) {\n        return {};\n      }\n      let sh1Texture = this.packedSplats.extra.sh1Texture;\n      if (!sh1Texture) {\n        let sh1 = this.packedSplats.extra.sh1;\n        const { width, height, depth, maxSplats } = getTextureSize(\n          sh1.length / 2\n        );\n        if (sh1.length < maxSplats * 2) {\n          const newSh1 = new Uint32Array(maxSplats * 2);\n          newSh1.set(sh1);\n          this.packedSplats.extra.sh1 = newSh1;\n          sh1 = newSh1;\n        }\n        const texture = new DataArrayTexture(sh1, width, height, depth);\n        texture.format = RGIntegerFormat;\n        texture.type = UnsignedIntType;\n        texture.internalFormat = "RG32UI";\n        texture.needsUpdate = true;\n        sh1Texture = new DynoUsampler2DArray({\n          value: texture,\n          key: "sh1"\n        });\n        this.packedSplats.extra.sh1Texture = sh1Texture;\n      }\n      if (!this.packedSplats.extra.sh2) {\n        return { sh1Texture };\n      }\n      let sh2Texture = this.packedSplats.extra.sh2Texture;\n      if (!sh2Texture) {\n        let sh2 = this.packedSplats.extra.sh2;\n        const { width, height, depth, maxSplats } = getTextureSize(\n          sh2.length / 4\n        );\n        if (sh2.length < maxSplats * 4) {\n          const newSh2 = new Uint32Array(maxSplats * 4);\n          newSh2.set(sh2);\n          this.packedSplats.extra.sh2 = newSh2;\n          sh2 = newSh2;\n        }\n        const texture = new DataArrayTexture(sh2, width, height, depth);\n        texture.format = RGBAIntegerFormat;\n        texture.type = UnsignedIntType;\n        texture.internalFormat = "RGBA32UI";\n        texture.needsUpdate = true;\n        sh2Texture = new DynoUsampler2DArray({\n          value: texture,\n          key: "sh2"\n        });\n        this.packedSplats.extra.sh2Texture = sh2Texture;\n      }\n      if (!this.packedSplats.extra.sh3) {\n        return { sh1Texture, sh2Texture };\n      }\n      let sh3Texture = this.packedSplats.extra.sh3Texture;\n      if (!sh3Texture) {\n        let sh3 = this.packedSplats.extra.sh3;\n        const { width, height, depth, maxSplats } = getTextureSize(\n          sh3.length / 4\n        );\n        if (sh3.length < maxSplats * 4) {\n          const newSh3 = new Uint32Array(maxSplats * 4);\n          newSh3.set(sh3);\n          this.packedSplats.extra.sh3 = newSh3;\n          sh3 = newSh3;\n        }\n        const texture = new DataArrayTexture(sh3, width, height, depth);\n        texture.format = RGBAIntegerFormat;\n        texture.type = UnsignedIntType;\n        texture.internalFormat = "RGBA32UI";\n        texture.needsUpdate = true;\n        sh3Texture = new DynoUsampler2DArray({\n          value: texture,\n          key: "sh3"\n        });\n        this.packedSplats.extra.sh3Texture = sh3Texture;\n      }\n      return { sh1Texture, sh2Texture, sh3Texture };\n    }\n  };\n  _SplatMesh.staticInitialized = _SplatMesh.staticInitialize();\n  _SplatMesh.isStaticInitialized = false;\n  _SplatMesh.dynoTime = new DynoFloat({ value: 0 });\n  let SplatMesh = _SplatMesh;\n  const defineEvaluateSH1 = unindent(`\n  vec3 evaluateSH1(Gsplat gsplat, usampler2DArray sh1, vec3 viewDir) {\n    // Extract sint7 values packed into 2 x uint32\n    uvec2 packed = texelFetch(sh1, splatTexCoord(gsplat.index), 0).rg;\n    vec3 sh1_0 = vec3(ivec3(\n      int(packed.x << 25u) >> 25,\n      int(packed.x << 18u) >> 25,\n      int(packed.x << 11u) >> 25\n    )) / 63.0;\n    vec3 sh1_1 = vec3(ivec3(\n      int(packed.x << 4u) >> 25,\n      int((packed.x >> 3u) | (packed.y << 29u)) >> 25,\n      int(packed.y << 22u) >> 25\n    )) / 63.0;\n    vec3 sh1_2 = vec3(ivec3(\n      int(packed.y << 15u) >> 25,\n      int(packed.y << 8u) >> 25,\n      int(packed.y << 1u) >> 25\n    )) / 63.0;\n\n    return sh1_0 * (-0.4886025 * viewDir.y)\n      + sh1_1 * (0.4886025 * viewDir.z)\n      + sh1_2 * (-0.4886025 * viewDir.x);\n  }\n`);\n  const defineEvaluateSH2 = unindent(`\n  vec3 evaluateSH2(Gsplat gsplat, usampler2DArray sh2, vec3 viewDir) {\n    // Extract sint8 values packed into 4 x uint32\n    uvec4 packed = texelFetch(sh2, splatTexCoord(gsplat.index), 0);\n    vec3 sh2_0 = vec3(ivec3(\n      int(packed.x << 24u) >> 24,\n      int(packed.x << 16u) >> 24,\n      int(packed.x << 8u) >> 24\n    )) / 127.0;\n    vec3 sh2_1 = vec3(ivec3(\n      int(packed.x) >> 24,\n      int(packed.y << 24u) >> 24,\n      int(packed.y << 16u) >> 24\n    )) / 127.0;\n    vec3 sh2_2 = vec3(ivec3(\n      int(packed.y << 8u) >> 24,\n      int(packed.y) >> 24,\n      int(packed.z << 24u) >> 24\n    )) / 127.0;\n    vec3 sh2_3 = vec3(ivec3(\n      int(packed.z << 16u) >> 24,\n      int(packed.z << 8u) >> 24,\n      int(packed.z) >> 24\n    )) / 127.0;\n    vec3 sh2_4 = vec3(ivec3(\n      int(packed.w << 24u) >> 24,\n      int(packed.w << 16u) >> 24,\n      int(packed.w << 8u) >> 24\n    )) / 127.0;\n\n    return sh2_0 * (1.0925484 * viewDir.x * viewDir.y)\n      + sh2_1 * (-1.0925484 * viewDir.y * viewDir.z)\n      + sh2_2 * (0.3153915 * (2.0 * viewDir.z * viewDir.z - viewDir.x * viewDir.x - viewDir.y * viewDir.y))\n      + sh2_3 * (-1.0925484 * viewDir.x * viewDir.z)\n      + sh2_4 * (0.5462742 * (viewDir.x * viewDir.x - viewDir.y * viewDir.y));\n  }\n`);\n  const defineEvaluateSH3 = unindent(`\n  vec3 evaluateSH3(Gsplat gsplat, usampler2DArray sh3, vec3 viewDir) {\n    // Extract sint6 values packed into 4 x uint32\n    uvec4 packed = texelFetch(sh3, splatTexCoord(gsplat.index), 0);\n    vec3 sh3_0 = vec3(ivec3(\n      int(packed.x << 26u) >> 26,\n      int(packed.x << 20u) >> 26,\n      int(packed.x << 14u) >> 26\n    )) / 31.0;\n    vec3 sh3_1 = vec3(ivec3(\n      int(packed.x << 8u) >> 26,\n      int(packed.x << 2u) >> 26,\n      int((packed.x >> 4u) | (packed.y << 28u)) >> 26\n    )) / 31.0;\n    vec3 sh3_2 = vec3(ivec3(\n      int(packed.y << 22u) >> 26,\n      int(packed.y << 16u) >> 26,\n      int(packed.y << 10u) >> 26\n    )) / 31.0;\n    vec3 sh3_3 = vec3(ivec3(\n      int(packed.y << 4u) >> 26,\n      int((packed.y >> 2u) | (packed.z << 30u)) >> 26,\n      int(packed.z << 24u) >> 26\n    )) / 31.0;\n    vec3 sh3_4 = vec3(ivec3(\n      int(packed.z << 18u) >> 26,\n      int(packed.z << 12u) >> 26,\n      int(packed.z << 6u) >> 26\n    )) / 31.0;\n    vec3 sh3_5 = vec3(ivec3(\n      int(packed.z) >> 26,\n      int(packed.w << 26u) >> 26,\n      int(packed.w << 20u) >> 26\n    )) / 31.0;\n    vec3 sh3_6 = vec3(ivec3(\n      int(packed.w << 14u) >> 26,\n      int(packed.w << 8u) >> 26,\n      int(packed.w << 2u) >> 26\n    )) / 31.0;\n\n    float xx = viewDir.x * viewDir.x;\n    float yy = viewDir.y * viewDir.y;\n    float zz = viewDir.z * viewDir.z;\n    float xy = viewDir.x * viewDir.y;\n    float yz = viewDir.y * viewDir.z;\n    float zx = viewDir.z * viewDir.x;\n\n    return sh3_0 * (-0.5900436 * viewDir.y * (3.0 * xx - yy))\n      + sh3_1 * (2.8906114 * xy * viewDir.z) +\n      + sh3_2 * (-0.4570458 * viewDir.y * (4.0 * zz - xx - yy))\n      + sh3_3 * (0.3731763 * viewDir.z * (2.0 * zz - 3.0 * xx - 3.0 * yy))\n      + sh3_4 * (-0.4570458 * viewDir.x * (4.0 * zz - xx - yy))\n      + sh3_5 * (1.4453057 * viewDir.z * (xx - yy))\n      + sh3_6 * (-0.5900436 * viewDir.x * (xx - 3.0 * yy));\n  }\n`);\n  function evaluateSH1(gsplat, sh1, viewDir) {\n    return dyno({\n      inTypes: { gsplat: Gsplat, sh1: "usampler2DArray", viewDir: "vec3" },\n      outTypes: { rgb: "vec3" },\n      inputs: { gsplat, sh1, viewDir },\n      globals: () => [defineGsplat, defineEvaluateSH1],\n      statements: ({ inputs, outputs }) => {\n        const statements = unindentLines(`\n        if (isGsplatActive(${inputs.gsplat}.flags)) {\n          ${outputs.rgb} = evaluateSH1(${inputs.gsplat}, ${inputs.sh1}, ${inputs.viewDir});\n        } else {\n          ${outputs.rgb} = vec3(0.0);\n        }\n      `);\n        return statements;\n      }\n    }).outputs.rgb;\n  }\n  function evaluateSH2(gsplat, sh2, viewDir) {\n    return dyno({\n      inTypes: { gsplat: Gsplat, sh2: "usampler2DArray", viewDir: "vec3" },\n      outTypes: { rgb: "vec3" },\n      inputs: { gsplat, sh2, viewDir },\n      globals: () => [defineGsplat, defineEvaluateSH2],\n      statements: ({ inputs, outputs }) => unindentLines(`\n        if (isGsplatActive(${inputs.gsplat}.flags)) {\n          ${outputs.rgb} = evaluateSH2(${inputs.gsplat}, ${inputs.sh2}, ${inputs.viewDir});\n        } else {\n          ${outputs.rgb} = vec3(0.0);\n        }\n      `)\n    }).outputs.rgb;\n  }\n  function evaluateSH3(gsplat, sh3, viewDir) {\n    return dyno({\n      inTypes: { gsplat: Gsplat, sh3: "usampler2DArray", viewDir: "vec3" },\n      outTypes: { rgb: "vec3" },\n      inputs: { gsplat, sh3, viewDir },\n      globals: () => [defineGsplat, defineEvaluateSH3],\n      statements: ({ inputs, outputs }) => unindentLines(`\n        if (isGsplatActive(${inputs.gsplat}.flags)) {\n          ${outputs.rgb} = evaluateSH3(${inputs.gsplat}, ${inputs.sh3}, ${inputs.viewDir});\n        } else {\n          ${outputs.rgb} = vec3(0.0);\n        }\n      `)\n    }).outputs.rgb;\n  }\n  function WorkerWrapper(options) {\n    return new Worker(\n      self.location.href,\n      {\n        name: options == null ? void 0 : options.name\n      }\n    );\n  }\n  class SplatWorker {\n    constructor() {\n      this.messages = {};\n      this.messageIdNext = 0;\n      this.worker = new WorkerWrapper();\n      this.worker.onmessage = (event) => this.onMessage(event);\n    }\n    makeMessageId() {\n      return ++this.messageIdNext;\n    }\n    makeMessagePromiseId() {\n      const id = this.makeMessageId();\n      const promise = new Promise((resolve, reject) => {\n        this.messages[id] = { resolve, reject };\n      });\n      return { id, promise };\n    }\n    onMessage(event) {\n      const { id, result, error } = event.data;\n      const handler = this.messages[id];\n      if (handler) {\n        delete this.messages[id];\n        if (error) {\n          handler.reject(error);\n        } else {\n          handler.resolve(result);\n        }\n      }\n    }\n    // Invoke an RPC on the worker with the given name and arguments.\n    // The normal usage of a worker is to run one activity at a time,\n    // but this function allows for concurrent calls, tagging each request\n    // with a unique message Id and awaiting a response to that same Id.\n    // The method will automatically transfer any ArrayBuffers in the\n    // arguments to the worker. If you\'d like to transfer a copy of a\n    // buffer then you must clone it before passing to this function.\n    async call(name, args) {\n      const { id, promise } = this.makeMessagePromiseId();\n      this.worker.postMessage(\n        { name, args, id },\n        { transfer: getArrayBuffers(args) }\n      );\n      return promise;\n    }\n  }\n  let maxWorkers = 4;\n  let numWorkers = 0;\n  const freeWorkers = [];\n  const workerQueue = [];\n  async function allocWorker() {\n    const worker = freeWorkers.shift();\n    if (worker) {\n      return worker;\n    }\n    if (numWorkers < maxWorkers) {\n      const worker2 = new SplatWorker();\n      numWorkers += 1;\n      return worker2;\n    }\n    return new Promise((resolve) => {\n      workerQueue.push(resolve);\n    });\n  }\n  function freeWorker(worker) {\n    if (numWorkers > maxWorkers) {\n      numWorkers -= 1;\n      return;\n    }\n    const waiter = workerQueue.shift();\n    if (waiter) {\n      waiter(worker);\n      return;\n    }\n    freeWorkers.push(worker);\n  }\n  async function withWorker(callback) {\n    const worker = await allocWorker();\n    try {\n      return await callback(worker);\n    } finally {\n      freeWorker(worker);\n    }\n  }\n  class SplatLoader extends Loader {\n    constructor(manager) {\n      super(manager);\n      this.fileLoader = new FileLoader(manager);\n    }\n    load(url, onLoad, onProgress, onError) {\n      this.fileLoader.setResponseType("arraybuffer");\n      this.fileLoader.setCrossOrigin(this.crossOrigin);\n      this.fileLoader.setWithCredentials(this.withCredentials);\n      this.fileLoader.setPath(this.path);\n      this.fileLoader.setResourcePath(this.resourcePath);\n      this.fileLoader.setRequestHeader(this.requestHeader);\n      this.fileLoader.load(\n        url,\n        async (response) => {\n          if (onLoad) {\n            const input = response;\n            const extraFiles = {};\n            const promises = [];\n            let fileType = this.fileType;\n            try {\n              const pcSogsJson = tryPcSogs(input);\n              if (this.fileType === "pcsogs") {\n                if (pcSogsJson === void 0) {\n                  throw new Error("Invalid PC SOGS file");\n                }\n              }\n              if (pcSogsJson !== void 0) {\n                fileType = "pcsogs";\n                for (const key of ["means", "scales", "quats", "sh0", "shN"]) {\n                  const prop = pcSogsJson[key];\n                  if (prop) {\n                    const files = prop.files;\n                    for (const file of files) {\n                      const fileUrl = new URL(file, url).toString();\n                      this.manager.itemStart(fileUrl);\n                      const promise = this.loadExtra(fileUrl).then((data) => {\n                        extraFiles[file] = data;\n                      }).catch((error) => {\n                        this.manager.itemError(fileUrl);\n                        throw error;\n                      }).finally(() => {\n                        this.manager.itemEnd(fileUrl);\n                      });\n                      promises.push(promise);\n                    }\n                  }\n                }\n              }\n              await Promise.all(promises);\n              const decoded = await unpackSplats({\n                input,\n                extraFiles,\n                fileType,\n                pathOrUrl: url\n              });\n              if (this.packedSplats) {\n                this.packedSplats.initialize(decoded);\n                onLoad(this.packedSplats);\n              } else {\n                onLoad(new PackedSplats(decoded));\n              }\n            } catch (error) {\n              onError == null ? void 0 : onError(error);\n            }\n          }\n        },\n        onProgress,\n        onError\n      );\n    }\n    async loadAsync(url, onProgress) {\n      return new Promise((resolve, reject) => {\n        this.load(\n          url,\n          (decoded) => {\n            resolve(decoded);\n          },\n          onProgress,\n          reject\n        );\n      });\n    }\n    async loadExtra(url) {\n      return new Promise((resolve, reject) => {\n        this.fileLoader.load(\n          url,\n          (response) => resolve(response),\n          void 0,\n          (error) => reject(error)\n        );\n      });\n    }\n    parse(packedSplats) {\n      return new SplatMesh({ packedSplats });\n    }\n  }\n  var SplatFileType = /* @__PURE__ */ ((SplatFileType2) => {\n    SplatFileType2["PLY"] = "ply";\n    SplatFileType2["SPZ"] = "spz";\n    SplatFileType2["SPLAT"] = "splat";\n    SplatFileType2["KSPLAT"] = "ksplat";\n    SplatFileType2["PCSOGS"] = "pcsogs";\n    return SplatFileType2;\n  })(SplatFileType || {});\n  function getSplatFileType(fileBytes) {\n    const view = new DataView(fileBytes.buffer);\n    if ((view.getUint32(0, true) & 16777215) === 7957616) {\n      return "ply";\n    }\n    if ((view.getUint32(0, true) & 16777215) === 559903) {\n      const header = decompressPartialGzip(fileBytes, 4);\n      const gView = new DataView(header.buffer);\n      if (gView.getUint32(0, true) === 1347635022) {\n        return "spz";\n      }\n      return void 0;\n    }\n    return void 0;\n  }\n  function getFileExtension(pathOrUrl) {\n    const noTrailing = pathOrUrl.split(/[?#]/, 1)[0];\n    const lastSlash = Math.max(\n      noTrailing.lastIndexOf("/"),\n      noTrailing.lastIndexOf("\\\\")\n    );\n    const filename = noTrailing.slice(lastSlash + 1);\n    const lastDot = filename.lastIndexOf(".");\n    if (lastDot <= 0 || lastDot === filename.length - 1) {\n      return "";\n    }\n    return filename.slice(lastDot + 1).toLowerCase();\n  }\n  function getSplatFileTypeFromPath(pathOrUrl) {\n    const extension = getFileExtension(pathOrUrl);\n    if (extension === "ply") {\n      return "ply";\n    }\n    if (extension === "spz") {\n      return "spz";\n    }\n    if (extension === "splat") {\n      return "splat";\n    }\n    if (extension === "ksplat") {\n      return "ksplat";\n    }\n    return void 0;\n  }\n  function tryPcSogs(input) {\n    try {\n      let text;\n      if (typeof input === "string") {\n        text = input;\n      } else {\n        const fileBytes = input instanceof ArrayBuffer ? new Uint8Array(input) : input;\n        if (fileBytes.length > 65536) {\n          return void 0;\n        }\n        text = new TextDecoder().decode(fileBytes);\n      }\n      const json = JSON.parse(text);\n      if (!json || typeof json !== "object" || Array.isArray(json)) {\n        return void 0;\n      }\n      for (const key of ["means", "scales", "quats", "sh0"]) {\n        if (!json[key] || typeof json[key] !== "object" || Array.isArray(json[key])) {\n          return void 0;\n        }\n        if (!json[key].shape || !json[key].files) {\n          return void 0;\n        }\n        if (key !== "quats" && (!json[key].mins || !json[key].maxs)) {\n          return void 0;\n        }\n      }\n      return json;\n    } catch {\n      return void 0;\n    }\n  }\n  async function unpackSplats({\n    input,\n    extraFiles,\n    fileType,\n    pathOrUrl\n  }) {\n    const fileBytes = input instanceof ArrayBuffer ? new Uint8Array(input) : input;\n    let splatFileType = fileType;\n    if (!fileType) {\n      splatFileType = getSplatFileType(fileBytes);\n      if (!splatFileType && pathOrUrl) {\n        splatFileType = getSplatFileTypeFromPath(pathOrUrl);\n      }\n    }\n    switch (splatFileType) {\n      case "ply": {\n        const ply = new PlyReader({ fileBytes });\n        await ply.parseHeader();\n        const numSplats = ply.numSplats;\n        const maxSplats = getTextureSize(numSplats).maxSplats;\n        const args = { fileBytes, packedArray: new Uint32Array(maxSplats * 4) };\n        return await withWorker(async (worker) => {\n          const { packedArray, numSplats: numSplats2, extra } = await worker.call(\n            "unpackPly",\n            args\n          );\n          return { packedArray, numSplats: numSplats2, extra };\n        });\n      }\n      case "spz": {\n        return await withWorker(async (worker) => {\n          const { packedArray, numSplats, extra } = await worker.call(\n            "decodeSpz",\n            {\n              fileBytes\n            }\n          );\n          return { packedArray, numSplats, extra };\n        });\n      }\n      case "splat": {\n        return await withWorker(async (worker) => {\n          const { packedArray, numSplats } = await worker.call(\n            "decodeAntiSplat",\n            {\n              fileBytes\n            }\n          );\n          return { packedArray, numSplats };\n        });\n      }\n      case "ksplat": {\n        return await withWorker(async (worker) => {\n          const { packedArray, numSplats, extra } = await worker.call(\n            "decodeKsplat",\n            { fileBytes }\n          );\n          return { packedArray, numSplats, extra };\n        });\n      }\n      case "pcsogs": {\n        return await withWorker(async (worker) => {\n          const { packedArray, numSplats, extra } = await worker.call(\n            "decodePcSogs",\n            { fileBytes, extraFiles }\n          );\n          return { packedArray, numSplats, extra };\n        });\n      }\n      default: {\n        throw new Error(`Unknown splat file type: ${splatFileType}`);\n      }\n    }\n  }\n  class SplatData {\n    constructor({ maxSplats = 1 } = {}) {\n      this.numSplats = 0;\n      this.maxSplats = getTextureSize(maxSplats).maxSplats;\n      this.centers = new Float32Array(this.maxSplats * 3);\n      this.scales = new Float32Array(this.maxSplats * 3);\n      this.quaternions = new Float32Array(this.maxSplats * 4);\n      this.opacities = new Float32Array(this.maxSplats);\n      this.colors = new Float32Array(this.maxSplats * 3);\n    }\n    pushSplat() {\n      const index = this.numSplats;\n      this.ensureIndex(index);\n      this.numSplats += 1;\n      return index;\n    }\n    unpushSplat(index) {\n      if (index === this.numSplats - 1) {\n        this.numSplats -= 1;\n      } else {\n        throw new Error("Cannot unpush splat from non-last position");\n      }\n    }\n    ensureCapacity(numSplats) {\n      if (numSplats > this.maxSplats) {\n        const targetSplats = Math.max(numSplats, this.maxSplats * 2);\n        const newCenters = new Float32Array(targetSplats * 3);\n        const newScales = new Float32Array(targetSplats * 3);\n        const newQuaternions = new Float32Array(targetSplats * 4);\n        const newOpacities = new Float32Array(targetSplats);\n        const newColors = new Float32Array(targetSplats * 3);\n        newCenters.set(this.centers);\n        newScales.set(this.scales);\n        newQuaternions.set(this.quaternions);\n        newOpacities.set(this.opacities);\n        newColors.set(this.colors);\n        this.centers = newCenters;\n        this.scales = newScales;\n        this.quaternions = newQuaternions;\n        this.opacities = newOpacities;\n        this.colors = newColors;\n        if (this.sh1) {\n          const newSh1 = new Float32Array(targetSplats * 9);\n          newSh1.set(this.sh1);\n          this.sh1 = newSh1;\n        }\n        if (this.sh2) {\n          const newSh2 = new Float32Array(targetSplats * 15);\n          newSh2.set(this.sh2);\n          this.sh2 = newSh2;\n        }\n        if (this.sh3) {\n          const newSh3 = new Float32Array(targetSplats * 21);\n          newSh3.set(this.sh3);\n          this.sh3 = newSh3;\n        }\n        this.maxSplats = targetSplats;\n      }\n    }\n    ensureIndex(index) {\n      this.ensureCapacity(index + 1);\n    }\n    setCenter(index, x2, y, z) {\n      this.centers[index * 3] = x2;\n      this.centers[index * 3 + 1] = y;\n      this.centers[index * 3 + 2] = z;\n    }\n    setScale(index, scaleX, scaleY, scaleZ) {\n      this.scales[index * 3] = scaleX;\n      this.scales[index * 3 + 1] = scaleY;\n      this.scales[index * 3 + 2] = scaleZ;\n    }\n    setQuaternion(index, x2, y, z, w) {\n      this.quaternions[index * 4] = x2;\n      this.quaternions[index * 4 + 1] = y;\n      this.quaternions[index * 4 + 2] = z;\n      this.quaternions[index * 4 + 3] = w;\n    }\n    setOpacity(index, opacity) {\n      this.opacities[index] = opacity;\n    }\n    setColor(index, r, g, b) {\n      this.colors[index * 3] = r;\n      this.colors[index * 3 + 1] = g;\n      this.colors[index * 3 + 2] = b;\n    }\n    setSh1(index, sh1) {\n      if (!this.sh1) {\n        this.sh1 = new Float32Array(this.maxSplats * 9);\n      }\n      for (let j = 0; j < 9; ++j) {\n        this.sh1[index * 9 + j] = sh1[j];\n      }\n    }\n    setSh2(index, sh2) {\n      if (!this.sh2) {\n        this.sh2 = new Float32Array(this.maxSplats * 15);\n      }\n      for (let j = 0; j < 15; ++j) {\n        this.sh2[index * 15 + j] = sh2[j];\n      }\n    }\n    setSh3(index, sh3) {\n      if (!this.sh3) {\n        this.sh3 = new Float32Array(this.maxSplats * 21);\n      }\n      for (let j = 0; j < 21; ++j) {\n        this.sh3[index * 21 + j] = sh3[j];\n      }\n    }\n  }\n  class SpzReader {\n    constructor({ fileBytes }) {\n      this.fileBytes = fileBytes instanceof ArrayBuffer ? new Uint8Array(fileBytes) : fileBytes;\n      this.reader = new GunzipReader({ fileBytes: this.fileBytes });\n      const header = new DataView(this.reader.read(16).buffer);\n      if (header.getUint32(0, true) !== 1347635022) {\n        throw new Error("Invalid SPZ file");\n      }\n      this.version = header.getUint32(4, true);\n      if (this.version < 1 || this.version > 2) {\n        throw new Error(`Unsupported SPZ version: ${this.version}`);\n      }\n      this.numSplats = header.getUint32(8, true);\n      this.shDegree = header.getUint8(12);\n      this.fractionalBits = header.getUint8(13);\n      this.flags = header.getUint8(14);\n      this.flagAntiAlias = (this.flags & 1) !== 0;\n      this.reserved = header.getUint8(15);\n      this.parsed = false;\n    }\n    parseSplats(centerCallback, alphaCallback, rgbCallback, scalesCallback, quatCallback, shCallback) {\n      if (this.parsed) {\n        throw new Error("SPZ file already parsed");\n      }\n      this.parsed = true;\n      if (this.version === 1) {\n        const centerBytes = this.reader.read(this.numSplats * 3 * 2);\n        const centerUint16 = new Uint16Array(centerBytes.buffer);\n        for (let i2 = 0; i2 < this.numSplats; i2++) {\n          const i3 = i2 * 3;\n          const x2 = fromHalf(centerUint16[i3]);\n          const y = fromHalf(centerUint16[i3 + 1]);\n          const z = fromHalf(centerUint16[i3 + 2]);\n          centerCallback == null ? void 0 : centerCallback(i2, x2, y, z);\n        }\n      } else if (this.version === 2) {\n        const fixed = 1 << this.fractionalBits;\n        const centerBytes = this.reader.read(this.numSplats * 3 * 3);\n        for (let i2 = 0; i2 < this.numSplats; i2++) {\n          const i9 = i2 * 9;\n          const x2 = ((centerBytes[i9 + 2] << 24 | centerBytes[i9 + 1] << 16 | centerBytes[i9] << 8) >> 8) / fixed;\n          const y = ((centerBytes[i9 + 5] << 24 | centerBytes[i9 + 4] << 16 | centerBytes[i9 + 3] << 8) >> 8) / fixed;\n          const z = ((centerBytes[i9 + 8] << 24 | centerBytes[i9 + 7] << 16 | centerBytes[i9 + 6] << 8) >> 8) / fixed;\n          centerCallback == null ? void 0 : centerCallback(i2, x2, y, z);\n        }\n      } else {\n        throw new Error("Unreachable");\n      }\n      {\n        const bytes = this.reader.read(this.numSplats);\n        for (let i2 = 0; i2 < this.numSplats; i2++) {\n          alphaCallback == null ? void 0 : alphaCallback(i2, bytes[i2] / 255);\n        }\n      }\n      {\n        const rgbBytes = this.reader.read(this.numSplats * 3);\n        const scale = SH_C0 / 0.15;\n        for (let i2 = 0; i2 < this.numSplats; i2++) {\n          const i3 = i2 * 3;\n          const r = (rgbBytes[i3] / 255 - 0.5) * scale + 0.5;\n          const g = (rgbBytes[i3 + 1] / 255 - 0.5) * scale + 0.5;\n          const b = (rgbBytes[i3 + 2] / 255 - 0.5) * scale + 0.5;\n          rgbCallback == null ? void 0 : rgbCallback(i2, r, g, b);\n        }\n      }\n      {\n        const scalesBytes = this.reader.read(this.numSplats * 3);\n        for (let i2 = 0; i2 < this.numSplats; i2++) {\n          const i3 = i2 * 3;\n          const scaleX = Math.exp(scalesBytes[i3] / 16 - 10);\n          const scaleY = Math.exp(scalesBytes[i3 + 1] / 16 - 10);\n          const scaleZ = Math.exp(scalesBytes[i3 + 2] / 16 - 10);\n          scalesCallback == null ? void 0 : scalesCallback(i2, scaleX, scaleY, scaleZ);\n        }\n      }\n      {\n        const quatBytes = this.reader.read(this.numSplats * 3);\n        for (let i2 = 0; i2 < this.numSplats; i2++) {\n          const i3 = i2 * 3;\n          const quatX = quatBytes[i3] / 127.5 - 1;\n          const quatY = quatBytes[i3 + 1] / 127.5 - 1;\n          const quatZ = quatBytes[i3 + 2] / 127.5 - 1;\n          const quatW = Math.sqrt(\n            Math.max(0, 1 - quatX * quatX - quatY * quatY - quatZ * quatZ)\n          );\n          quatCallback == null ? void 0 : quatCallback(i2, quatX, quatY, quatZ, quatW);\n        }\n      }\n      if (shCallback && this.shDegree >= 1) {\n        const sh1 = new Float32Array(3 * 3);\n        const sh2 = this.shDegree >= 2 ? new Float32Array(5 * 3) : void 0;\n        const sh3 = this.shDegree >= 3 ? new Float32Array(7 * 3) : void 0;\n        const shBytes = this.reader.read(\n          this.numSplats * SH_DEGREE_TO_VECS[this.shDegree] * 3\n        );\n        let offset = 0;\n        for (let i2 = 0; i2 < this.numSplats; i2++) {\n          for (let j = 0; j < 9; ++j) {\n            sh1[j] = (shBytes[offset + j] - 128) / 128;\n          }\n          offset += 9;\n          if (sh2) {\n            for (let j = 0; j < 15; ++j) {\n              sh2[j] = (shBytes[offset + j] - 128) / 128;\n            }\n            offset += 15;\n          }\n          if (sh3) {\n            for (let j = 0; j < 21; ++j) {\n              sh3[j] = (shBytes[offset + j] - 128) / 128;\n            }\n            offset += 21;\n          }\n          shCallback == null ? void 0 : shCallback(i2, sh1, sh2, sh3);\n        }\n      }\n    }\n  }\n  const SH_DEGREE_TO_VECS = { 1: 3, 2: 8, 3: 15 };\n  const SH_C0 = 0.28209479177387814;\n  const SPZ_MAGIC = 1347635022;\n  const SPZ_VERSION = 2;\n  const FLAG_ANTIALIASED = 1;\n  class SpzWriter {\n    constructor({\n      numSplats,\n      shDegree,\n      fractionalBits = 12,\n      flagAntiAlias = true\n    }) {\n      this.clippedCount = 0;\n      const splatSize = 9 + 1 + 3 + 3 + 3 + (shDegree >= 1 ? 9 : 0) + (shDegree >= 2 ? 15 : 0) + (shDegree >= 3 ? 21 : 0);\n      const bufferSize = 16 + numSplats * splatSize;\n      this.buffer = new ArrayBuffer(bufferSize);\n      this.view = new DataView(this.buffer);\n      this.view.setUint32(0, SPZ_MAGIC, true);\n      this.view.setUint32(4, SPZ_VERSION, true);\n      this.view.setUint32(8, numSplats, true);\n      this.view.setUint8(12, shDegree);\n      this.view.setUint8(13, fractionalBits);\n      this.view.setUint8(14, flagAntiAlias ? FLAG_ANTIALIASED : 0);\n      this.view.setUint8(15, 0);\n      this.numSplats = numSplats;\n      this.shDegree = shDegree;\n      this.fractionalBits = fractionalBits;\n      this.fraction = 1 << fractionalBits;\n      this.flagAntiAlias = flagAntiAlias;\n    }\n    setCenter(index, x2, y, z) {\n      const xRounded = Math.round(x2 * this.fraction);\n      const xInt = Math.max(-8388607, Math.min(8388607, xRounded));\n      const yRounded = Math.round(y * this.fraction);\n      const yInt = Math.max(-8388607, Math.min(8388607, yRounded));\n      const zRounded = Math.round(z * this.fraction);\n      const zInt = Math.max(-8388607, Math.min(8388607, zRounded));\n      const clipped = xRounded !== xInt || yRounded !== yInt || zRounded !== zInt;\n      if (clipped) {\n        this.clippedCount += 1;\n      }\n      const i9 = index * 9;\n      const base = 16 + i9;\n      this.view.setUint8(base, xInt & 255);\n      this.view.setUint8(base + 1, xInt >> 8 & 255);\n      this.view.setUint8(base + 2, xInt >> 16 & 255);\n      this.view.setUint8(base + 3, yInt & 255);\n      this.view.setUint8(base + 4, yInt >> 8 & 255);\n      this.view.setUint8(base + 5, yInt >> 16 & 255);\n      this.view.setUint8(base + 6, zInt & 255);\n      this.view.setUint8(base + 7, zInt >> 8 & 255);\n      this.view.setUint8(base + 8, zInt >> 16 & 255);\n    }\n    setAlpha(index, alpha) {\n      const base = 16 + this.numSplats * 9 + index;\n      this.view.setUint8(\n        base,\n        Math.max(0, Math.min(255, Math.round(alpha * 255)))\n      );\n    }\n    static scaleRgb(r) {\n      const v = ((r - 0.5) / (SH_C0 / 0.15) + 0.5) * 255;\n      return Math.max(0, Math.min(255, Math.round(v)));\n    }\n    setRgb(index, r, g, b) {\n      const base = 16 + this.numSplats * 10 + index * 3;\n      this.view.setUint8(base, SpzWriter.scaleRgb(r));\n      this.view.setUint8(base + 1, SpzWriter.scaleRgb(g));\n      this.view.setUint8(base + 2, SpzWriter.scaleRgb(b));\n    }\n    setScale(index, scaleX, scaleY, scaleZ) {\n      const base = 16 + this.numSplats * 13 + index * 3;\n      this.view.setUint8(\n        base,\n        Math.max(0, Math.min(255, Math.round((Math.log(scaleX) + 10) * 16)))\n      );\n      this.view.setUint8(\n        base + 1,\n        Math.max(0, Math.min(255, Math.round((Math.log(scaleY) + 10) * 16)))\n      );\n      this.view.setUint8(\n        base + 2,\n        Math.max(0, Math.min(255, Math.round((Math.log(scaleZ) + 10) * 16)))\n      );\n    }\n    setQuat(index, quatX, quatY, quatZ, quatW) {\n      const base = 16 + this.numSplats * 16 + index * 3;\n      const quatNeg = quatW < 0;\n      this.view.setUint8(\n        base,\n        Math.max(\n          0,\n          Math.min(255, Math.round(((quatNeg ? -quatX : quatX) + 1) * 127.5))\n        )\n      );\n      this.view.setUint8(\n        base + 1,\n        Math.max(\n          0,\n          Math.min(255, Math.round(((quatNeg ? -quatY : quatY) + 1) * 127.5))\n        )\n      );\n      this.view.setUint8(\n        base + 2,\n        Math.max(\n          0,\n          Math.min(255, Math.round(((quatNeg ? -quatZ : quatZ) + 1) * 127.5))\n        )\n      );\n    }\n    static quantizeSh(sh, bits2) {\n      const value = Math.round(sh * 128) + 128;\n      const bucketSize = 1 << 8 - bits2;\n      const quantized = Math.floor((value + bucketSize / 2) / bucketSize) * bucketSize;\n      return Math.max(0, Math.min(255, quantized));\n    }\n    setSh(index, sh1, sh2, sh3) {\n      const shVecs = SH_DEGREE_TO_VECS[this.shDegree] || 0;\n      const base1 = 16 + this.numSplats * 19 + index * shVecs * 3;\n      for (let j = 0; j < 9; ++j) {\n        this.view.setUint8(base1 + j, SpzWriter.quantizeSh(sh1[j], 5));\n      }\n      if (sh2) {\n        const base2 = base1 + 9;\n        for (let j = 0; j < 15; ++j) {\n          this.view.setUint8(base2 + j, SpzWriter.quantizeSh(sh2[j], 4));\n        }\n        if (sh3) {\n          const base3 = base2 + 15;\n          for (let j = 0; j < 21; ++j) {\n            this.view.setUint8(base3 + j, SpzWriter.quantizeSh(sh3[j], 4));\n          }\n        }\n      }\n    }\n    async finalize() {\n      const input = new Uint8Array(this.buffer);\n      const stream = new ReadableStream({\n        async start(controller) {\n          controller.enqueue(input);\n          controller.close();\n        }\n      });\n      const compressed = stream.pipeThrough(new CompressionStream("gzip"));\n      const response = new Response(compressed);\n      const buffer = await response.arrayBuffer();\n      console.log(\n        "Compressed",\n        input.length,\n        "bytes to",\n        buffer.byteLength,\n        "bytes"\n      );\n      return new Uint8Array(buffer);\n    }\n  }\n  async function transcodeSpz(input) {\n    var _a2, _b2, _c;\n    const splats = new SplatData();\n    const {\n      inputs,\n      clipXyz,\n      maxSh,\n      fractionalBits = 12,\n      opacityThreshold\n    } = input;\n    for (const input2 of inputs) {\n      let transformPos2 = function(pos) {\n        pos.multiplyScalar(scale);\n        pos.applyQuaternion(quaternion);\n        pos.add(translate);\n        return pos;\n      }, transformScales = function(scales) {\n        scales.multiplyScalar(scale);\n        return scales;\n      }, transformQuaternion = function(quat) {\n        quat.premultiply(quaternion);\n        return quat;\n      }, withinClip = function(p) {\n        return !clip || clip.containsPoint(p);\n      }, withinOpacity = function(opacity) {\n        return opacityThreshold !== void 0 ? opacity >= opacityThreshold : true;\n      };\n      const scale = ((_a2 = input2.transform) == null ? void 0 : _a2.scale) ?? 1;\n      const quaternion = new Quaternion().fromArray(\n        ((_b2 = input2.transform) == null ? void 0 : _b2.quaternion) ?? [0, 0, 0, 1]\n      );\n      const translate = new Vector3().fromArray(\n        ((_c = input2.transform) == null ? void 0 : _c.translate) ?? [0, 0, 0]\n      );\n      const clip = clipXyz ? new Box3(\n        new Vector3().fromArray(clipXyz.min),\n        new Vector3().fromArray(clipXyz.max)\n      ) : void 0;\n      let fileType = input2.fileType;\n      if (!fileType) {\n        fileType = getSplatFileType(input2.fileBytes);\n        if (!fileType && input2.pathOrUrl) {\n          fileType = getSplatFileTypeFromPath(input2.pathOrUrl);\n        }\n      }\n      switch (fileType) {\n        case SplatFileType.PLY: {\n          const ply = new PlyReader({ fileBytes: input2.fileBytes });\n          await ply.parseHeader();\n          let lastIndex = null;\n          ply.parseSplats(\n            (index, x2, y, z, scaleX, scaleY, scaleZ, quatX, quatY, quatZ, quatW, opacity, r, g, b) => {\n              const center = transformPos2(new Vector3(x2, y, z));\n              if (withinClip(center) && withinOpacity(opacity)) {\n                lastIndex = splats.pushSplat();\n                splats.setCenter(lastIndex, center.x, center.y, center.z);\n                const scales = transformScales(\n                  new Vector3(scaleX, scaleY, scaleZ)\n                );\n                splats.setScale(lastIndex, scales.x, scales.y, scales.z);\n                const quaternion2 = transformQuaternion(\n                  new Quaternion(quatX, quatY, quatZ, quatW)\n                );\n                splats.setQuaternion(\n                  lastIndex,\n                  quaternion2.x,\n                  quaternion2.y,\n                  quaternion2.z,\n                  quaternion2.w\n                );\n                splats.setOpacity(lastIndex, opacity);\n                splats.setColor(lastIndex, r, g, b);\n              } else {\n                lastIndex = null;\n              }\n            },\n            (index, sh1, sh2, sh3) => {\n              if (sh1 && lastIndex !== null) {\n                splats.setSh1(lastIndex, sh1);\n              }\n              if (sh2 && lastIndex !== null) {\n                splats.setSh2(lastIndex, sh2);\n              }\n              if (sh3 && lastIndex !== null) {\n                splats.setSh3(lastIndex, sh3);\n              }\n            }\n          );\n          break;\n        }\n        case SplatFileType.SPZ: {\n          const spz2 = new SpzReader({ fileBytes: input2.fileBytes });\n          const mapping = new Int32Array(spz2.numSplats);\n          mapping.fill(-1);\n          const centers = new Float32Array(spz2.numSplats * 3);\n          const center = new Vector3();\n          spz2.parseSplats(\n            (index, x2, y, z) => {\n              const center2 = transformPos2(new Vector3(x2, y, z));\n              centers[index * 3] = center2.x;\n              centers[index * 3 + 1] = center2.y;\n              centers[index * 3 + 2] = center2.z;\n            },\n            (index, alpha) => {\n              center.fromArray(centers, index * 3);\n              if (withinClip(center) && withinOpacity(alpha)) {\n                mapping[index] = splats.pushSplat();\n                splats.setCenter(mapping[index], center.x, center.y, center.z);\n                splats.setOpacity(mapping[index], alpha);\n              }\n            },\n            (index, r, g, b) => {\n              if (mapping[index] >= 0) {\n                splats.setColor(mapping[index], r, g, b);\n              }\n            },\n            (index, scaleX, scaleY, scaleZ) => {\n              if (mapping[index] >= 0) {\n                const scales = transformScales(\n                  new Vector3(scaleX, scaleY, scaleZ)\n                );\n                splats.setScale(mapping[index], scales.x, scales.y, scales.z);\n              }\n            },\n            (index, quatX, quatY, quatZ, quatW) => {\n              if (mapping[index] >= 0) {\n                const quaternion2 = transformQuaternion(\n                  new Quaternion(quatX, quatY, quatZ, quatW)\n                );\n                splats.setQuaternion(\n                  mapping[index],\n                  quaternion2.x,\n                  quaternion2.y,\n                  quaternion2.z,\n                  quaternion2.w\n                );\n              }\n            },\n            (index, sh1, sh2, sh3) => {\n              if (mapping[index] >= 0) {\n                splats.setSh1(mapping[index], sh1);\n                if (sh2) {\n                  splats.setSh2(mapping[index], sh2);\n                }\n                if (sh3) {\n                  splats.setSh3(mapping[index], sh3);\n                }\n              }\n            }\n          );\n          break;\n        }\n        case SplatFileType.SPLAT:\n          decodeAntiSplat(\n            input2.fileBytes,\n            (numSplats) => {\n            },\n            (index, x2, y, z, scaleX, scaleY, scaleZ, quatX, quatY, quatZ, quatW, opacity, r, g, b) => {\n              const center = transformPos2(new Vector3(x2, y, z));\n              if (withinClip(center) && withinOpacity(opacity)) {\n                const index2 = splats.pushSplat();\n                splats.setCenter(index2, center.x, center.y, center.z);\n                const scales = transformScales(\n                  new Vector3(scaleX, scaleY, scaleZ)\n                );\n                splats.setScale(index2, scales.x, scales.y, scales.z);\n                const quaternion2 = transformQuaternion(\n                  new Quaternion(quatX, quatY, quatZ, quatW)\n                );\n                splats.setQuaternion(\n                  index2,\n                  quaternion2.x,\n                  quaternion2.y,\n                  quaternion2.z,\n                  quaternion2.w\n                );\n                splats.setOpacity(index2, opacity);\n                splats.setColor(index2, r, g, b);\n              }\n            }\n          );\n          break;\n        case SplatFileType.KSPLAT: {\n          let lastIndex = null;\n          decodeKsplat(\n            input2.fileBytes,\n            (numSplats) => {\n            },\n            (index, x2, y, z, scaleX, scaleY, scaleZ, quatX, quatY, quatZ, quatW, opacity, r, g, b) => {\n              const center = transformPos2(new Vector3(x2, y, z));\n              if (withinClip(center) && withinOpacity(opacity)) {\n                lastIndex = splats.pushSplat();\n                splats.setCenter(lastIndex, center.x, center.y, center.z);\n                const scales = transformScales(\n                  new Vector3(scaleX, scaleY, scaleZ)\n                );\n                splats.setScale(lastIndex, scales.x, scales.y, scales.z);\n                const quaternion2 = transformQuaternion(\n                  new Quaternion(quatX, quatY, quatZ, quatW)\n                );\n                splats.setQuaternion(\n                  lastIndex,\n                  quaternion2.x,\n                  quaternion2.y,\n                  quaternion2.z,\n                  quaternion2.w\n                );\n                splats.setOpacity(lastIndex, opacity);\n                splats.setColor(lastIndex, r, g, b);\n              } else {\n                lastIndex = null;\n              }\n            },\n            (index, sh1, sh2, sh3) => {\n              if (lastIndex !== null) {\n                splats.setSh1(lastIndex, sh1);\n                if (sh2) {\n                  splats.setSh2(lastIndex, sh2);\n                }\n                if (sh3) {\n                  splats.setSh3(lastIndex, sh3);\n                }\n              }\n            }\n          );\n          break;\n        }\n        default:\n          throw new Error(`transcodeSpz not implemented for ${fileType}`);\n      }\n    }\n    const shDegree = Math.min(\n      maxSh ?? 3,\n      splats.sh3 ? 3 : splats.sh2 ? 2 : splats.sh1 ? 1 : 0\n    );\n    const spz = new SpzWriter({\n      numSplats: splats.numSplats,\n      shDegree,\n      fractionalBits,\n      flagAntiAlias: true\n    });\n    for (let i2 = 0; i2 < splats.numSplats; ++i2) {\n      const i3 = i2 * 3;\n      const i4 = i2 * 4;\n      spz.setCenter(\n        i2,\n        splats.centers[i3],\n        splats.centers[i3 + 1],\n        splats.centers[i3 + 2]\n      );\n      spz.setScale(\n        i2,\n        splats.scales[i3],\n        splats.scales[i3 + 1],\n        splats.scales[i3 + 2]\n      );\n      spz.setQuat(\n        i2,\n        splats.quaternions[i4],\n        splats.quaternions[i4 + 1],\n        splats.quaternions[i4 + 2],\n        splats.quaternions[i4 + 3]\n      );\n      spz.setAlpha(i2, splats.opacities[i2]);\n      spz.setRgb(\n        i2,\n        splats.colors[i3],\n        splats.colors[i3 + 1],\n        splats.colors[i3 + 2]\n      );\n      if (splats.sh1 && shDegree >= 1) {\n        spz.setSh(\n          i2,\n          splats.sh1.slice(i2 * 9, (i2 + 1) * 9),\n          shDegree >= 2 && splats.sh2 ? splats.sh2.slice(i2 * 15, (i2 + 1) * 15) : void 0,\n          shDegree >= 3 && splats.sh3 ? splats.sh3.slice(i2 * 21, (i2 + 1) * 21) : void 0\n        );\n      }\n    }\n    const spzBytes = await spz.finalize();\n    return { fileBytes: spzBytes, clippedCount: spz.clippedCount };\n  }\n  async function onMessage(event) {\n    const { name, args, id } = event.data;\n    let result = void 0;\n    let error = void 0;\n    try {\n      switch (name) {\n        case "unpackPly": {\n          const { packedArray, fileBytes } = args;\n          const decoded = await unpackPly({ packedArray, fileBytes });\n          result = {\n            id,\n            numSplats: decoded.numSplats,\n            packedArray: decoded.packedArray,\n            extra: decoded.extra\n          };\n          break;\n        }\n        case "decodeSpz": {\n          const { fileBytes } = args;\n          const decoded = unpackSpz(fileBytes);\n          result = {\n            id,\n            numSplats: decoded.numSplats,\n            packedArray: decoded.packedArray,\n            extra: decoded.extra\n          };\n          break;\n        }\n        case "decodeAntiSplat": {\n          const { fileBytes } = args;\n          const decoded = unpackAntiSplat(fileBytes);\n          result = {\n            id,\n            numSplats: decoded.numSplats,\n            packedArray: decoded.packedArray\n          };\n          break;\n        }\n        case "decodeKsplat": {\n          const { fileBytes } = args;\n          const decoded = unpackKsplat(fileBytes);\n          result = {\n            id,\n            numSplats: decoded.numSplats,\n            packedArray: decoded.packedArray,\n            extra: decoded.extra\n          };\n          break;\n        }\n        case "decodePcSogs": {\n          const { fileBytes, extraFiles } = args;\n          const decoded = await unpackPcSogs(fileBytes, extraFiles);\n          result = {\n            id,\n            numSplats: decoded.numSplats,\n            packedArray: decoded.packedArray,\n            extra: decoded.extra\n          };\n          break;\n        }\n        case "sortSplats": {\n          const { maxSplats, totalSplats, readback, ordering } = args;\n          result = {\n            id,\n            readback,\n            ...sortSplats({ totalSplats, readback, ordering })\n          };\n          break;\n        }\n        case "sortDoubleSplats": {\n          const { numSplats, readback, ordering } = args;\n          result = {\n            id,\n            readback,\n            ordering\n          };\n          if (WASM_SPLAT_SORT) {\n            result = {\n              id,\n              readback,\n              ordering,\n              activeSplats: sort_splats(numSplats, readback, ordering)\n            };\n          }\n          break;\n        }\n        case "transcodeSpz": {\n          const input = args;\n          const spzBytes = await transcodeSpz(input);\n          result = {\n            id,\n            fileBytes: spzBytes,\n            input\n          };\n          break;\n        }\n        default: {\n          throw new Error(`Unknown name: ${name}`);\n        }\n      }\n    } catch (e) {\n      error = e;\n    }\n    self.postMessage(\n      { id, result, error },\n      { transfer: getArrayBuffers(result) }\n    );\n  }\n  async function unpackPly({\n    packedArray,\n    fileBytes\n  }) {\n    const ply = new PlyReader({ fileBytes });\n    await ply.parseHeader();\n    const numSplats = ply.numSplats;\n    const extra = {};\n    const ZERO_CUTOFF = Math.exp(-20);\n    ply.parseSplats(\n      (index, x2, y, z, scaleX, scaleY, scaleZ, quatX, quatY, quatZ, quatW, opacity, r, g, b) => {\n        setPackedSplat(\n          packedArray,\n          index,\n          x2,\n          y,\n          z,\n          scaleX < ZERO_CUTOFF ? 0 : Math.max(SCALE_MIN, scaleX),\n          scaleY < ZERO_CUTOFF ? 0 : Math.max(SCALE_MIN, scaleY),\n          scaleZ < ZERO_CUTOFF ? 0 : Math.max(SCALE_MIN, scaleZ),\n          quatX,\n          quatY,\n          quatZ,\n          quatW,\n          opacity,\n          r,\n          g,\n          b\n        );\n      },\n      (index, sh1, sh2, sh3) => {\n        if (sh1) {\n          if (!extra.sh1) {\n            extra.sh1 = new Uint32Array(numSplats * 2);\n          }\n          encodeSh1Rgb(extra.sh1, index, sh1);\n        }\n        if (sh2) {\n          if (!extra.sh2) {\n            extra.sh2 = new Uint32Array(numSplats * 4);\n          }\n          encodeSh2Rgb(extra.sh2, index, sh2);\n        }\n        if (sh3) {\n          if (!extra.sh3) {\n            extra.sh3 = new Uint32Array(numSplats * 4);\n          }\n          encodeSh3Rgb(extra.sh3, index, sh3);\n        }\n      }\n    );\n    return { packedArray, numSplats, extra };\n  }\n  function unpackSpz(fileBytes) {\n    const spz = new SpzReader({ fileBytes });\n    const numSplats = spz.numSplats;\n    const maxSplats = computeMaxSplats(numSplats);\n    const packedArray = new Uint32Array(maxSplats * 4);\n    const extra = {};\n    spz.parseSplats(\n      (index, x2, y, z) => {\n        setPackedSplatCenter(packedArray, index, x2, y, z);\n      },\n      (index, alpha) => {\n        setPackedSplatOpacity(packedArray, index, alpha);\n      },\n      (index, r, g, b) => {\n        setPackedSplatRgb(packedArray, index, r, g, b);\n      },\n      (index, scaleX, scaleY, scaleZ) => {\n        setPackedSplatScales(packedArray, index, scaleX, scaleY, scaleZ);\n      },\n      (index, quatX, quatY, quatZ, quatW) => {\n        setPackedSplatQuat(packedArray, index, quatX, quatY, quatZ, quatW);\n      },\n      (index, sh1, sh2, sh3) => {\n        if (sh1) {\n          if (!extra.sh1) {\n            extra.sh1 = new Uint32Array(numSplats * 2);\n          }\n          encodeSh1Rgb(extra.sh1, index, sh1);\n        }\n        if (sh2) {\n          if (!extra.sh2) {\n            extra.sh2 = new Uint32Array(numSplats * 4);\n          }\n          encodeSh2Rgb(extra.sh2, index, sh2);\n        }\n        if (sh3) {\n          if (!extra.sh3) {\n            extra.sh3 = new Uint32Array(numSplats * 4);\n          }\n          encodeSh3Rgb(extra.sh3, index, sh3);\n        }\n      }\n    );\n    return { packedArray, numSplats, extra };\n  }\n  const DEPTH_INFINITY = 31744;\n  const DEPTH_SIZE = DEPTH_INFINITY + 1;\n  let depthArray = null;\n  function sortSplats({\n    totalSplats,\n    readback,\n    ordering\n  }) {\n    if (!depthArray) {\n      depthArray = new Uint32Array(DEPTH_SIZE);\n    }\n    depthArray.fill(0);\n    const readbackUint32 = readback.map((layer) => new Uint32Array(layer.buffer));\n    const layerSize = readbackUint32[0].length;\n    const numLayers = Math.ceil(totalSplats / layerSize);\n    let layerBase = 0;\n    for (let layer = 0; layer < numLayers; ++layer) {\n      const readbackLayer = readbackUint32[layer];\n      const layerSplats = Math.min(readbackLayer.length, totalSplats - layerBase);\n      for (let i2 = 0; i2 < layerSplats; ++i2) {\n        const pri = readbackLayer[i2] & 32767;\n        if (pri < DEPTH_INFINITY) {\n          depthArray[pri] += 1;\n        }\n      }\n      layerBase += layerSplats;\n    }\n    let activeSplats = 0;\n    for (let j = 0; j < DEPTH_SIZE; ++j) {\n      const nextIndex = activeSplats + depthArray[j];\n      depthArray[j] = activeSplats;\n      activeSplats = nextIndex;\n    }\n    layerBase = 0;\n    for (let layer = 0; layer < numLayers; ++layer) {\n      const readbackLayer = readbackUint32[layer];\n      const layerSplats = Math.min(readbackLayer.length, totalSplats - layerBase);\n      for (let i2 = 0; i2 < layerSplats; ++i2) {\n        const pri = readbackLayer[i2] & 32767;\n        if (pri < DEPTH_INFINITY) {\n          ordering[depthArray[pri]] = layerBase + i2;\n          depthArray[pri] += 1;\n        }\n      }\n      layerBase += layerSplats;\n    }\n    if (depthArray[DEPTH_SIZE - 1] !== activeSplats) {\n      throw new Error(\n        `Expected ${activeSplats} active splats but got ${depthArray[DEPTH_SIZE - 1]}`\n      );\n    }\n    return { activeSplats, ordering };\n  }\n  function sortDoubleSplats({\n    numSplats,\n    readback,\n    ordering\n  }) {\n    if (!depthArray) {\n      depthArray = new Uint32Array(DEPTH_SIZE);\n    }\n    depthArray.fill(0);\n    for (let i2 = 0; i2 < numSplats; ++i2) {\n      const pri = readback[i2];\n      if (pri < DEPTH_INFINITY) {\n        depthArray[pri] += 1;\n      }\n    }\n    let activeSplats = 0;\n    for (let j = DEPTH_INFINITY - 1; j >= 0; --j) {\n      const nextIndex = activeSplats + depthArray[j];\n      depthArray[j] = activeSplats;\n      activeSplats = nextIndex;\n    }\n    for (let i2 = 0; i2 < numSplats; ++i2) {\n      const pri = readback[i2];\n      if (pri < DEPTH_INFINITY) {\n        ordering[depthArray[pri]] = i2;\n        depthArray[pri] += 1;\n      }\n    }\n    if (depthArray[0] !== activeSplats) {\n      throw new Error(\n        `Expected ${activeSplats} active splats but got ${depthArray[0]}`\n      );\n    }\n    return { activeSplats, ordering };\n  }\n  const messageBuffer = [];\n  function bufferMessage(event) {\n    messageBuffer.push(event);\n  }\n  async function initialize() {\n    self.addEventListener("message", bufferMessage);\n    await __wbg_init();\n    self.removeEventListener("message", bufferMessage);\n    self.addEventListener("message", onMessage);\n    for (const event of messageBuffer) {\n      onMessage(event);\n    }\n    messageBuffer.length = 0;\n  }\n  initialize().catch(console.error);\n})();\n//# sourceMappingURL=worker-D5xlON3B.js.map\n',Og="undefined"!=typeof self&&self.Blob&&new Blob([Pg],{type:"text/javascript;charset=utf-8"});function Wg(A){let n;try{if(n=Og&&(self.URL||self.webkitURL).createObjectURL(Og),!n)throw"";const t=new Worker(n,{name:null==A?void 0:A.name});return t.addEventListener("error",(()=>{(self.URL||self.webkitURL).revokeObjectURL(n)})),t}catch(n){return new Worker("data:text/javascript;charset=utf-8,"+encodeURIComponent(Pg),{name:null==A?void 0:A.name})}finally{n&&(self.URL||self.webkitURL).revokeObjectURL(n)}}class Vg{constructor(){this.messages={},this.messageIdNext=0,this.worker=new Wg,this.worker.onmessage=A=>this.onMessage(A)}makeMessageId(){return++this.messageIdNext}makeMessagePromiseId(){const A=this.makeMessageId(),n=new Promise(((n,t)=>{this.messages[A]={resolve:n,reject:t}}));return{id:A,promise:n}}onMessage(A){const{id:n,result:t,error:e}=A.data,i=this.messages[n];i&&(delete this.messages[n],e?i.reject(e):i.resolve(t))}async call(A,n){const{id:t,promise:e}=this.makeMessagePromiseId();return this.worker.postMessage({name:A,args:n,id:t},{transfer:$n(n)}),e}}let jg=4,Xg=0;const $g=[],Aa=[];async function na(A){const n=await async function(){const A=$g.shift();if(A)return A;if(Xg<jg){const A=new Vg;return Xg+=1,A}return new Promise((A=>{Aa.push(A)}))}();try{return await A(n)}finally{!function(A){if(Xg>jg)return void(Xg-=1);const n=Aa.shift();n?n(A):$g.push(A)}(n)}}class ta extends e.Loader{constructor(A){super(A),this.fileLoader=new e.FileLoader(A)}load(A,n,t,e){this.fileLoader.setResponseType("arraybuffer"),this.fileLoader.setCrossOrigin(this.crossOrigin),this.fileLoader.setWithCredentials(this.withCredentials),this.fileLoader.setPath(this.path),this.fileLoader.setResourcePath(this.resourcePath),this.fileLoader.setRequestHeader(this.requestHeader),this.fileLoader.load(A,(async t=>{if(n){const i=t,s={},g=[];let a=this.fileType;try{const t=aa(i);if("pcsogs"===this.fileType&&void 0===t)throw new Error("Invalid PC SOGS file");if(void 0!==t){a="pcsogs";for(const n of["means","scales","quats","sh0","shN"]){const e=t[n];if(e){const n=e.files;for(const t of n){const n=new URL(t,A).toString();this.manager.itemStart(n);const e=this.loadExtra(n).then((A=>{s[t]=A})).catch((A=>{throw this.manager.itemError(n),A})).finally((()=>{this.manager.itemEnd(n)}));g.push(e)}}}}await Promise.all(g);const e=await Ia({input:i,extraFiles:s,fileType:a,pathOrUrl:A});this.packedSplats?(this.packedSplats.initialize(e),n(this.packedSplats)):n(new oa(e))}catch(A){null==e||e(A)}}}),t,e)}async loadAsync(A,n){return new Promise(((t,e)=>{this.load(A,(A=>{t(A)}),n,e)}))}async loadExtra(A){return new Promise(((n,t)=>{this.fileLoader.load(A,(A=>n(A)),void 0,(A=>t(A)))}))}parse(A){return new Rg({packedSplats:A})}}var ea=(A=>(A.PLY="ply",A.SPZ="spz",A.SPLAT="splat",A.KSPLAT="ksplat",A.PCSOGS="pcsogs",A))(ea||{});function ia(A){const n=new DataView(A.buffer);if(7957616==(16777215&n.getUint32(0,!0)))return"ply";if(559903==(16777215&n.getUint32(0,!0))){const n=pt(A,4);return 1347635022===new DataView(n.buffer).getUint32(0,!0)?"spz":void 0}}function sa(A){const n=function(A){const n=A.split(/[?#]/,1)[0],t=Math.max(n.lastIndexOf("/"),n.lastIndexOf("\\")),e=n.slice(t+1),i=e.lastIndexOf(".");return i<=0||i===e.length-1?"":e.slice(i+1).toLowerCase()}(A);return"ply"===n?"ply":"spz"===n?"spz":"splat"===n?"splat":"ksplat"===n?"ksplat":void 0}function ga(A){return void 0!==aa(A)}function aa(A){try{let n;if("string"==typeof A)n=A;else{const t=A instanceof ArrayBuffer?new Uint8Array(A):A;if(t.length>65536)return;n=(new TextDecoder).decode(t)}const t=JSON.parse(n);if(!t||"object"!=typeof t||Array.isArray(t))return;for(const A of["means","scales","quats","sh0"]){if(!t[A]||"object"!=typeof t[A]||Array.isArray(t[A]))return;if(!t[A].shape||!t[A].files)return;if(!("quats"===A||t[A].mins&&t[A].maxs))return}return t}catch{return}}async function Ia({input:A,extraFiles:n,fileType:t,pathOrUrl:e}){const i=A instanceof ArrayBuffer?new Uint8Array(A):A;let s=t;switch(t||(s=ia(i),!s&&e&&(s=sa(e))),s){case"ply":{const A=new Yg({fileBytes:i});await A.parseHeader();const n=it(A.numSplats).maxSplats,t={fileBytes:i,packedArray:new Uint32Array(4*n)};return await na((async A=>{const{packedArray:n,numSplats:e,extra:i}=await A.call("unpackPly",t);return{packedArray:n,numSplats:e,extra:i}}))}case"spz":return await na((async A=>{const{packedArray:n,numSplats:t,extra:e}=await A.call("decodeSpz",{fileBytes:i});return{packedArray:n,numSplats:t,extra:e}}));case"splat":return await na((async A=>{const{packedArray:n,numSplats:t}=await A.call("decodeAntiSplat",{fileBytes:i});return{packedArray:n,numSplats:t}}));case"ksplat":return await na((async A=>{const{packedArray:n,numSplats:t,extra:e}=await A.call("decodeKsplat",{fileBytes:i});return{packedArray:n,numSplats:t,extra:e}}));case"pcsogs":return await na((async A=>{const{packedArray:t,numSplats:e,extra:s}=await A.call("decodePcSogs",{fileBytes:i,extraFiles:n});return{packedArray:t,numSplats:e,extra:s}}));default:throw new Error(`Unknown splat file type: ${s}`)}}class ra{constructor({maxSplats:A=1}={}){this.numSplats=0,this.maxSplats=it(A).maxSplats,this.centers=new Float32Array(3*this.maxSplats),this.scales=new Float32Array(3*this.maxSplats),this.quaternions=new Float32Array(4*this.maxSplats),this.opacities=new Float32Array(this.maxSplats),this.colors=new Float32Array(3*this.maxSplats)}pushSplat(){const A=this.numSplats;return this.ensureIndex(A),this.numSplats+=1,A}unpushSplat(A){if(A!==this.numSplats-1)throw new Error("Cannot unpush splat from non-last position");this.numSplats-=1}ensureCapacity(A){if(A>this.maxSplats){const n=Math.max(A,2*this.maxSplats),t=new Float32Array(3*n),e=new Float32Array(3*n),i=new Float32Array(4*n),s=new Float32Array(n),g=new Float32Array(3*n);if(t.set(this.centers),e.set(this.scales),i.set(this.quaternions),s.set(this.opacities),g.set(this.colors),this.centers=t,this.scales=e,this.quaternions=i,this.opacities=s,this.colors=g,this.sh1){const A=new Float32Array(9*n);A.set(this.sh1),this.sh1=A}if(this.sh2){const A=new Float32Array(15*n);A.set(this.sh2),this.sh2=A}if(this.sh3){const A=new Float32Array(21*n);A.set(this.sh3),this.sh3=A}this.maxSplats=n}}ensureIndex(A){this.ensureCapacity(A+1)}setCenter(A,n,t,e){this.centers[3*A]=n,this.centers[3*A+1]=t,this.centers[3*A+2]=e}setScale(A,n,t,e){this.scales[3*A]=n,this.scales[3*A+1]=t,this.scales[3*A+2]=e}setQuaternion(A,n,t,e,i){this.quaternions[4*A]=n,this.quaternions[4*A+1]=t,this.quaternions[4*A+2]=e,this.quaternions[4*A+3]=i}setOpacity(A,n){this.opacities[A]=n}setColor(A,n,t,e){this.colors[3*A]=n,this.colors[3*A+1]=t,this.colors[3*A+2]=e}setSh1(A,n){this.sh1||(this.sh1=new Float32Array(9*this.maxSplats));for(let t=0;t<9;++t)this.sh1[9*A+t]=n[t]}setSh2(A,n){this.sh2||(this.sh2=new Float32Array(15*this.maxSplats));for(let t=0;t<15;++t)this.sh2[15*A+t]=n[t]}setSh3(A,n){this.sh3||(this.sh3=new Float32Array(21*this.maxSplats));for(let t=0;t<21;++t)this.sh3[21*A+t]=n[t]}}const Ba=class A{constructor(A={}){this.maxSplats=0,this.numSplats=0,this.packedArray=null,this.isInitialized=!1,this.target=null,this.source=null,this.needsUpdate=!0,this.extra={},this.dyno=new Qa({packedSplats:this}),this.initialized=Promise.resolve(this),this.reinitialize(A)}reinitialize(A){this.isInitialized=!1,A.url||A.fileBytes||A.construct?this.initialized=this.asyncInitialize(A).then((()=>(this.isInitialized=!0,this))):(this.initialize(A),this.isInitialized=!0,this.initialized=Promise.resolve(this))}initialize(A){A.packedArray?(this.packedArray=A.packedArray,this.maxSplats=Math.floor(this.packedArray.length/4),this.maxSplats=Math.floor(this.maxSplats/o)*o,this.numSplats=Math.min(this.maxSplats,A.numSplats??Number.POSITIVE_INFINITY)):(this.maxSplats=A.maxSplats??0,this.numSplats=0),this.extra=A.extra??{}}async asyncInitialize(A){const{url:n,fileBytes:t,construct:e}=A;if(n){const A=new ta;A.packedSplats=this,await A.loadAsync(n)}else if(t){const e=await Ia({input:t,fileType:A.fileType,pathOrUrl:A.fileName??n});this.initialize(e)}if(e){const A=e(this);A instanceof Promise&&await A}}dispose(){this.target&&(this.target.dispose(),this.target=null),this.source&&(this.source.dispose(),this.source=null)}ensureSplats(A){const n=A<=this.maxSplats?this.maxSplats:Math.max(A,2*this.maxSplats),t=this.packedArray?this.packedArray.length/4:0;if(!this.packedArray||n>t){this.maxSplats=it(n).maxSplats;const A=new Uint32Array(4*this.maxSplats);this.packedArray&&A.set(this.packedArray),this.packedArray=A}return this.packedArray}ensureSplatsSh(A,n){let t,e;if(0===A)return this.ensureSplats(n);if(1===A)t=2,e="sh1";else if(2===A)t=4,e="sh2";else{if(3!==A)throw new Error(`Invalid level: ${A}`);t=4,e="sh3"}let i=this.extra[e]?this.extra[e].length/t:0;const s=n<=i?i:Math.max(n,2*i);if(!this.extra[e]||s>i){i=it(s).maxSplats;const A=new Uint32Array(i*t);this.extra[e]&&A.set(this.extra[e]),this.extra[e]=A}return this.extra[e]}getSplat(A){if(!this.packedArray||A>=this.numSplats)throw new Error("Invalid index");return et(this.packedArray,A)}setSplat(A,n,t,e,i,s){nt(this.ensureSplats(A+1),A,n.x,n.y,n.z,t.x,t.y,t.z,e.x,e.y,e.z,e.w,i,s.r,s.g,s.b),this.numSplats=Math.max(this.numSplats,A+1)}pushSplat(A,n,t,e,i){nt(this.ensureSplats(this.numSplats+1),this.numSplats,A.x,A.y,A.z,n.x,n.y,n.z,t.x,t.y,t.z,t.w,e,i.r,i.g,i.b),++this.numSplats}forEachSplat(A){if(this.packedArray&&this.numSplats)for(let n=0;n<this.numSplats;++n){const t=et(this.packedArray,n);A(n,t.center,t.scales,t.quaternion,t.opacity,t.color)}}ensureGenerate(A){if(this.target&&(A??1)<=this.maxSplats)return!1;this.dispose();const n=it(A??1),{width:t,height:i,depth:s}=n;return this.maxSplats=n.maxSplats,this.target=new e.WebGLArrayRenderTarget(t,i,s,{depthBuffer:!1,stencilBuffer:!1,generateMipmaps:!1,magFilter:e.NearestFilter,minFilter:e.NearestFilter}),this.target.texture.format=e.RGBAIntegerFormat,this.target.texture.type=e.UnsignedIntType,this.target.texture.internalFormat="RGBA32UI",this.target.scissorTest=!0,!0}generateMapping(A){let n=0;const t=A.map((A=>{const t=n,e=Math.ceil(A/o)*o;return n+=e,{base:t,count:A}}));return{maxSplats:n,mapping:t}}getTexture(){if(this.target)return this.target.texture;if(this.source||this.packedArray){return this.maybeUpdateSource()}return A.getEmpty()}maybeUpdateSource(){if(!this.packedArray)throw new Error("No packed splats");if(this.needsUpdate||!this.source){if(this.needsUpdate=!1,this.source){const{width:A,height:n,depth:t}=this.source.image;this.maxSplats!==A*n*t&&(this.source.dispose(),this.source=null)}if(this.source)this.packedArray.buffer!==this.source.image.data.buffer&&(this.source.image.data=new Uint8Array(this.packedArray.buffer));else{const{width:A,height:n,depth:t}=it(this.maxSplats);this.source=new e.DataArrayTexture(this.packedArray,A,n,t),this.source.format=e.RGBAIntegerFormat,this.source.type=e.UnsignedIntType,this.source.internalFormat="RGBA32UI",this.source.needsUpdate=!0}this.source.needsUpdate=!0}return this.source}static getEmpty(){if(!A.emptySource){const{width:n,height:t,depth:i,maxSplats:s}=it(1),g=new Uint32Array(4*s);A.emptySource=new e.DataArrayTexture(g,n,t,i),A.emptySource.format=e.RGBAIntegerFormat,A.emptySource.type=e.UnsignedIntType,A.emptySource.internalFormat="RGBA32UI",A.emptySource.needsUpdate=!0}return A.emptySource}prepareProgramMaterial(n){let t=A.generatorProgram.get(n);if(!t){const e=Z({index:"int"},{output:"uvec4"},(({index:A})=>{n.inputs.index=A;const t=n.outputs.gsplat;return{output:dA(t)}}));A.programTemplate||(A.programTemplate=new ft("precision highp float;\nprecision highp int;\nprecision highp sampler2D;\nprecision highp usampler2D;\nprecision highp isampler2D;\nprecision highp sampler2DArray;\nprecision highp usampler2DArray;\nprecision highp isampler2DArray;\nprecision highp sampler3D;\nprecision highp usampler3D;\nprecision highp isampler3D;\n\n#include <splatDefines>\n\nuniform uint targetLayer;\nuniform int targetBase;\nuniform int targetCount;\n\nout uvec4 target;\n\n{{ GLOBALS }}\n\nvoid produceSplat(int index) {\n    {{ STATEMENTS }}\n}\n\nvoid main() {\n    int targetIndex = int(targetLayer << SPLAT_TEX_LAYER_BITS) + int(uint(gl_FragCoord.y) << SPLAT_TEX_WIDTH_BITS) + int(gl_FragCoord.x);\n    int index = targetIndex - targetBase;\n\n    if ((index >= 0) && (index < targetCount)) {\n        produceSplat(index);\n    } else {\n        target = uvec4(0u, 0u, 0u, 0u);\n    }\n}")),t=new wt({graph:e,inputs:{index:"index"},outputs:{output:"target"},template:A.programTemplate}),Object.assign(t.uniforms,{targetLayer:{value:0},targetBase:{value:0},targetCount:{value:0}}),A.generatorProgram.set(n,t)}const e=t.prepareMaterial();return A.mesh.material=e,{program:t,material:e}}saveRenderState(A){return{xrEnabled:A.xr.enabled,autoClear:A.autoClear}}resetRenderState(A,n){A.setRenderTarget(null),A.xr.enabled=n.xrEnabled,A.autoClear=n.autoClear}generate({generator:n,base:t,count:e,renderer:i}){if(!this.target)throw new Error("Target must be initialized with ensureSplats");if(t+e>this.maxSplats)throw new Error("Base + count exceeds maxSplats");const{program:s,material:g}=this.prepareProgramMaterial(n);s.update();const a=this.saveRenderState(i),I=Math.ceil((t+e)/o)*o,r=o*Q;for(g.uniforms.targetBase.value=t,g.uniforms.targetCount.value=e;t<I;){const n=Math.floor(t/r);g.uniforms.targetLayer.value=n;const e=n*r,s=Math.floor((t-e)/o),a=Math.min(Q,Math.ceil((I-e)/o));this.target.scissor.set(0,s,o,a-s),i.setRenderTarget(this.target,n),i.xr.enabled=!1,i.autoClear=!1,i.render(A.scene,A.camera),t+=o*(a-s)}return this.resetRenderState(i,a),{nextBase:I}}};Ba.emptySource=null,Ba.programTemplate=null,Ba.generatorProgram=new Map,Ba.geometry=new e.PlaneGeometry(2,2),Ba.mesh=new e.Mesh(Ba.geometry,new e.RawShaderMaterial({visible:!1})),Ba.scene=(new e.Scene).add(Ba.mesh),Ba.camera=new e.Camera;let oa=Ba;class Qa extends fA{constructor({packedSplats:A}={}){super({key:"packedSplats",type:nA,globals:()=>[rA],value:{texture:oa.getEmpty(),numSplats:0},update:A=>{var n,t;return A.texture=(null==(n=this.packedSplats)?void 0:n.getTexture())??oa.getEmpty(),A.numSplats=(null==(t=this.packedSplats)?void 0:t.numSplats)??0,A}}),this.packedSplats=A}}class Ca extends e.InstancedBufferGeometry{constructor(A,n){super(),this.ordering=A,this.setAttribute("position",new e.BufferAttribute(Ea,3)),this.setIndex(new e.BufferAttribute(ca,1)),this._maxInstanceCount=A.length,this.instanceCount=n,this.attribute=new e.InstancedBufferAttribute(A,1,!1,1),this.attribute.setUsage(e.DynamicDrawUsage),this.setAttribute("splatIndex",this.attribute)}update(A,n){this.ordering=A,this.attribute.array=A,this.instanceCount=n,this.attribute.addUpdateRange(0,n),this.attribute.needsUpdate=!0}}const Ea=new Float32Array([-1,-1,0,1,-1,0,1,1,0,-1,1,0]),ca=new Uint16Array([0,1,2,0,2,3]),la=class A{constructor(A){if(this.lastTime=null,this.encodeLinear=!1,this.superXY=1,this.display=null,this.sorting=null,this.pending=null,this.sortingCheck=!1,this.readback=new Uint16Array(0),this.spark=A.spark,this.camera=A.camera,this.viewToWorld=A.viewToWorld??new e.Matrix4,A.target){const{width:n,height:t,doubleBuffer:i}=A.target,s=Math.max(1,Math.min(4,A.target.superXY??1));if(this.superXY=s,n*s>8192||t*s>8192)throw new Error("Target size too large");this.target=new e.WebGLRenderTarget(n*s,t*s,{format:e.RGBAFormat,type:e.UnsignedByteType,colorSpace:e.SRGBColorSpace}),i&&(this.back=new e.WebGLRenderTarget(n*s,t*s,{format:e.RGBAFormat,type:e.UnsignedByteType,colorSpace:e.SRGBColorSpace})),this.encodeLinear=!0}this.onTextureUpdated=A.onTextureUpdated,this.sortRadial=A.sortRadial??!0,this.sortDistance=A.sortDistance,this.sortCoorient=A.sortCoorient,this.depthBias=A.depthBias,this.sort360=A.sort360,this.orderingFreelist=new At({allocate:A=>new Uint32Array(A),valid:(A,n)=>A.length===n}),this.autoUpdate=!1,this.setAutoUpdate(A.autoUpdate??!1)}dispose(){var A;this.setAutoUpdate(!1),this.target&&(this.target.dispose(),this.target=void 0),this.back&&(this.back.dispose(),this.back=void 0),this.display&&(this.spark.releaseAccumulator(this.display.accumulator),this.display.geometry.dispose(),this.display=null),(null==(A=this.pending)?void 0:A.accumulator)&&(this.spark.releaseAccumulator(this.pending.accumulator),this.pending=null)}setAutoUpdate(A){!this.autoUpdate&&A?this.spark.autoViewpoints.push(this):this.autoUpdate&&!A&&(this.spark.autoViewpoints=this.spark.autoViewpoints.filter((A=>A!==this))),this.autoUpdate=A}async prepare({scene:A,camera:n,viewToWorld:t,update:e,forceOrigin:i}){var s;for(t?this.viewToWorld=t:(this.camera=n??this.camera,this.camera&&(this.camera.updateMatrixWorld(),this.viewToWorld=this.camera.matrixWorld.clone()));e??1;){const n=i?this.viewToWorld:void 0;if(this.spark.updateInternal({scene:A,originToWorld:n}))break;await new Promise((A=>setTimeout(A,10)))}const g=this.spark.active;g!==(null==(s=this.display)?void 0:s.accumulator)&&(this.spark.active.refCount+=1),await this.sortUpdate({accumulator:g,viewToWorld:this.viewToWorld})}renderTarget({scene:A,camera:n}){var t;const i=this.back??this.target;if(!i)throw new Error("Must initialize SparkViewpoint with target");if(!(n=n??this.camera))throw new Error("Must provide camera");if(n instanceof e.PerspectiveCamera){const A=(new e.PerspectiveCamera).copy(n,!1);A.aspect=i.width/i.height,A.updateProjectionMatrix(),n=A}this.viewToWorld=n.matrixWorld.clone();try{this.spark.renderer.setRenderTarget(i),this.spark.prepareViewpoint(this),this.spark.renderer.render(A,n)}finally{this.spark.prepareViewpoint(this.spark.defaultView),this.spark.renderer.setRenderTarget(null)}i!==this.target&&([this.target,this.back]=[this.back,this.target]),null==(t=this.onTextureUpdated)||t.call(this,i.texture)}async readTarget(){if(!this.target)throw new Error("Must initialize SparkViewpoint with target");const{width:A,height:n}=this.target,t=A*n*4;(!this.superPixels||this.superPixels.length<t)&&(this.superPixels=new Uint8Array(t)),await this.spark.renderer.readRenderTargetPixelsAsync(this.target,0,0,A,n,this.superPixels);const{superXY:e}=this;if(1===e)return this.superPixels;const i=A/e,s=n/e,g=i*s*4;(!this.pixels||this.pixels.length<g)&&(this.pixels=new Uint8Array(g));const{superPixels:a,pixels:I}=this,r=e*e;for(let A=0;A<s;A++){const n=A*i;for(let t=0;t<i;t++){const i=t*e;let s=0,g=0,B=0,o=0;for(let n=0;n<e;n++){const t=(A*e+n)*this.target.width;for(let A=0;A<e;A++){const n=4*(t+i+A);s+=a[n],g+=a[n+1],B+=a[n+2],o+=a[n+3]}}const Q=4*(n+t);I[Q]=s/r,I[Q+1]=g/r,I[Q+2]=B/r,I[Q+3]=o/r}}return I}async prepareRenderPixels({scene:A,camera:n,viewToWorld:t,update:e,forceOrigin:i}){return await this.prepare({scene:A,camera:n,viewToWorld:t,update:e,forceOrigin:i}),this.renderTarget({scene:A,camera:n}),this.readTarget()}autoPoll({accumulator:A}){var n,t,e,i;this.camera&&(this.camera.updateMatrixWorld(),this.viewToWorld=this.camera.matrixWorld.clone());let s=!1,g=!1;if(this.display){if(A){s=!0;const{mappingVersion:n}=this.display.accumulator;A.mappingVersion===n&&(this.spark.releaseAccumulator(this.display.accumulator),this.display.accumulator=A,g=!0)}}else s=!0;const a=(null==(n=this.sorting)?void 0:n.viewToWorld)??(null==(t=this.display)?void 0:t.viewToWorld);a&&!lt({matrix1:this.viewToWorld,matrix2:a,maxDistance:this.sortDistance??.01,minCoorient:this.sortCoorient??this.sortRadial?.99:.999})&&(s=!0),s&&(A&&(A.refCount+=1),A&&(null==(e=this.pending)?void 0:e.accumulator)&&this.pending.accumulator!==(null==(i=this.display)?void 0:i.accumulator)&&this.spark.releaseAccumulator(this.pending.accumulator),this.pending={accumulator:A,viewToWorld:this.viewToWorld,displayed:g},this.driveSort())}async driveSort(){for(var A;;){if(this.sorting||!this.pending)return;const{viewToWorld:n,displayed:t}=this.pending;let e=this.pending.accumulator??(null==(A=this.display)?void 0:A.accumulator);if(e||(e=this.spark.active,e.refCount+=1),this.pending=null,!e)throw new Error("No accumulator to sort");this.sorting={viewToWorld:n},await this.sortUpdate({accumulator:e,viewToWorld:n,displayed:t}),this.sorting=null}}async sortUpdate({accumulator:n,viewToWorld:t,displayed:e=!1}){if(this.sortingCheck)throw new Error("Only one sort at a time");this.sortingCheck=!0,n=n??this.spark.active;const{numSplats:i,maxSplats:s}=n.splats;let g=0,a=this.orderingFreelist.alloc(s);if(i>0){const{reader:e,doubleSortReader:I,dynoSortRadial:r,dynoOrigin:B,dynoDirection:o,dynoDepthBias:Q,dynoSort360:C,dynoSplats:E}=A.makeSorter(),c=Math.ceil(s/2);this.readback=e.ensureBuffer(c,this.readback);const l=n.toWorld.clone().invert(),h=t.clone().premultiply(l);r.value=!!this.sort360||this.sortRadial,B.value.set(0,0,0).applyMatrix4(h),o.value.set(0,0,-1).applyMatrix4(h).sub(B.value).normalize(),Q.value=this.depthBias??1,C.value=this.sort360??!1,E.packedSplats=n.splats,await e.renderReadback({renderer:this.spark.renderer,reader:I,count:Math.ceil(i/2),readback:this.readback});const u=await na((async A=>A.call("sortDoubleSplats",{numSplats:i,readback:this.readback,ordering:a})));this.readback=u.readback,a=u.ordering,g=u.activeSplats}this.updateDisplay({accumulator:n,viewToWorld:t,ordering:a,activeSplats:g,displayed:e}),this.sortingCheck=!1}updateDisplay({accumulator:A,viewToWorld:n,ordering:t,activeSplats:e,displayed:i=!1}){if(this.display){i||A===this.display.accumulator||(this.spark.releaseAccumulator(this.display.accumulator),this.display.accumulator=A),this.display.viewToWorld=n;const s=this.display.geometry.ordering;s.length===t.length?this.display.geometry.update(t,e):(this.display.geometry.dispose(),this.display.geometry=new Ca(t,e)),this.orderingFreelist.free(s)}else this.display={accumulator:A,viewToWorld:n,geometry:new Ca(t,e)};this.spark.viewpoint===this&&this.spark.prepareViewpoint(this)}static makeSorter(){if(!A.dynos){const n=new mA({value:!0}),t=new vA({value:new e.Vector3}),i=new vA({value:new e.Vector3}),s=new FA({value:1}),g=new mA({value:!1}),a=new Qa,I=new Qg,r=Z({index:"int"},{rgba8:"vec4"},(({index:A})=>{if(!A)throw new Error("No index");const e={sortRadial:n,sortOrigin:t,sortDirection:i,sortDepthBias:s,sort360:g},I=ie(A,H("int",2)),r=da({gsplat:tA(a,I),...e}),B=da({gsplat:tA(a,te(I,H("int",1))),...e}),o=Wi({vectorType:"vec2",x:r,y:B});return{rgba8:Ei(Ci(o))}}));A.dynos={dynoSortRadial:n,dynoOrigin:t,dynoDirection:i,dynoDepthBias:s,dynoSort360:g,dynoSplats:a,reader:I,doubleSortReader:r}}return A.dynos}};la.EMPTY_TEXTURE=new e.Texture,la.dynos=null;let ha=la;const ua=V("\n  float computeSort(Gsplat gsplat, bool sortRadial, vec3 sortOrigin, vec3 sortDirection, float sortDepthBias, bool sort360) {\n    if (!isGsplatActive(gsplat.flags)) {\n      return INFINITY;\n    }\n\n    vec3 center = gsplat.center - sortOrigin;\n    float biasedDepth = dot(center, sortDirection) + sortDepthBias;\n    if (!sort360 && (biasedDepth <= 0.0)) {\n      return INFINITY;\n    }\n\n    return sortRadial ? length(center) : biasedDepth;\n  }\n");function da({gsplat:A,sortRadial:n,sortOrigin:t,sortDirection:e,sortDepthBias:i,sort360:s}){return P({inTypes:{gsplat:AA,sortRadial:"bool",sortOrigin:"vec3",sortDirection:"vec3",sortDepthBias:"float",sort360:"bool"},outTypes:{metric:"float"},globals:()=>[IA,ua],inputs:{gsplat:A,sortRadial:n,sortOrigin:t,sortDirection:e,sortDepthBias:i,sort360:s},statements:({inputs:A,outputs:n})=>{const{gsplat:t,sortRadial:e,sortOrigin:i,sortDirection:s,sortDepthBias:g,sort360:a}=A;return W(`\n        ${n.metric} = computeSort(${t}, ${e}, ${i}, ${s}, ${g}, ${a});\n      `)}}).outputs.metric}class pa{constructor(){this.splats=new oa,this.toWorld=new e.Matrix4,this.mapping=[],this.refCount=0,this.splatsVersion=-1,this.mappingVersion=-1}ensureGenerate(A){this.splats.ensureGenerate(A)&&(this.mapping=[])}generateSplats({renderer:A,modifier:n,generators:t,forceUpdate:e,originToWorld:i}){const s=this.mapping.reduce(((A,n)=>(A.set(n.node,n),A)),new Map);let g=0,a=0;for(const{node:i,generator:I,version:r,base:B,count:o}of t){const t=s.get(i);if((e||I!==(null==t?void 0:t.generator)||r!==(null==t?void 0:t.version)||B!==(null==t?void 0:t.base)||o!==(null==t?void 0:t.count))&&I&&o>0){const t=n.apply(I);try{this.splats.generate({generator:t,base:B,count:o,renderer:A})}catch(A){i.generator=void 0,i.generatorError=A}g+=1}a=Math.max(a,B+o)}return this.splats.numSplats=a,this.toWorld=i,this.mapping=t,0!==g}hasCorrespondence(A){return this.mapping.length===A.mapping.length&&this.mapping.every((({node:n,base:t,count:e},i)=>{const{node:s,base:g,count:a}=A.mapping[i];return n===s&&t===g&&e===a}))}}let ya=null;let Da,wa=!1,fa=!1;const ma=e.Scene.prototype.add;e.Scene.prototype.add=function(A){return wa=wa||function(A){let n=!1;return A instanceof Rg||(A.traverse((A=>{n=n||A instanceof Rg})),n)}(A),fa=fa||A instanceof Fa,ma.call(this,A),this};const Sa=e.Scene.prototype.onBeforeRender;e.Scene.prototype.onBeforeRender=function(A){if(wa){if(!fa){const n=Da||new Fa({renderer:A});this.add(n)}e.Scene.prototype.onBeforeRender=Sa,e.Scene.prototype.add=ma}};const xa=class A extends e.Mesh{constructor(n){const t=A.makeUniforms(),i=(ya||(e.ShaderChunk.splatDefines="const float LN_SCALE_MIN = -9.0;\nconst float LN_SCALE_MAX = 9.0;\nconst float LN_RESCALE = (LN_SCALE_MAX - LN_SCALE_MIN) / 254.0; \n\nconst uint SPLAT_TEX_WIDTH_BITS = 11u;\nconst uint SPLAT_TEX_HEIGHT_BITS = 11u;\nconst uint SPLAT_TEX_DEPTH_BITS = 11u;\nconst uint SPLAT_TEX_LAYER_BITS = SPLAT_TEX_WIDTH_BITS + SPLAT_TEX_HEIGHT_BITS;\n\nconst uint SPLAT_TEX_WIDTH = 1u << SPLAT_TEX_WIDTH_BITS;\nconst uint SPLAT_TEX_HEIGHT = 1u << SPLAT_TEX_HEIGHT_BITS;\nconst uint SPLAT_TEX_DEPTH = 1u << SPLAT_TEX_DEPTH_BITS;\n\nconst uint SPLAT_TEX_WIDTH_MASK = SPLAT_TEX_WIDTH - 1u;\nconst uint SPLAT_TEX_HEIGHT_MASK = SPLAT_TEX_HEIGHT - 1u;\nconst uint SPLAT_TEX_DEPTH_MASK = SPLAT_TEX_DEPTH - 1u;\n\nconst uint F16_INF = 0x7c00u;\nconst float PI = 3.1415926535897932384626433832795;\n\nconst float INFINITY = 1.0 / 0.0;\nconst float NEG_INFINITY = -INFINITY;\n\nconst float MAX_PIXEL_RADIUS = 512.0;\nconst float MIN_ALPHA = 0.5 * (1.0 / 255.0); \nconst float MAX_STDDEV = sqrt(8.0);\n\nfloat sqr(float x) {\n    return x * x;\n}\n\nfloat pow4(float x) {\n    float x2 = x * x;\n    return x2 * x2;\n}\n\nfloat pow8(float x) {\n    float x4 = pow4(x);\n    return x4 * x4;\n}\n\nvec3 srgbToLinear(vec3 rgb) {\n    return pow(rgb, vec3(2.2));\n}\n\nvec3 linearToSrgb(vec3 rgb) {\n    return pow(rgb, vec3(1.0 / 2.2));\n}\n\nuint encodeQuatOctXy88R8(vec4 q) {\n    \n    if (q.w < 0.0) {\n        q = -q;\n    }\n    \n    float theta = 2.0 * acos(q.w);\n    float halfTheta = theta * 0.5;\n    float s = sin(halfTheta);\n    \n    vec3 axis = (abs(s) < 1e-6) ? vec3(1.0, 0.0, 0.0) : q.xyz / s;\n    \n    \n    \n    float sum = abs(axis.x) + abs(axis.y) + abs(axis.z);\n    vec2 p = vec2(axis.x, axis.y) / sum;\n    \n    if (axis.z < 0.0) {\n        float oldPx = p.x;\n        p.x = (1.0 - abs(p.y)) * (p.x >= 0.0 ? 1.0 : -1.0);\n        p.y = (1.0 - abs(oldPx)) * (p.y >= 0.0 ? 1.0 : -1.0);\n    }\n    \n    float u_f = p.x * 0.5 + 0.5;\n    float v_f = p.y * 0.5 + 0.5;\n    \n    uint quantU = uint(clamp(round(u_f * 255.0), 0.0, 255.0));\n    uint quantV = uint(clamp(round(v_f * 255.0), 0.0, 255.0));\n    \n    \n    \n    uint angleInt = uint(clamp(round((theta / 3.14159265359) * 255.0), 0.0, 255.0));\n    \n    \n    return (angleInt << 16u) | (quantV << 8u) | quantU;\n}\n\nvec4 decodeQuatOctXy88R8(uint encoded) {\n    \n    uint quantU = encoded & uint(0xFFu);               \n    uint quantV = (encoded >> 8u) & uint(0xFFu);         \n    uint angleInt = encoded >> 16u;                      \n\n    \n    float u_f = float(quantU) / 255.0;\n    float v_f = float(quantV) / 255.0;\n    vec2 f = vec2(u_f * 2.0 - 1.0, v_f * 2.0 - 1.0);\n\n    vec3 axis = vec3(f.xy, 1.0 - abs(f.x) - abs(f.y));\n    float t = max(-axis.z, 0.0);\n    axis.x += (axis.x >= 0.0) ? -t : t;\n    axis.y += (axis.y >= 0.0) ? -t : t;\n    axis = normalize(axis);\n    \n    \n    float theta = (float(angleInt) / 255.0) * 3.14159265359;\n    float halfTheta = theta * 0.5;\n    float s = sin(halfTheta);\n    float w = cos(halfTheta);\n    \n    return vec4(axis * s, w);\n}\n\n    \n\n    \n\n    \n\n    \n\n    \n\n    \n\n    \n\n    \n\n    \n\n    \n\nuvec4 packSplat(vec3 center, vec3 scales, vec4 quaternion, vec4 rgba) {\n    uvec4 uRgba = uvec4(round(clamp(rgba * 255.0, 0.0, 255.0)));\n\n    uint uQuat = encodeQuatOctXy88R8(quaternion);\n    \n    \n    uvec3 uQuat3 = uvec3(uQuat & 0xffu, (uQuat >> 8u) & 0xffu, (uQuat >> 16u) & 0xffu);\n\n    \n    uvec3 uScales = uvec3(\n        (scales.x == 0.0) ? 0u : uint(round(clamp((log(scales.x) - LN_SCALE_MIN) / LN_RESCALE, 0.0, 254.0))) + 1u,\n        (scales.y == 0.0) ? 0u : uint(round(clamp((log(scales.y) - LN_SCALE_MIN) / LN_RESCALE, 0.0, 254.0))) + 1u,\n        (scales.z == 0.0) ? 0u : uint(round(clamp((log(scales.z) - LN_SCALE_MIN) / LN_RESCALE, 0.0, 254.0))) + 1u\n    );\n\n    \n    uint word0 = uRgba.r | (uRgba.g << 8u) | (uRgba.b << 16u) | (uRgba.a << 24u);\n    uint word1 = packHalf2x16(center.xy);\n    uint word2 = packHalf2x16(vec2(center.z, 0.0)) | (uQuat3.x << 16u) | (uQuat3.y << 24u);\n    uint word3 = uScales.x | (uScales.y << 8u) | (uScales.z << 16u) | (uQuat3.z << 24u);\n    return uvec4(word0, word1, word2, word3);\n}\n\nvoid unpackSplat(uvec4 packed, out vec3 center, out vec3 scales, out vec4 quaternion, out vec4 rgba) {\n    uint word0 = packed.x, word1 = packed.y, word2 = packed.z, word3 = packed.w;\n\n    uvec4 uRgba = uvec4(word0 & 0xffu, (word0 >> 8u) & 0xffu, (word0 >> 16u) & 0xffu, (word0 >> 24u) & 0xffu);\n    rgba = vec4(uRgba) / 255.0;\n\n    center = vec4(\n        unpackHalf2x16(word1),\n        unpackHalf2x16(word2 & 0xffffu)\n    ).xyz;\n\n    uvec3 uScales = uvec3(word3 & 0xffu, (word3 >> 8u) & 0xffu, (word3 >> 16u) & 0xffu);\n    scales = vec3(\n        (uScales.x == 0u) ? 0.0 : exp(LN_SCALE_MIN + float(uScales.x - 1u) * LN_RESCALE),\n        (uScales.y == 0u) ? 0.0 : exp(LN_SCALE_MIN + float(uScales.y - 1u) * LN_RESCALE),\n        (uScales.z == 0u) ? 0.0 : exp(LN_SCALE_MIN + float(uScales.z - 1u) * LN_RESCALE)\n    );\n\n    uint uQuat = ((word2 >> 16u) & 0xFFFFu) | ((word3 >> 8u) & 0xFF0000u);\n    quaternion = decodeQuatOctXy88R8(uQuat);\n    \n    \n}\n\nvec3 quatVec(vec4 q, vec3 v) {\n    \n    vec3 t = 2.0 * cross(q.xyz, v);\n    return v + q.w * t + cross(q.xyz, t);\n}\n\nvec4 quatQuat(vec4 q1, vec4 q2) {\n    return vec4(\n        q1.w * q2.x + q1.x * q2.w + q1.y * q2.z - q1.z * q2.y,\n        q1.w * q2.y - q1.x * q2.z + q1.y * q2.w + q1.z * q2.x,\n        q1.w * q2.z + q1.x * q2.y - q1.y * q2.x + q1.z * q2.w,\n        q1.w * q2.w - q1.x * q2.x - q1.y * q2.y - q1.z * q2.z\n    );\n}\n\nmat3 scaleQuaternionToMatrix(vec3 s, vec4 q) {\n    \n    return mat3(\n        s.x * (1.0 - 2.0 * (q.y * q.y + q.z * q.z)),\n        s.x * (2.0 * (q.x * q.y + q.w * q.z)),\n        s.x * (2.0 * (q.x * q.z - q.w * q.y)),\n        s.y * (2.0 * (q.x * q.y - q.w * q.z)),\n        s.y * (1.0 - 2.0 * (q.x * q.x + q.z * q.z)),\n        s.y * (2.0 * (q.y * q.z + q.w * q.x)),\n        s.z * (2.0 * (q.x * q.z + q.w * q.y)),\n        s.z * (2.0 * (q.y * q.z - q.w * q.x)),\n        s.z * (1.0 - 2.0 * (q.x * q.x + q.y * q.y))\n    );\n}\n\nvec4 slerp(vec4 q1, vec4 q2, float t) {\n    \n    float cosHalfTheta = dot(q1, q2);\n\n    \n    if (abs(cosHalfTheta) >= 0.999) {\n        return q1;\n    }\n    \n    \n    \n    if (cosHalfTheta < 0.0) {\n        q2 = -q2;\n        cosHalfTheta = -cosHalfTheta;\n    }\n\n    \n    float halfTheta = acos(cosHalfTheta);\n    float sinHalfTheta = sqrt(1.0 - cosHalfTheta * cosHalfTheta);\n\n    \n    float ratioA = sin((1.0 - t) * halfTheta) / sinHalfTheta;\n    float ratioB = sin(t * halfTheta) / sinHalfTheta;\n\n    \n    return q1 * ratioA + q2 * ratioB;\n}\n\nivec3 splatTexCoord(int index) {\n    uint x = uint(index) & SPLAT_TEX_WIDTH_MASK;\n    uint y = (uint(index) >> SPLAT_TEX_WIDTH_BITS) & SPLAT_TEX_HEIGHT_MASK;\n    uint z = uint(index) >> SPLAT_TEX_LAYER_BITS;\n    return ivec3(x, y, z);\n}",ya={splatVertex:"precision highp float;\nprecision highp int;\nprecision highp usampler2DArray;\n\n#include <splatDefines>\n\nattribute uint splatIndex;\n\nout vec4 vRgba;\nout vec2 vSplatUv;\nout vec3 vNdc;\n\nuniform vec2 renderSize;\nuniform uint numSplats;\nuniform vec4 renderToViewQuat;\nuniform vec3 renderToViewPos;\nuniform float maxStdDev;\nuniform float time;\nuniform float deltaTime;\nuniform bool debugFlag;\nuniform bool enable2DGS;\nuniform float blurAmount;\nuniform float preBlurAmount;\nuniform float focalDistance;\nuniform float apertureAngle;\nuniform float clipXY;\nuniform float renderScale;\n\nuniform usampler2DArray packedSplats;\n\nvoid main() {\n    \n    gl_Position = vec4(0.0, 0.0, 2.0, 1.0);\n\n    if (uint(gl_InstanceID) >= numSplats) {\n        return;\n    }\n    if (splatIndex == 0xffffffffu) {\n        \n        return;\n    }\n\n    ivec3 texCoord = ivec3(\n        splatIndex & SPLAT_TEX_WIDTH_MASK,\n        (splatIndex >> SPLAT_TEX_WIDTH_BITS) & SPLAT_TEX_HEIGHT_MASK,\n        splatIndex >> SPLAT_TEX_LAYER_BITS\n    );\n    uvec4 packed = texelFetch(packedSplats, texCoord, 0);\n\n    vec3 center, scales;\n    vec4 quaternion, rgba;\n    unpackSplat(packed, center, scales, quaternion, rgba);\n\n    if (rgba.a < MIN_ALPHA) {\n        return;\n    }\n    bvec3 zeroScales = equal(scales, vec3(0.0));\n    if (all(zeroScales)) {\n        return;\n    }\n\n    \n    vec3 viewCenter = quatVec(renderToViewQuat, center) + renderToViewPos;\n\n    \n    if (viewCenter.z >= 0.0) {\n        return;\n    }\n\n    \n    vec4 clipCenter = projectionMatrix * vec4(viewCenter, 1.0);\n\n    \n    if (abs(clipCenter.z) >= clipCenter.w) {\n        return;\n    }\n\n    \n    float clip = clipXY * clipCenter.w;\n    if (abs(clipCenter.x) > clip || abs(clipCenter.y) > clip) {\n        return;\n    }\n\n    \n    vec4 viewQuaternion = quatQuat(renderToViewQuat, quaternion);\n\n    if (enable2DGS && any(zeroScales)) {\n        vRgba = rgba;\n        vSplatUv = position.xy * maxStdDev;\n\n        vec3 offset;\n        if (zeroScales.z) {\n            offset = vec3(vSplatUv.xy * scales.xy, 0.0);\n        } else if (zeroScales.y) {\n            offset = vec3(vSplatUv.x * scales.x, 0.0, vSplatUv.y * scales.z);\n        } else {\n            offset = vec3(0.0, vSplatUv.xy * scales.yz);\n        }\n\n        vec3 viewPos = viewCenter + quatVec(viewQuaternion, offset);\n        gl_Position = projectionMatrix * vec4(viewPos, 1.0);\n        vNdc = gl_Position.xyz / gl_Position.w;\n        return;\n    }\n\n    \n    vec3 ndcCenter = clipCenter.xyz / clipCenter.w;\n\n    \n    mat3 RS = scaleQuaternionToMatrix(scales, viewQuaternion);\n    mat3 cov3D = RS * transpose(RS);\n\n    \n    vec2 scaledRenderSize = renderSize * renderScale;\n    vec2 focal = 0.5 * scaledRenderSize * vec2(projectionMatrix[0][0], projectionMatrix[1][1]);\n    float invZ = 1.0 / viewCenter.z;\n    vec2 J1 = focal * invZ;\n    vec2 J2 = -(J1 * viewCenter.xy) * invZ;\n    mat3 J = mat3(\n        J1.x, 0.0, J2.x,\n        0.0, J1.y, J2.y,\n        0.0, 0.0, 0.0\n    );\n\n    \n    \n    \n    \n    \n    \n    \n    mat3 cov2D = transpose(J) * cov3D * J;\n    float a = cov2D[0][0];\n    float d = cov2D[1][1];\n    float b = cov2D[0][1];\n\n    \n    a += preBlurAmount;\n    d += preBlurAmount;\n\n    float fullBlurAmount = blurAmount;\n    if ((focalDistance > 0.0) && (apertureAngle > 0.0)) {\n        float focusRadius = MAX_PIXEL_RADIUS;\n        if (viewCenter.z < 0.0) {\n            float focusBlur = abs((-viewCenter.z - focalDistance) / viewCenter.z);\n            float apertureRadius = focal.x * tan(0.5 * apertureAngle);\n            focusRadius = focusBlur * apertureRadius;\n        }\n        fullBlurAmount = clamp(sqr(focusRadius), blurAmount, sqr(MAX_PIXEL_RADIUS));\n    }\n\n    \n    float detOrig = a * d - b * b;\n    a += fullBlurAmount;\n    d += fullBlurAmount;\n    float det = a * d - b * b;\n\n    \n    float blurAdjust = sqrt(max(0.0, detOrig / det));\n    rgba.a *= blurAdjust;\n    if (rgba.a < MIN_ALPHA) {\n        return;\n    }\n\n    \n    float eigenAvg = 0.5 * (a + d);\n    float eigenDelta = sqrt(max(0.0, eigenAvg * eigenAvg - det));\n    float eigen1 = eigenAvg + eigenDelta;\n    float eigen2 = eigenAvg - eigenDelta;\n\n    vec2 eigenVec1 = normalize(vec2((abs(b) < 0.001) ? 1.0 : b, eigen1 - a));\n    vec2 eigenVec2 = vec2(eigenVec1.y, -eigenVec1.x);\n\n    float scale1 = position.x * min(MAX_PIXEL_RADIUS, maxStdDev * sqrt(eigen1));\n    float scale2 = position.y * min(MAX_PIXEL_RADIUS, maxStdDev * sqrt(eigen2));\n\n    \n    vec2 pixelOffset = eigenVec1 * scale1 + eigenVec2 * scale2;\n    vec2 ndcOffset = (2.0 / scaledRenderSize) * pixelOffset;\n    vec3 ndc = vec3(ndcCenter.xy + ndcOffset, ndcCenter.z);\n\n    vRgba = rgba;\n    vSplatUv = position.xy * maxStdDev;\n    vNdc = ndc;\n    gl_Position = vec4(ndc.xy * clipCenter.w, clipCenter.zw);\n}",splatFragment:"precision highp float;\nprecision highp int;\n\n#include <splatDefines>\n\nuniform float near;\nuniform float far;\nuniform bool encodeLinear;\nuniform float maxStdDev;\nuniform bool disableFalloff;\nuniform float falloff;\n\nuniform bool splatTexEnable;\nuniform sampler3D splatTexture;\nuniform mat2 splatTexMul;\nuniform vec2 splatTexAdd;\nuniform float splatTexNear;\nuniform float splatTexFar;\nuniform float splatTexMid;\n\nout vec4 fragColor;\n\nin vec4 vRgba;\nin vec2 vSplatUv;\nin vec3 vNdc;\n\nvoid main() {\n    vec4 rgba = vRgba;\n\n    float z = dot(vSplatUv, vSplatUv);\n    if (!splatTexEnable) {\n        if (z > (maxStdDev * maxStdDev)) {\n            discard;\n        }\n    } else {\n        vec2 uv = splatTexMul * vSplatUv + splatTexAdd;\n        float ndcZ = vNdc.z;\n        float depth = (2.0 * near * far) / (far + near - ndcZ * (far - near));\n        float clampedFar = max(splatTexFar, splatTexNear);\n        float clampedDepth = clamp(depth, splatTexNear, clampedFar);\n        float logDepth = log2(clampedDepth + 1.0);\n        float logNear = log2(splatTexNear + 1.0);\n        float logFar = log2(clampedFar + 1.0);\n\n        float texZ;\n        if (splatTexMid > 0.0) {\n            float clampedMid = clamp(splatTexMid, splatTexNear, clampedFar);\n            float logMid = log2(clampedMid + 1.0);\n            texZ = (clampedDepth <= clampedMid) ?\n                (0.5 * ((logDepth - logNear) / (logMid - logNear))) :\n                (0.5 * ((logDepth - logMid) / (logFar - logMid)) + 0.5);\n        } else {\n            texZ = (logDepth - logNear) / (logFar - logNear);\n        }\n\n        vec4 modulate = texture(splatTexture, vec3(uv, 1.0 - texZ));\n        rgba *= modulate;\n    }\n\n    rgba.a *= mix(1.0, exp(-0.5 * z), falloff);\n\n    if (rgba.a < MIN_ALPHA) {\n        discard;\n    }\n    if (encodeLinear) {\n        rgba.rgb = srgbToLinear(rgba.rgb);\n    }\n    fragColor = rgba;\n}"}),ya),s=new e.ShaderMaterial({glslVersion:e.GLSL3,vertexShader:i.splatVertex,fragmentShader:i.splatFragment,uniforms:t,transparent:!0,blending:e.NormalBlending,depthTest:!0,depthWrite:!1,side:e.DoubleSide});super(Ga,s),this.renderScale=1,this.splatTexture=null,this.autoViewpoints=[],this.rotateToAccumulator=new HA({value:new e.Quaternion}),this.translateToAccumulator=new vA({value:new e.Vector3}),this.lastFrame=-1,this.lastUpdateTime=null,this.defaultCameras=[],this.pendingUpdate=null,this.envViewpoint=null,this.frustumCulled=!1,this.renderer=n.renderer,this.material=s,this.uniforms=t;const g=Z({gsplat:AA},{gsplat:AA},(({gsplat:A})=>{if(!A)throw new Error("gsplat not defined");return{gsplat:A=aA(A,{rotate:this.rotateToAccumulator,translate:this.translateToAccumulator})}}));this.modifier=new Gg(g),this.autoUpdate=n.autoUpdate??!0,this.preUpdate=n.preUpdate??!1,this.originDistance=n.originDistance??1,this.maxStdDev=n.maxStdDev??Math.sqrt(8),this.enable2DGS=n.enable2DGS??!1,this.preBlurAmount=n.preBlurAmount??0,this.blurAmount=n.blurAmount??.3,this.focalDistance=n.focalDistance??0,this.apertureAngle=n.apertureAngle??0,this.falloff=n.falloff??1,this.clipXY=n.clipXY??1.4,this.active=new pa,this.accumulatorCount=1,this.freeAccumulators=[];for(let A=0;A<1;++A)this.freeAccumulators.push(new pa),this.accumulatorCount+=1;this.defaultView=new ha({...n.view,autoUpdate:!0,spark:this}),this.viewpoint=this.defaultView,this.prepareViewpoint(this.viewpoint),this.clock=n.clock?Bt(n.clock):new e.Clock,Da=this}static makeUniforms(){return{renderSize:{value:new e.Vector2},near:{value:.1},far:{value:1e3},numSplats:{value:0},renderToViewQuat:{value:new e.Quaternion},renderToViewPos:{value:new e.Vector3},maxStdDev:{value:1},enable2DGS:{value:!1},preBlurAmount:{value:0},blurAmount:{value:.3},focalDistance:{value:0},apertureAngle:{value:0},falloff:{value:1},clipXY:{value:1.4},renderScale:{value:1},splatTexEnable:{value:!1},splatTexture:{type:"t",value:A.EMPTY_SPLAT_TEXTURE},splatTexMul:{value:new e.Matrix2},splatTexAdd:{value:new e.Vector2},splatTexNear:{value:.1},splatTexFar:{value:1e3},splatTexMid:{value:0},packedSplats:{type:"t",value:oa.getEmpty()},time:{value:0},deltaTime:{value:0},encodeLinear:{value:!1},debugFlag:{value:!1}}}canAllocAccumulator(){return this.freeAccumulators.length>0||this.accumulatorCount<5}maybeAllocAccumulator(){let A=this.freeAccumulators.pop();if(void 0===A){if(this.accumulatorCount>=5)return null;A=new pa,this.accumulatorCount+=1}return A.refCount=1,A}releaseAccumulator(A){A.refCount-=1,0===A.refCount&&this.freeAccumulators.push(A)}newViewpoint(A){return new ha({...A,spark:this})}onBeforeRender(n,t,i){var s,g;const a=this.time??this.clock.getElapsedTime(),I=a-(this.viewpoint.lastTime??a);this.viewpoint.lastTime=a;const r=n.info.render.frame,B=r!==this.lastFrame;this.lastFrame=r;const o=this.viewpoint;if(o===this.defaultView){if(B)if(n.xr.isPresenting){const A=n.xr.getCamera().cameras;this.defaultCameras=A.map((A=>A.matrixWorld)),this.defaultView.viewToWorld=function(A){if(0===A.length)return null;const n=new e.Vector3,t=new e.Quaternion,i=new e.Vector3,s=[],g=[];for(const e of A)e.decompose(n,t,i),s.push(n),g.push(t);return(new e.Matrix4).compose(Qt(s),Ct(g),new e.Vector3(1,1,1))}(this.defaultCameras)??new e.Matrix4}else this.defaultView.viewToWorld=i.matrixWorld.clone(),this.defaultCameras=[this.defaultView.viewToWorld];this.autoUpdate&&this.update({scene:t,viewToWorld:this.defaultView.viewToWorld})}if(B&&(this.uniforms.time.value=a,this.uniforms.deltaTime.value=I,this.uniforms.debugFlag.value=performance.now()/1e3%2<1),o.target)this.uniforms.renderSize.value.set(o.target.width,o.target.height);else{const A=n.getDrawingBufferSize(this.uniforms.renderSize.value);if(1===A.x&&1===A.y){const t=null==(s=n.xr.getSession())?void 0:s.renderState.baseLayer;t&&(A.x=t.framebufferWidth,A.y=t.framebufferHeight)}}const Q=i;if(this.uniforms.near.value=Q.near,this.uniforms.far.value=Q.far,this.uniforms.encodeLinear.value=o.encodeLinear,this.uniforms.maxStdDev.value=this.maxStdDev,this.uniforms.enable2DGS.value=this.enable2DGS,this.uniforms.preBlurAmount.value=this.preBlurAmount,this.uniforms.blurAmount.value=this.blurAmount,this.uniforms.focalDistance.value=this.focalDistance,this.uniforms.apertureAngle.value=this.apertureAngle,this.uniforms.falloff.value=this.falloff,this.uniforms.clipXY.value=this.clipXY,this.uniforms.renderScale.value=this.renderScale,this.splatTexture){const{enable:n,texture:t,multiply:e,add:i,near:s,far:g,mid:a}=this.splatTexture;n&&t?(this.uniforms.splatTexEnable.value=!0,this.uniforms.splatTexture.value=t,e?this.uniforms.splatTexMul.value.fromArray(e.elements):this.uniforms.splatTexMul.value.set(.5/this.maxStdDev,0,0,.5/this.maxStdDev),this.uniforms.splatTexAdd.value.set((null==i?void 0:i.x)??.5,(null==i?void 0:i.y)??.5),this.uniforms.splatTexNear.value=s??this.uniforms.near.value,this.uniforms.splatTexFar.value=g??this.uniforms.far.value,this.uniforms.splatTexMid.value=a??0):(this.uniforms.splatTexEnable.value=!1,this.uniforms.splatTexture.value=A.EMPTY_SPLAT_TEXTURE)}else this.uniforms.splatTexEnable.value=!1,this.uniforms.splatTexture.value=A.EMPTY_SPLAT_TEXTURE;const C=(null==(g=o.display)?void 0:g.accumulator.toWorld)??new e.Matrix4,E=i.matrixWorld.clone().invert();C.clone().premultiply(E).decompose(this.uniforms.renderToViewPos.value,this.uniforms.renderToViewQuat.value,new e.Vector3)}prepareViewpoint(A){if(this.viewpoint=A??this.viewpoint,this.viewpoint.display){const{accumulator:A,geometry:n}=this.viewpoint.display;this.uniforms.numSplats.value=A.splats.numSplats,this.uniforms.packedSplats.value=A.splats.getTexture(),this.geometry=n}else this.uniforms.numSplats.value=0,this.uniforms.packedSplats.value=oa.getEmpty(),this.geometry=Ga}update({scene:A,viewToWorld:n}){const t=this.matrixWorld.clone();this.preUpdate?this.updateInternal({scene:A,originToWorld:t,viewToWorld:n}):(this.pendingUpdate={scene:A,originToWorld:t},setTimeout((()=>{if(this.pendingUpdate){const{scene:A,originToWorld:t}=this.pendingUpdate;this.pendingUpdate=null,this.updateInternal({scene:A,originToWorld:t,viewToWorld:n})}}),1))}updateInternal({scene:A,originToWorld:n,viewToWorld:t}){var i;if(!this.canAllocAccumulator())return!1;n||(n=this.active.toWorld),t=t??n.clone();const s=this.time??this.clock.getElapsedTime(),g=s-(this.lastUpdateTime??s);this.lastUpdateTime=s;const a=this.active.mapping.reduce(((A,n)=>(A.set(n.node,n),A)),new Map),{generators:I,globalEdits:r}=this.compileScene(A);for(const A of I)null==(i=A.frameUpdate)||i.call(A,{object:A,time:s,deltaTime:g,viewToWorld:t,globalEdits:r});for(const A of I){const n=a.get(A),t=A.generator?A.numSplats:0;A.generator===(null==n?void 0:n.generator)&&t===(null==n?void 0:n.count)||A.updateVersion()}const B=!lt({matrix1:n,matrix2:this.active.toWorld,maxDistance:this.originDistance})||I.length!==a.size||I.some((A=>{var n;return A.version!==(null==(n=a.get(A))?void 0:n.version)}));let o=null;if(B){if(o=this.maybeAllocAccumulator(),!o)throw new Error("Unreachable");const A=!lt({matrix1:n,matrix2:this.active.toWorld,maxDistance:1e-5,minCoorient:.99999}),t=I.map(((A,n)=>{const t=a.get(A);return t?[A.version-t.version,t.base,A]:[Number.POSITIVE_INFINITY,A.version,A]})).sort(((A,n)=>A[0]!==n[0]?A[0]-n[0]:A[1]-n[1])).map((([A,n,t])=>t)),i=t.map((A=>A.numSplats)),{maxSplats:s,mapping:g}=o.splats.generateMapping(i),r=t.map(((A,n)=>{const{base:t,count:e}=g[n];return{node:A,generator:A.generator,version:A.version,base:t,count:e}}));n.clone().invert().decompose(this.translateToAccumulator.value,this.rotateToAccumulator.value,new e.Vector3),o.ensureGenerate(s),o.generateSplats({renderer:this.renderer,modifier:this.modifier,generators:r,forceUpdate:A,originToWorld:n}),o.splatsVersion=this.active.splatsVersion+1;const B=o.hasCorrespondence(this.active);o.mappingVersion=this.active.mappingVersion+(B?0:1),this.releaseAccumulator(this.active),this.active=o,this.prepareViewpoint()}return setTimeout((()=>{for(const A of this.autoViewpoints)A.autoPoll({accumulator:o??void 0})}),1),!0}compileScene(A){const n=[];A.traverse((A=>{A instanceof Ng&&n.push(A)}));const t=new Set;return A.traverseVisible((A=>{if(A instanceof wg){let n=A.parent;for(;null!=n&&!(n instanceof Rg);)n=n.parent;null==n&&t.add(A)}})),{generators:n,globalEdits:Array.from(t)}}async renderEnvMap({renderer:n,scene:t,worldCenter:i,size:s=256,near:g=.1,far:a=1e3,hideObjects:I=[],update:r=!1}){var B,o;if(this.envViewpoint||(this.envViewpoint=this.newViewpoint({sort360:!0})),!A.cubeRender||A.cubeRender.target.width!==s||A.cubeRender.near!==g||A.cubeRender.far!==a){A.cubeRender&&A.cubeRender.target.dispose();const n=new e.WebGLCubeRenderTarget(s,{format:e.RGBAFormat,generateMipmaps:!0,minFilter:e.LinearMipMapLinearFilter}),t=new e.CubeCamera(g,a,n);A.cubeRender={target:n,camera:t,near:g,far:a}}A.pmrem||(A.pmrem=new e.PMREMGenerator(n??this.renderer));const Q=(new e.Matrix4).setPosition(i);await(null==(B=this.envViewpoint)?void 0:B.prepare({scene:t,viewToWorld:Q,update:r}));const{target:C,camera:E}=A.cubeRender;E.position.copy(i);const c=new Map;for(const A of I)c.set(A,A.visible),A.visible=!1;this.prepareViewpoint(this.envViewpoint),E.update(n??this.renderer,t),this.prepareViewpoint(this.defaultView);for(const[A,n]of c.entries())A.visible=n;return null==(o=A.pmrem)?void 0:o.fromCubemap(C.texture).texture}recurseSetEnvMap(A,n){A.traverse((A=>{if(A instanceof e.Mesh)if(Array.isArray(A.material))for(const t of A.material)t instanceof e.MeshStandardMaterial&&(t.envMap=n);else A.material instanceof e.MeshStandardMaterial&&(A.material.envMap=n)}))}getRgba({generator:A,rgba:n}){const t=this.active.mapping.find((({node:n})=>n===A));if(!t)throw new Error("Generator not found");return(n=n??new Eg).fromPackedSplats({packedSplats:this.active.splats,base:t.base,count:t.count,renderer:this.renderer}),n}async readRgba({generator:A,rgba:n}){return(n=this.getRgba({generator:A,rgba:n})).read()}};xa.cubeRender=null,xa.pmrem=null,xa.EMPTY_SPLAT_TEXTURE=new e.Data3DTexture;let Fa=xa;const Ga=new Ca(new Uint32Array(1),0);function ka(A,n,t){const e=Math.floor(A.length/32);if(32*e!==A.length)throw new Error("Invalid .splat file size");const i=new Float32Array(A.buffer);for(let n=0;n<e;++n){const e=32*n,s=8*n,g=i[s+0],a=i[s+1],I=i[s+2],r=i[s+3],B=i[s+4],o=i[s+5],Q=A[e+24]/255,C=A[e+25]/255,E=A[e+26]/255,c=A[e+27]/255,l=(A[e+28]-128)/128;t(n,g,a,I,r,B,o,(A[e+29]-128)/128,(A[e+30]-128)/128,(A[e+31]-128)/128,l,c,Q,C,E)}}Z({packedSplats:nA,index:"int"},{gsplat:AA},(({packedSplats:A,index:n})=>{if(!A||!n)throw new Error("Invalid input");return{gsplat:tA(A,n)}}));const Na={0:{bytesPerCenter:12,bytesPerScale:12,bytesPerRotation:16,bytesPerColor:4,bytesPerSphericalHarmonicsComponent:4,scaleOffsetBytes:12,rotationOffsetBytes:24,colorOffsetBytes:40,sphericalHarmonicsOffsetBytes:44,scaleRange:1},1:{bytesPerCenter:6,bytesPerScale:6,bytesPerRotation:8,bytesPerColor:4,bytesPerSphericalHarmonicsComponent:2,scaleOffsetBytes:6,rotationOffsetBytes:12,colorOffsetBytes:20,sphericalHarmonicsOffsetBytes:24,scaleRange:32767},2:{bytesPerCenter:6,bytesPerScale:6,bytesPerRotation:8,bytesPerColor:4,bytesPerSphericalHarmonicsComponent:1,scaleOffsetBytes:6,rotationOffsetBytes:12,colorOffsetBytes:20,sphericalHarmonicsOffsetBytes:24,scaleRange:32767}},Ma={0:0,1:9,2:24,3:45};function Ra(A,n,t,e){var i;const s=4096,g=1024;let a=0;const I=new DataView(A.buffer,a,s);a+=s;const r=I.getUint8(0),B=I.getUint8(1);if(0!==r||B<1)throw new Error(`Unsupported .ksplat version: ${r}.${B}`);const o=I.getUint32(4,!0);I.getUint32(16,!0);const Q=I.getUint16(20,!0);if(Q<0||Q>2)throw new Error(`Invalid .ksplat compression level: ${Q}`);const C=I.getFloat32(36,!0)||-1.5,E=I.getFloat32(40,!0)||1.5;let c=s+o*g;for(let n=0;n<o;++n){let n=function(A,n){if(0===Q)return P.getFloat32(A+b+4*n,!0);if(1===Q)return On(P.getUint16(A+b+2*n,!0));const t=P.getUint8(A+b+n)/255;return C+t*(E-C)};const s=new DataView(A.buffer,a,g);a+=g;const I=s.getUint32(0,!0),r=s.getUint32(4,!0),B=s.getUint32(8,!0),o=s.getUint32(12,!0),l=s.getFloat32(16,!0),h=s.getUint16(20,!0),u=(s.getUint32(24,!0)||(null==(i=Na[Q])?void 0:i.scaleRange))??1,d=s.getUint32(32,!0),p=d*B,y=s.getUint32(36,!0),D=4*y,w=h*o+D,f=s.getUint16(40,!0),m=Ma[f],{bytesPerCenter:S,bytesPerScale:x,bytesPerRotation:F,bytesPerColor:G,bytesPerSphericalHarmonicsComponent:k,scaleOffsetBytes:N,rotationOffsetBytes:M,colorOffsetBytes:R,sphericalHarmonicsOffsetBytes:b}=Na[Q],U=S+x+F+G+m*k,v=U*r,L=v+w,Y=[0,3,6,1,4,7,2,5,8],J=[9,14,19,10,15,20,11,16,21,12,17,22,13,18,23],H=[24,31,38,25,32,39,26,33,40,27,34,41,28,35,42,29,36,43,30,37,44],T=f>=1?new Float32Array(9):void 0,q=f>=2?new Float32Array(15):void 0,K=f>=3?new Float32Array(21):void 0,_=l/2/u,z=c+D,Z=c+w,P=new DataView(A.buffer,Z,v),O=new Float32Array(A.buffer,z,3*o),W=new Uint32Array(A.buffer,c,y);let V=d,j=p;for(let A=0;A<I;++A){const i=A*U;let s;if(A<p)s=Math.floor(A/B);else{const n=W[V-d];A>=j+n&&(V+=1,j+=n),s=V}const g=0===Q?P.getFloat32(i+0,!0):(P.getUint16(i+0,!0)-u)*_+O[3*s+0],a=0===Q?P.getFloat32(i+4,!0):(P.getUint16(i+2,!0)-u)*_+O[3*s+1],I=0===Q?P.getFloat32(i+8,!0):(P.getUint16(i+4,!0)-u)*_+O[3*s+2],r=0===Q?P.getFloat32(i+N+0,!0):On(P.getUint16(i+N+0,!0)),o=0===Q?P.getFloat32(i+N+4,!0):On(P.getUint16(i+N+2,!0)),C=0===Q?P.getFloat32(i+N+8,!0):On(P.getUint16(i+N+4,!0)),E=0===Q?P.getFloat32(i+M+0,!0):On(P.getUint16(i+M+0,!0)),c=0===Q?P.getFloat32(i+M+4,!0):On(P.getUint16(i+M+2,!0)),l=0===Q?P.getFloat32(i+M+8,!0):On(P.getUint16(i+M+4,!0)),h=0===Q?P.getFloat32(i+M+12,!0):On(P.getUint16(i+M+6,!0)),y=P.getUint8(i+R+0)/255,D=P.getUint8(i+R+1)/255,w=P.getUint8(i+R+2)/255;if(t(A,g,a,I,r,o,C,c,l,h,E,P.getUint8(i+R+3)/255,y,D,w),f>=1&&T){for(const[A,t]of Y.entries())T[A]=n(i,t);if(q)for(const[A,t]of J.entries())q[A]=n(i,t);if(K)for(const[A,t]of H.entries())K[A]=n(i,t);null==e||e(A,T,q,K)}}c+=L}}class ba{constructor({fileBytes:A}){this.fileBytes=A instanceof ArrayBuffer?new Uint8Array(A):A,this.reader=new yt({fileBytes:this.fileBytes});const n=new DataView(this.reader.read(16).buffer);if(1347635022!==n.getUint32(0,!0))throw new Error("Invalid SPZ file");if(this.version=n.getUint32(4,!0),this.version<1||this.version>2)throw new Error(`Unsupported SPZ version: ${this.version}`);this.numSplats=n.getUint32(8,!0),this.shDegree=n.getUint8(12),this.fractionalBits=n.getUint8(13),this.flags=n.getUint8(14),this.flagAntiAlias=!!(1&this.flags),this.reserved=n.getUint8(15),this.parsed=!1}parseSplats(A,n,t,e,i,s){if(this.parsed)throw new Error("SPZ file already parsed");if(this.parsed=!0,1===this.version){const n=this.reader.read(3*this.numSplats*2),t=new Uint16Array(n.buffer);for(let n=0;n<this.numSplats;n++){const e=3*n,i=On(t[e]),s=On(t[e+1]),g=On(t[e+2]);null==A||A(n,i,s,g)}}else{if(2!==this.version)throw new Error("Unreachable");{const n=1<<this.fractionalBits,t=this.reader.read(3*this.numSplats*3);for(let e=0;e<this.numSplats;e++){const i=9*e,s=((t[i+2]<<24|t[i+1]<<16|t[i]<<8)>>8)/n,g=((t[i+5]<<24|t[i+4]<<16|t[i+3]<<8)>>8)/n,a=((t[i+8]<<24|t[i+7]<<16|t[i+6]<<8)>>8)/n;null==A||A(e,s,g,a)}}}{const A=this.reader.read(this.numSplats);for(let t=0;t<this.numSplats;t++)null==n||n(t,A[t]/255)}{const A=this.reader.read(3*this.numSplats),n=va/.15;for(let e=0;e<this.numSplats;e++){const i=3*e,s=(A[i]/255-.5)*n+.5,g=(A[i+1]/255-.5)*n+.5,a=(A[i+2]/255-.5)*n+.5;null==t||t(e,s,g,a)}}{const A=this.reader.read(3*this.numSplats);for(let n=0;n<this.numSplats;n++){const t=3*n,i=Math.exp(A[t]/16-10),s=Math.exp(A[t+1]/16-10),g=Math.exp(A[t+2]/16-10);null==e||e(n,i,s,g)}}{const A=this.reader.read(3*this.numSplats);for(let n=0;n<this.numSplats;n++){const t=3*n,e=A[t]/127.5-1,s=A[t+1]/127.5-1,g=A[t+2]/127.5-1,a=Math.sqrt(Math.max(0,1-e*e-s*s-g*g));null==i||i(n,e,s,g,a)}}if(s&&this.shDegree>=1){const A=new Float32Array(9),n=this.shDegree>=2?new Float32Array(15):void 0,t=this.shDegree>=3?new Float32Array(21):void 0,e=this.reader.read(this.numSplats*Ua[this.shDegree]*3);let i=0;for(let g=0;g<this.numSplats;g++){for(let n=0;n<9;++n)A[n]=(e[i+n]-128)/128;if(i+=9,n){for(let A=0;A<15;++A)n[A]=(e[i+A]-128)/128;i+=15}if(t){for(let A=0;A<21;++A)t[A]=(e[i+A]-128)/128;i+=21}null==s||s(g,A,n,t)}}}}const Ua={1:3,2:8,3:15},va=.28209479177387814;class La{constructor({numSplats:A,shDegree:n,fractionalBits:t=12,flagAntiAlias:e=!0}){this.clippedCount=0;const i=16+A*(19+(n>=1?9:0)+(n>=2?15:0)+(n>=3?21:0));this.buffer=new ArrayBuffer(i),this.view=new DataView(this.buffer),this.view.setUint32(0,1347635022,!0),this.view.setUint32(4,2,!0),this.view.setUint32(8,A,!0),this.view.setUint8(12,n),this.view.setUint8(13,t),this.view.setUint8(14,e?1:0),this.view.setUint8(15,0),this.numSplats=A,this.shDegree=n,this.fractionalBits=t,this.fraction=1<<t,this.flagAntiAlias=e}setCenter(A,n,t,e){const i=Math.round(n*this.fraction),s=Math.max(-8388607,Math.min(8388607,i)),g=Math.round(t*this.fraction),a=Math.max(-8388607,Math.min(8388607,g)),I=Math.round(e*this.fraction),r=Math.max(-8388607,Math.min(8388607,I));(i!==s||g!==a||I!==r)&&(this.clippedCount+=1);const B=16+9*A;this.view.setUint8(B,255&s),this.view.setUint8(B+1,s>>8&255),this.view.setUint8(B+2,s>>16&255),this.view.setUint8(B+3,255&a),this.view.setUint8(B+4,a>>8&255),this.view.setUint8(B+5,a>>16&255),this.view.setUint8(B+6,255&r),this.view.setUint8(B+7,r>>8&255),this.view.setUint8(B+8,r>>16&255)}setAlpha(A,n){const t=16+9*this.numSplats+A;this.view.setUint8(t,Math.max(0,Math.min(255,Math.round(255*n))))}static scaleRgb(A){const n=255*((A-.5)/(va/.15)+.5);return Math.max(0,Math.min(255,Math.round(n)))}setRgb(A,n,t,e){const i=16+10*this.numSplats+3*A;this.view.setUint8(i,La.scaleRgb(n)),this.view.setUint8(i+1,La.scaleRgb(t)),this.view.setUint8(i+2,La.scaleRgb(e))}setScale(A,n,t,e){const i=16+13*this.numSplats+3*A;this.view.setUint8(i,Math.max(0,Math.min(255,Math.round(16*(Math.log(n)+10))))),this.view.setUint8(i+1,Math.max(0,Math.min(255,Math.round(16*(Math.log(t)+10))))),this.view.setUint8(i+2,Math.max(0,Math.min(255,Math.round(16*(Math.log(e)+10)))))}setQuat(A,n,t,e,i){const s=16+16*this.numSplats+3*A,g=i<0;this.view.setUint8(s,Math.max(0,Math.min(255,Math.round(127.5*((g?-n:n)+1))))),this.view.setUint8(s+1,Math.max(0,Math.min(255,Math.round(127.5*((g?-t:t)+1))))),this.view.setUint8(s+2,Math.max(0,Math.min(255,Math.round(127.5*((g?-e:e)+1)))))}static quantizeSh(A,n){const t=Math.round(128*A)+128,e=1<<8-n,i=Math.floor((t+e/2)/e)*e;return Math.max(0,Math.min(255,i))}setSh(A,n,t,e){const i=Ua[this.shDegree]||0,s=16+19*this.numSplats+A*i*3;for(let A=0;A<9;++A)this.view.setUint8(s+A,La.quantizeSh(n[A],5));if(t){const A=s+9;for(let n=0;n<15;++n)this.view.setUint8(A+n,La.quantizeSh(t[n],4));if(e){const n=A+15;for(let A=0;A<21;++A)this.view.setUint8(n+A,La.quantizeSh(e[A],4))}}}async finalize(){const A=new Uint8Array(this.buffer),n=new ReadableStream({async start(n){n.enqueue(A),n.close()}}).pipeThrough(new CompressionStream("gzip")),t=new Response(n),e=await t.arrayBuffer();return console.log("Compressed",A.length,"bytes to",e.byteLength,"bytes"),new Uint8Array(e)}}async function Ya(A){var n,t,i;const s=new ra,{inputs:g,clipXyz:a,maxSh:I,fractionalBits:r=12,opacityThreshold:B}=A;for(const A of g){let g=function(A){return A.multiplyScalar(C),A.applyQuaternion(E),A.add(c),A},I=function(A){return A.multiplyScalar(C),A},r=function(A){return A.premultiply(E),A},o=function(A){return!l||l.containsPoint(A)},Q=function(A){return void 0===B||A>=B};const C=(null==(n=A.transform)?void 0:n.scale)??1,E=(new e.Quaternion).fromArray((null==(t=A.transform)?void 0:t.quaternion)??[0,0,0,1]),c=(new e.Vector3).fromArray((null==(i=A.transform)?void 0:i.translate)??[0,0,0]),l=a?new e.Box3((new e.Vector3).fromArray(a.min),(new e.Vector3).fromArray(a.max)):void 0;let h=A.fileType;switch(h||(h=ia(A.fileBytes),!h&&A.pathOrUrl&&(h=sa(A.pathOrUrl))),h){case ea.PLY:{const n=new Yg({fileBytes:A.fileBytes});await n.parseHeader();let t=null;n.parseSplats(((A,n,i,a,B,C,E,c,l,h,u,d,p,y,D)=>{const w=g(new e.Vector3(n,i,a));if(o(w)&&Q(d)){t=s.pushSplat(),s.setCenter(t,w.x,w.y,w.z);const A=I(new e.Vector3(B,C,E));s.setScale(t,A.x,A.y,A.z);const n=r(new e.Quaternion(c,l,h,u));s.setQuaternion(t,n.x,n.y,n.z,n.w),s.setOpacity(t,d),s.setColor(t,p,y,D)}else t=null}),((A,n,e,i)=>{n&&null!==t&&s.setSh1(t,n),e&&null!==t&&s.setSh2(t,e),i&&null!==t&&s.setSh3(t,i)}));break}case ea.SPZ:{const n=new ba({fileBytes:A.fileBytes}),t=new Int32Array(n.numSplats);t.fill(-1);const i=new Float32Array(3*n.numSplats),a=new e.Vector3;n.parseSplats(((A,n,t,s)=>{const a=g(new e.Vector3(n,t,s));i[3*A]=a.x,i[3*A+1]=a.y,i[3*A+2]=a.z}),((A,n)=>{a.fromArray(i,3*A),o(a)&&Q(n)&&(t[A]=s.pushSplat(),s.setCenter(t[A],a.x,a.y,a.z),s.setOpacity(t[A],n))}),((A,n,e,i)=>{t[A]>=0&&s.setColor(t[A],n,e,i)}),((A,n,i,g)=>{if(t[A]>=0){const a=I(new e.Vector3(n,i,g));s.setScale(t[A],a.x,a.y,a.z)}}),((A,n,i,g,a)=>{if(t[A]>=0){const I=r(new e.Quaternion(n,i,g,a));s.setQuaternion(t[A],I.x,I.y,I.z,I.w)}}),((A,n,e,i)=>{t[A]>=0&&(s.setSh1(t[A],n),e&&s.setSh2(t[A],e),i&&s.setSh3(t[A],i))}));break}case ea.SPLAT:ka(A.fileBytes,0,((A,n,t,i,a,B,C,E,c,l,h,u,d,p,y)=>{const D=g(new e.Vector3(n,t,i));if(o(D)&&Q(u)){const A=s.pushSplat();s.setCenter(A,D.x,D.y,D.z);const n=I(new e.Vector3(a,B,C));s.setScale(A,n.x,n.y,n.z);const t=r(new e.Quaternion(E,c,l,h));s.setQuaternion(A,t.x,t.y,t.z,t.w),s.setOpacity(A,u),s.setColor(A,d,p,y)}}));break;case ea.KSPLAT:{let n=null;Ra(A.fileBytes,0,((A,t,i,a,B,C,E,c,l,h,u,d,p,y,D)=>{const w=g(new e.Vector3(t,i,a));if(o(w)&&Q(d)){n=s.pushSplat(),s.setCenter(n,w.x,w.y,w.z);const A=I(new e.Vector3(B,C,E));s.setScale(n,A.x,A.y,A.z);const t=r(new e.Quaternion(c,l,h,u));s.setQuaternion(n,t.x,t.y,t.z,t.w),s.setOpacity(n,d),s.setColor(n,p,y,D)}else n=null}),((A,t,e,i)=>{null!==n&&(s.setSh1(n,t),e&&s.setSh2(n,e),i&&s.setSh3(n,i))}));break}default:throw new Error(`transcodeSpz not implemented for ${h}`)}}const o=Math.min(I??3,s.sh3?3:s.sh2?2:s.sh1?1:0),Q=new La({numSplats:s.numSplats,shDegree:o,fractionalBits:r,flagAntiAlias:!0});for(let A=0;A<s.numSplats;++A){const n=3*A,t=4*A;Q.setCenter(A,s.centers[n],s.centers[n+1],s.centers[n+2]),Q.setScale(A,s.scales[n],s.scales[n+1],s.scales[n+2]),Q.setQuat(A,s.quaternions[t],s.quaternions[t+1],s.quaternions[t+2],s.quaternions[t+3]),Q.setAlpha(A,s.opacities[A]),Q.setRgb(A,s.colors[n],s.colors[n+1],s.colors[n+2]),s.sh1&&o>=1&&Q.setSh(A,s.sh1.slice(9*A,9*(A+1)),o>=2&&s.sh2?s.sh2.slice(15*A,15*(A+1)):void 0,o>=3&&s.sh3?s.sh3.slice(21*A,21*(A+1)):void 0)}return{fileBytes:await Q.finalize(),clippedCount:Q.clippedCount}}class Ja{constructor(A){this.mesh=A.mesh,this.numSplats=A.numSplats??this.mesh.numSplats;const{width:n,height:t,depth:i,maxSplats:s}=it(this.numSplats);this.skinData=new Uint16Array(4*s),this.skinTexture=new e.DataArrayTexture(this.skinData,n,t,i),this.skinTexture.format=e.RGBAIntegerFormat,this.skinTexture.type=e.UnsignedShortType,this.skinTexture.internalFormat="RGBA16UI",this.skinTexture.needsUpdate=!0,this.numBones=A.numBones??256,this.boneData=new Float32Array(16*this.numBones),this.boneTexture=new e.DataTexture(this.boneData,4,this.numBones,e.RGBAFormat,e.FloatType),this.boneTexture.internalFormat="RGBA32F",this.boneTexture.needsUpdate=!0,this.uniform=new fA({key:"skinning",type:Ha,globals:()=>[Ta],value:{numSplats:this.numSplats,numBones:this.numBones,skinTexture:this.skinTexture,boneTexture:this.boneTexture}})}modify(A){return function(A,n){const t=new _({inTypes:{gsplat:AA,skinning:Ha},outTypes:{gsplat:AA},globals:()=>[Ta,qa],inputs:{gsplat:A,skinning:n},statements:({inputs:A,outputs:n})=>{const{skinning:t}=A,{gsplat:e}=n;return W(`\n        ${e} = ${A.gsplat};\n        if (isGsplatActive(${e}.flags)) {\n          applyGsplatSkinning(\n            ${t}.numSplats, ${t}.numBones,\n            ${t}.skinTexture, ${t}.boneTexture,\n            ${e}.index, ${e}.center, ${e}.quaternion\n          );\n        }\n      `)}});return t.outputs.gsplat}(A,this.uniform)}setRestQuatPos(A,n,t){const e=16*A;this.boneData[e+0]=n.x,this.boneData[e+1]=n.y,this.boneData[e+2]=n.z,this.boneData[e+3]=n.w,this.boneData[e+4]=t.x,this.boneData[e+5]=t.y,this.boneData[e+6]=t.z,this.boneData[e+7]=0,this.boneData[e+8]=0,this.boneData[e+9]=0,this.boneData[e+10]=0,this.boneData[e+11]=1,this.boneData[e+12]=0,this.boneData[e+13]=0,this.boneData[e+14]=0,this.boneData[e+15]=0}setBoneQuatPos(A,n,t){const i=16*A,s=new e.Quaternion(this.boneData[i+0],this.boneData[i+1],this.boneData[i+2],this.boneData[i+3]),g=new e.Vector3(this.boneData[i+4],this.boneData[i+5],this.boneData[i+6]),a=s.clone().invert(),I=t.clone().sub(g);I.applyQuaternion(a),a.multiply(n);const r=new e.Quaternion(I.x,I.y,I.z,0).multiply(s);this.boneData[i+8]=a.x,this.boneData[i+9]=a.y,this.boneData[i+10]=a.z,this.boneData[i+11]=a.w,this.boneData[i+12]=.5*r.x,this.boneData[i+13]=.5*r.y,this.boneData[i+14]=.5*r.z,this.boneData[i+15]=.5*r.w}setSplatBones(A,n,t){const e=4*A;this.skinData[e+0]=Math.min(255,Math.max(0,Math.round(255*t.x)))+(n.x<<8),this.skinData[e+1]=Math.min(255,Math.max(0,Math.round(255*t.y)))+(n.y<<8),this.skinData[e+2]=Math.min(255,Math.max(0,Math.round(255*t.z)))+(n.z<<8),this.skinData[e+3]=Math.min(255,Math.max(0,Math.round(255*t.w)))+(n.w<<8)}updateBones(){this.boneTexture.needsUpdate=!0,this.mesh.needsUpdate=!0}}const Ha={type:"GsplatSkinning"},Ta=V("\n  struct GsplatSkinning {\n    int numSplats;\n    int numBones;\n    usampler2DArray skinTexture;\n    sampler2D boneTexture;\n  };\n"),qa=V("\n  void applyGsplatSkinning(\n    int numSplats, int numBones,\n    usampler2DArray skinTexture, sampler2D boneTexture,\n    int splatIndex, inout vec3 center, inout vec4 quaternion\n  ) {\n    if ((splatIndex < 0) || (splatIndex >= numSplats)) {\n      return;\n    }\n\n    uvec4 skinData = texelFetch(skinTexture, splatTexCoord(splatIndex), 0);\n\n    float weights[4];\n    weights[0] = float(skinData.x & 0xffu) / 255.0;\n    weights[1] = float(skinData.y & 0xffu) / 255.0;\n    weights[2] = float(skinData.z & 0xffu) / 255.0;\n    weights[3] = float(skinData.w & 0xffu) / 255.0;\n\n    uint boneIndices[4];\n    boneIndices[0] = (skinData.x >> 8u) & 0xffu;\n    boneIndices[1] = (skinData.y >> 8u) & 0xffu;\n    boneIndices[2] = (skinData.z >> 8u) & 0xffu;\n    boneIndices[3] = (skinData.w >> 8u) & 0xffu;\n\n    vec4 quat = vec4(0.0);\n    vec4 dual = vec4(0.0);\n    for (int i = 0; i < 4; i++) {\n      if (weights[i] > 0.0) {\n        int boneIndex = int(boneIndices[i]);\n        vec4 boneQuat = vec4(0.0, 0.0, 0.0, 1.0);\n        vec4 boneDual = vec4(0.0);\n        if (boneIndex < numBones) {\n          boneQuat = texelFetch(boneTexture, ivec2(2, boneIndex), 0);\n          boneDual = texelFetch(boneTexture, ivec2(3, boneIndex), 0);\n        }\n\n        if ((i > 0) && (dot(quat, boneQuat) < 0.0)) {\n          // Flip sign if next blend is pointing in the opposite direction\n          boneQuat = -boneQuat;\n          boneDual = -boneDual;\n        }\n        quat += weights[i] * boneQuat;\n        dual += weights[i] * boneDual;\n      }\n    }\n\n    // Normalize dual quaternion\n    float norm = length(quat);\n    quat /= norm;\n    dual /= norm;\n    vec3 translate = vec3(\n      2.0 * (-dual.w * quat.x + dual.x * quat.w - dual.y * quat.z + dual.z * quat.y),\n      2.0 * (-dual.w * quat.y + dual.x * quat.z + dual.y * quat.w - dual.z * quat.x),\n      2.0 * (-dual.w * quat.z - dual.x * quat.y + dual.y * quat.x + dual.z * quat.w)\n    );\n\n    center = quatVec(quat, center) + translate;\n    quaternion = quatQuat(quat, quaternion);\n  }\n");function Ka({splats:A,extents:n,stepSize:t=1,pointRadius:i=.01,pointShadowScale:s=2,opacity:g=1,color:a}){const I=1e-6,r=new e.Vector3,B=new e.Vector3,o=new e.Quaternion(0,0,0,1);null==a&&(a=(A,n)=>A.set(.55+.45*Math.cos(1*n.x),.55+.45*Math.cos(1*n.y),.55+.45*Math.cos(1*n.z)));const Q=new e.Color;for(let e=n.min.z;e<n.max.z+I;e+=t)for(let C=n.min.y;C<n.max.y+I;C+=t)for(let E=n.min.x;E<n.max.x+I;E+=t){r.set(E,C,e);for(let n=0;n<2;++n)B.setScalar(i*(n?1:s)),n?"function"==typeof a?a(Q,r):Q.copy(a):Q.setScalar(0),A.pushSplat(r,B,o,g,Q)}}function _a({splats:A,scale:n=.25,axisRadius:t=.0075,axisShadowScale:i=2,origins:s=[new e.Vector3]}){const g=new e.Vector3,a=new e.Vector3,I=new e.Quaternion(0,0,0,1),r=new e.Color;for(const e of s)for(let s=0;s<3;++s){g.set(e.x+(0===s?n:0),e.y+(1===s?n:0),e.z+(2===s?n:0));for(let e=0;e<2;++e)a.set((0===s?n:t)*(e?1:i),(1===s?n:t)*(e?1:i),(2===s?n:t)*(e?1:i)),r.setRGB(0===e?0:0===s?1:0,0===e?0:1===s?1:0,0===e?0:2===s?1:0),A.pushSplat(g,a,I,1,r)}}function za({splats:A,origin:n=new e.Vector3,radius:t=1,maxDepth:i=3,filter:s=null,pointRadius:g=.02,pointThickness:a=.001,color:I=new e.Color(1,1,1)}){const r={};function B(A){if(s&&!s(A))return;const n=`${A.x},${A.y},${A.z}`;r[n]||(r[n]=A)}function o(A,n,t,s){if(B(n),B(t),B(s),A>=i)return;const g=(new e.Vector3).addVectors(n,t).normalize(),a=(new e.Vector3).addVectors(t,s).normalize(),I=(new e.Vector3).addVectors(s,n).normalize();o(A+1,n,g,I),o(A+1,g,t,a),o(A+1,I,a,s),o(A+1,g,a,I)}for(const A of[-1,1])for(const n of[-1,1])for(const t of[-1,1]){o(0,new e.Vector3(A,0,0),new e.Vector3(0,n,0),new e.Vector3(0,0,t))}const Q=Object.values(r),C=new e.Vector3(g,g,a),E=new e.Quaternion,c="function"==typeof I?new e.Color:I;for(const i of Q)E.setFromUnitVectors(new e.Vector3(0,0,-1),i),"function"==typeof I&&I(c,i),i.multiplyScalar(t),i.add(n),A.pushSplat(i,C,E,1,c)}function Za({text:A,font:n,fontSize:t,color:i,rgb:s,dotRadius:g,textAlign:a,lineHeight:I,objectScale:r}){n=n??"Arial",t=t??32,i=i??new e.Color(1,1,1),g=g??.8,a=a??"start",I=I??1,r=r??1;const B=A.split("\n"),o=document.createElement("canvas"),Q=o.getContext("2d");if(!Q)throw new Error("Failed to create canvas context");Q.font=`${t}px ${n}`,Q.textAlign=a;const C=Q.measureText(""),E=C.fontBoundingBoxAscent+C.fontBoundingBoxDescent;let c=Number.POSITIVE_INFINITY,l=Number.NEGATIVE_INFINITY,h=Number.POSITIVE_INFINITY,u=Number.NEGATIVE_INFINITY;for(let A=0;A<B.length;++A){const n=Q.measureText(B[A]),t=E*I*A;c=Math.min(c,-n.actualBoundingBoxLeft),l=Math.max(l,n.actualBoundingBoxRight),h=Math.min(h,t-n.actualBoundingBoxAscent),u=Math.max(u,t+n.actualBoundingBoxDescent)}const d=Math.floor(c),p=Math.floor(h),y=Math.ceil(l)-d,D=Math.ceil(u)-p;o.width=y,o.height=D,Q.font=`${t}px ${n}`,Q.textAlign=a,Q.textBaseline="alphabetic",Q.fillStyle="#FFFFFF";for(let A=0;A<B.length;++A){const n=E*I*A-p;Q.fillText(B[A],-d,n)}const w=Q.getImageData(0,0,y,D),f=new Uint8Array(w.data.buffer),m=new oa,S=new e.Vector3,x=(new e.Vector3).setScalar(g*r),F=new e.Quaternion(0,0,0,1);s=s??new e.Color(1,1,1);let G=0;for(let A=0;A<D;++A)for(let n=0;n<y;++n){const t=f[G+3];if(t>0){const e=t/255;S.set(n-.5*(y-1),.5*(D-1)-A,0),S.multiplyScalar(r),m.pushSplat(S,x,F,e,s)}G+=4}const k=new Rg({packedSplats:m});return k.recolor=i,k}function Pa({url:A,dotRadius:n,subXY:t,forEachSplat:i}){return n=n??.8,t=Math.max(1,Math.floor(t??1)),new Rg({constructSplats:async s=>new Promise(((g,a)=>{const I=new Image;I.crossOrigin="anonymous",I.onerror=a,I.onload=()=>{const{width:A,height:r}=I,B=document.createElement("canvas");B.width=A,B.height=r;const o=B.getContext("2d");if(!o)return void a(new Error("Failed to create canvas context"));o.imageSmoothingEnabled=!0,o.imageSmoothingQuality="high";const Q=Math.round(A/t),C=Math.round(r/t);o.drawImage(I,0,0,Q,C);try{const A=o.getImageData(0,0,Q,C),t=new Uint8Array(A.data.buffer),a=new e.Vector3,I=(new e.Vector3).setScalar(n),r=new e.Quaternion(0,0,0,1),B=new e.Color;let E=0;for(let A=0;A<C;++A)for(let e=0;e<Q;++e){const g=4*E,o=t[g+3];if(o>0){let c=o/255;B.set(t[g+0]/255,t[g+1]/255,t[g+2]/255),a.set(e-.5*(Q-1),.5*(C-1)-A,0),I.setScalar(n),r.set(0,0,0,1);let l=!0;if(i){const A=i(Q,C,E,a,I,r,c,B);c=A??c,l=null!==A}l&&s.pushSplat(a,I,r,c,B)}E+=1}g()}catch(A){a(A)}},I.src=A}))})}const Oa={box:new e.Box3(new e.Vector3(-1,-1,-1),new e.Vector3(1,1,1)),density:100,fallDirection:new e.Vector3(-1,-3,1).normalize(),fallVelocity:.02,wanderScale:.04,wanderVariance:2,color1:new e.Color(1,1,1),color2:new e.Color(.5,.5,1),minScale:.001,maxScale:.005,anisoScale:new e.Vector3(1,1,1)},Wa={box:new e.Box3(new e.Vector3(-2,-1,-2),new e.Vector3(2,5,2)),density:10,fallDirection:new e.Vector3(0,-1,0),fallVelocity:2,wanderScale:.1,wanderVariance:1,color1:new e.Color(1,1,1),color2:new e.Color(.25,.25,.5),minScale:.005,maxScale:.01,anisoScale:new e.Vector3(.1,1,.1)};const Va=Object.freeze(Object.defineProperty({__proto__:null,DEFAULT_RAIN:Wa,DEFAULT_SNOW:Oa,snowBox:function({box:A,minY:n,numSplats:t,density:i,anisoScale:s,minScale:g,maxScale:a,fallDirection:I,fallVelocity:r,wanderScale:B,wanderVariance:o,color1:Q,color2:C,opacity:E,onFrame:c}){const l=((A=A??new e.Box3(new e.Vector3(-1,-1,-1),new e.Vector3(1,1,1))).max.x-A.min.x)*(A.max.y-A.min.y)*(A.max.z-A.min.z);i=i??100,t=t??Math.max(1,Math.min(1e6,Math.round(l*i)));const h=DA(g??.001),u=DA(a??.005),d=wA(((null==s?void 0:s.clone())??new e.Vector3(1,1,1)).normalize()),p=wA((I??new e.Vector3(0,-1,0)).normalize()),y=DA(r??.02),D=DA(B??.01),w=DA(o??2),f=wA(Q??new e.Color(1,1,1)),m=wA(C??new e.Color(.5,.5,1)),S=DA(E??1),x=DA(0),F=wA(new e.Vector3(0,0,0)),G=wA(A.min),k=wA(A.max),N=DA(n??Number.NEGATIVE_INFINITY),M=ee(k,G),R=new Ng({numSplats:t,generator:Z({index:"int"},{gsplat:AA},(({index:A})=>{if(!A)throw new Error("index not defined");const n=Ds(A),t=Oi(n).outputs.w;let i=Bi(n),s=re(ie(t,H("float",100)));s=Os(ie(Y("float","PI"),s)),s=te(h,ie(s,ee(u,h)));const g=ie(s,d),a=re(ie(t,H("float",10))),I=re(t),r=oe(f,m,I),B=ie(r,a),o=Ds(Wi({vectorType:"ivec2",x:A,y:H("int",6837)}));let Q=Bi(o),C=ie(Oi(o).outputs.w,w);C=te(x,C),i=te(i,F);const E=ae(i,H("vec3",new e.Vector3(1,1,1)));i=te(G,ie(M,E));const c=H("vec4",new e.Quaternion(0,0,0,1));Q=Os(te(Bi(C),Q)),Q=ie(Q,D);let l=te(i,Q),p=Oi(l).outputs.y;p=Be(N,p),l=Wi({vector:l,y:p});let y=sA({flags:Y("uint","GSPLAT_FLAG_ACTIVE"),index:A,center:l,scales:g,quaternion:c,rgb:B,opacity:S});return y=b.applyGsplat(y),{gsplat:y}}),{globals:()=>[IA]}),update:({object:A,time:n,deltaTime:t})=>{x.value=n,b.update(R);const e=p.value.clone().multiplyScalar(y.value*t);F.value.add(e),A.visible=S.value>0,null==c||c({object:A,time:n,deltaTime:t}),R.updateVersion()}}),b=new kg;return{snow:R,min:G,max:k,minY:N,color1:f,color2:m,opacity:S,fallVelocity:y,wanderVariance:w,wanderScale:D,fallDirection:p,minScale:h,maxScale:u,anisoScale:d}},staticBox:function({box:A,cells:n,dotScale:t,color:i,opacity:s}){n.x=Math.max(1,Math.round(n.x)),n.y=Math.max(1,Math.round(n.y)),n.z=Math.max(1,Math.round(n.z)),s=s??1;const g=n.x*n.y*n.z,a=H("int",n.x),I=H("int",n.y);H("int",n.z);const r=DA(0),B=new Ng({numSplats:g,generator:Z({index:"int"},{gsplat:AA},(({index:g})=>{if(!g)throw new Error("index is undefined");const B=ge(g,a),Q=se(g,a),C=ge(Q,I),E=se(Q,I),c=Wi({vectorType:"ivec3",x:B,y:C,z:E}),l=Qi(r),h=Wi({vectorType:"ivec2",x:g,y:l}),u=ys(h),d=H("vec3",A.min),p=H("vec3",A.max),y=ee(p,d),D=se(te(Bi(c),u),H("vec3",n));let w,f,m;i?(w=H("float",i.r),f=H("float",i.g),m=H("float",i.b)):({r:w,g:f,b:m}=Oi(D).outputs);const S=Wi({vectorType:"vec4",r:w,g:f,b:m,a:H("float",s)}),x=te(d,ie(y,D)),F=Bi(H("float",t)),G=H("vec4",new e.Quaternion(0,0,0,1));let k=sA({flags:Y("uint","GSPLAT_FLAG_ACTIVE"),index:g,center:x,scales:F,quaternion:G,rgba:S});return k=o.applyGsplat(k),{gsplat:k}}),{globals:()=>[IA]}),update:({time:A})=>{r.value=A,o.update(B),B.updateVersion()}}),o=new kg;return B}},Symbol.toStringTag,{value:"Module"}));function ja(A){return Z({gsplat:AA},{gsplat:AA},(({gsplat:n})=>{if(!n)throw new Error("No gsplat input");let t=gA(n);const e=A.applyGsplat(n),i=iA(e).outputs.center,s=gA(e),g=Zi(i,s),a=Ke(g,H("float",0));t=_e(a,Ie(t),t);const I=te(ie(t,H("float",.5)),H("float",.5));return{gsplat:n=sA({gsplat:n,rgb:I})}}))}function Xa(A,n,t,e){return Z({gsplat:AA},{gsplat:AA},(({gsplat:i})=>{if(!i)throw new Error("No gsplat input");let{center:s}=iA(i).outputs;s=A.apply(s);const{z:g}=Oi(s).outputs;let a=ws(Ie(g),n,t);return a=_e(e,ee(H("float",1),a),a),{gsplat:i=sA({gsplat:i,r:a,g:a,b:a})}}))}const $a=Object.freeze(Object.defineProperty({__proto__:null,makeDepthColorModifier:Xa,makeNormalColorModifier:ja,setDepthColor:function(A,n,t,e){A.enableWorldToView=!0;const i=H("float",n),s=H("float",t),g=H("bool",e??!1);return A.worldModifier=Xa(A.context.worldToView,i,s,g),A.updateGenerator(),{minDepth:i,maxDepth:s,reverse:g}},setWorldNormalColor:function(A){A.enableWorldToView=!0,A.worldModifier=ja(A.context.worldToView),A.updateGenerator()}},Symbol.toStringTag,{value:"Module"})),AI=class A{static createButton(n,t={}){const e=navigator.xr;if(!e)return null;const i=e,s=document.createElement("button");function g(){s.style.display="none",s.style.cursor="auto",s.style.left="calc(50% - 75px)",s.style.width="150px",s.onmouseenter=null,s.onmouseleave=null,s.onclick=null}var a;return n.xr.enabled=!0,n.xr.setReferenceSpaceType("local"),s.id="VRButton",s.style.display="none",(a=s).style.position="absolute",a.style.bottom="20px",a.style.padding="12px 6px",a.style.border="1px solid #fff",a.style.borderRadius="4px",a.style.background="rgba(0,0,0,0.1)",a.style.color="#fff",a.style.font="normal 13px sans-serif",a.style.textAlign="center",a.style.opacity="0.5",a.style.outline="none",a.style.zIndex="999",i.isSessionSupported("immersive-vr").then((e=>{e?function(){let A=null;async function e(t){console.log("onSessionStarted"),t.addEventListener("end",g),await n.xr.setSession(t),s.textContent="EXIT VR",A=t}function g(){console.log("onSessionEnded"),null==A||A.removeEventListener("end",g),s.textContent="ENTER VR",A=null}s.style.display="",s.style.cursor="pointer",s.style.left="calc(50% - 100px)",s.style.width="200px",s.style.height="100px",s.textContent="ENTER VR";const a={...t,optionalFeatures:[...t.optionalFeatures||[]]};s.onmouseenter=()=>{s.style.opacity="1.0"},s.onmouseleave=()=>{s.style.opacity="0.5"},s.onclick=()=>{null===A?(console.log("requesting session"),i.requestSession("immersive-vr",a).then(e)):(console.log("ending session"),A.end())}}():(g(),s.textContent="VR NOT SUPPORTED"),e&&A.xrSessionIsGranted&&s.click()})).catch((function(A){g(),console.warn("Exception when trying to call xr.isSessionSupported",A),s.textContent="VR NOT ALLOWED"})),s}static registerSessionGrantedListener(){const n=navigator.xr;if(!n)return null;const t=n;/WebXRViewer\//i.test(navigator.userAgent)||t.addEventListener("sessiongranted",(()=>{A.xrSessionIsGranted=!0}))}};AI.xrSessionIsGranted=!1;let nI=AI;nI.registerSessionGrantedListener();var tI=(A=>(A.w="wrist",A.t0="thumb-metacarpal",A.t1="thumb-phalanx-proximal",A.t2="thumb-phalanx-distal",A.t3="thumb-tip",A.i0="index-finger-metacarpal",A.i1="index-finger-phalanx-proximal",A.i2="index-finger-phalanx-intermediate",A.i3="index-finger-phalanx-distal",A.i4="index-finger-tip",A.m0="middle-finger-metacarpal",A.m1="middle-finger-phalanx-proximal",A.m2="middle-finger-phalanx-intermediate",A.m3="middle-finger-phalanx-distal",A.m4="middle-finger-tip",A.r0="ring-finger-metacarpal",A.r1="ring-finger-phalanx-proximal",A.r2="ring-finger-phalanx-intermediate",A.r3="ring-finger-phalanx-distal",A.r4="ring-finger-tip",A.p0="pinky-finger-metacarpal",A.p1="pinky-finger-phalanx-proximal",A.p2="pinky-finger-phalanx-intermediate",A.p3="pinky-finger-phalanx-distal",A.p4="pinky-finger-tip",A))(tI||{});const eI=Object.keys(tI),iI=eI.length,sI={w:0,t0:1,t1:2,t2:3,t3:4,i0:5,i1:6,i2:7,i3:8,i4:9,m0:10,m1:11,m2:12,m3:13,m4:14,r0:15,r1:16,r2:17,r3:18,r4:19,p0:20,p1:21,p2:22,p3:23,p4:24},gI={w:.02,t0:.02,t1:.014,t2:.0115,t3:.0085,i0:.022,i1:.012,i2:.0085,i3:.0075,i4:.0065,m0:.021,m1:.012,m2:.008,m3:.0075,m4:.0065,r0:.019,r1:.011,r2:.0075,r3:.007,r4:.006,p0:.012,p1:.01,p2:.007,p3:.0065,p4:.0055},aI=[["w","t0","t1","t2","t3"],["w","i0","i1","i2","i3","i4"],["w","m0","m1","m2","m3","m4"],["w","r0","r1","r2","r3","r4"],["w","p0","p1","p2","p3","p4"]],II=[[8,10,8,6],[8,19,14,8,6],[8,19,14,8,6],[8,19,14,8,6],[8,19,14,8,6]],rI=["t3","i4","m4","r4","p4"],BI=["i4","m4","r4","p4"];var oI=(A=>(A.left="left",A.right="right",A))(oI||{});const QI=Object.keys(oI);class CI{constructor(){this.hands={},this.last={},this.values={},this.tests={},this.lastTests={},this.updated=!1}update({xr:A,xrFrame:n}){const t=A.getSession();if(!t)return;const i=A.getReferenceSpace();if(i&&n.getJointPose){this.last=this.hands,this.lastTests=this.tests,this.hands={},this.values={},this.tests={};for(const A of t.inputSources){if(!A.hand)continue;const t=A.handedness;this.hands[t]={};for(const s of eI){const g=A.hand.get(tI[s]);if(g){const A=n.getJointPose(g,i);if(A){const{position:n,orientation:i}=A.transform;this.hands[t][s]={position:new e.Vector3(n.x,n.y,n.z),quaternion:new e.Quaternion(i.x,i.y,i.z,i.w),radius:A.radius||.001}}}}}for(const A of QI)for(const{key:n,value:t}of[{key:`${A}AllTips`,value:this.allTipsTouching(A)},{key:`${A}IndexThumb`,value:this.touching(A,"i4",A,"t3")},{key:`${A}MiddleThumb`,value:this.touching(A,"m4",A,"t3")},{key:`${A}RingThumb`,value:this.touching(A,"r4",A,"t3")},{key:`${A}PinkyThumb`,value:this.touching(A,"p4",A,"t3")},{key:`${A}TriTips`,value:this.triTipsTouching(A)}])this.values[n]=t,this.tests[n]=1===t||0!==t&&(this.lastTests[n]??!1)}}makeGhostMesh(){const A=new e.Vector3,n=new e.Vector3(.01,.01,.01),t=new e.Quaternion(0,0,0,1),i=new e.Color(1,1,1),s=3*Math.PI;new e.Color(1,1,1);let g=1;const a=new Rg({onFrame:()=>{let e=0;for(const I of QI){const r=this.hands[I];for(const[B,o]of aI.entries())for(let Q=1;Q<o.length;++Q){const C=2*II[B][Q-1],E=Q+1===o.length,c=null==r?void 0:r[o[Q-1]],l=null==r?void 0:r[o[Q]];for(let r=0;r<C;++r){const B=(r+.5)/C;if(g=0,c&&l){A.copy(c.position).lerp(l.position,B),t.copy(c.quaternion).slerp(l.quaternion,B);let e=(1-B)*gI[o[Q-1]]+B*gI[o[Q]];E&&B>.8&&(e*=Math.sqrt(1-((B-.8)/.2)**2)),n.set(.65*e,.5*e,.003),i.set(.55+.45*Math.sin(A.x*s),.55+.45*Math.sin(A.y*s),.55+.45*Math.sin(A.z*s)),"right"===I&&i.set(1-i.r,1-i.g,1-i.b),g=.75}a.packedSplats.setSplat(e,A,n,t,g,i),e+=1}}}a.packedSplats.numSplats=e,a.packedSplats.needsUpdate=!0,a.numSplats=e,a.updateVersion()}});return a}distance(A,n,t,e,i=!1){const s=i?this.last[A]:this.hands[A],g=i?this.last[t]:this.hands[t],a=null==s?void 0:s[n],I=null==g?void 0:g[e];return a&&I?a.position.distanceTo(I.position):Number.POSITIVE_INFINITY}separation(A,n,t,e,i=!1){const s=this.distance(A,n,t,e,i);return s===Number.POSITIVE_INFINITY?Number.POSITIVE_INFINITY:s-gI[n]-gI[e]}touching(A,n,t,e,i=!1){const s=this.separation(A,n,t,e,i);return s===Number.POSITIVE_INFINITY?Number.POSITIVE_INFINITY:1-Math.max(0,Math.min(1,s/.01-0))}allTipsTouching(A,n=!1){return Math.min(this.touching(A,"t3",A,"i4",n),this.touching(A,"i4",A,"m4",n),this.touching(A,"m4",A,"r4",n),this.touching(A,"r4",A,"p4",n))}triTipsTouching(A,n=!1){return Math.min(this.touching(A,"t3",A,"i4",n),this.touching(A,"i4",A,"m4",n),this.touching(A,"m4",A,"t3",n))}}class EI{constructor({xrHands:A,control:n,moveInertia:t,rotateInertia:i}){this.lastGrip={},this.lastPivot=new e.Vector3,this.rotateVelocity=0,this.velocity=new e.Vector3,this.xrHands=A,this.control=n,this.moveInertia=t??.5,this.rotateInertia=i??.5}update(A){var n,t,i,s,g;const a={};for(const A of QI){const I=this.xrHands.hands[A];I&&this.xrHands.tests[`${A}MiddleThumb`]&&(a[A]=(new e.Vector3).add((null==(n=I.t3)?void 0:n.position)??new e.Vector3).add((null==(t=I.i4)?void 0:t.position)??new e.Vector3).add((null==(i=I.m4)?void 0:i.position)??new e.Vector3).add((null==(s=I.r4)?void 0:s.position)??new e.Vector3).add((null==(g=I.p4)?void 0:g.position)??new e.Vector3).multiplyScalar(.2))}if(a.left&&a.right&&this.lastGrip.left&&this.lastGrip.right){const n=a.left.clone().add(a.right).multiplyScalar(.5),t=this.lastGrip.left.clone().add(this.lastGrip.right).multiplyScalar(.5);this.lastPivot=n;const e=n.clone().applyMatrix4(this.control.matrix);e.sub(t.clone().applyMatrix4(this.control.matrix)),e.multiplyScalar(1/A),this.velocity.lerp(e,1-Math.exp(-20*A));let i=Math.atan2(a.left.z-n.z,a.left.x-n.x)-Math.atan2(this.lastGrip.left.z-t.z,this.lastGrip.left.x-t.x);i>Math.PI?i-=2*Math.PI:i<-Math.PI&&(i+=2*Math.PI);const s=i/A,g=Math.exp(-20*A);this.rotateVelocity=this.rotateVelocity*g+s*(1-g)}else if(this.rotateVelocity*=Math.exp(-A/this.rotateInertia),a.left&&this.lastGrip.left){const n=a.left.clone().applyMatrix4(this.control.matrix);n.sub(this.lastGrip.left.clone().applyMatrix4(this.control.matrix)),n.multiplyScalar(1/A),this.velocity.lerp(n,1-Math.exp(-20*A))}else if(a.right&&this.lastGrip.right){const n=a.right.clone().applyMatrix4(this.control.matrix);n.sub(this.lastGrip.right.clone().applyMatrix4(this.control.matrix)),n.multiplyScalar(1/A),this.velocity.lerp(n,1-Math.exp(-20*A))}else this.velocity.multiplyScalar(Math.exp(-A/this.moveInertia));const I=this.lastPivot.clone().negate(),r=(new e.Matrix4).makeTranslation(I).premultiply((new e.Matrix4).makeRotationY(this.rotateVelocity*A)).premultiply((new e.Matrix4).makeTranslation(this.lastPivot));this.control.matrix.multiply(r),this.control.matrix.decompose(this.control.position,this.control.quaternion,this.control.scale),this.control.updateMatrixWorld(!0),this.control.position.sub(this.velocity.clone().multiplyScalar(A)),this.lastGrip=a}}const cI={KeyW:new e.Vector3(0,0,-1),KeyS:new e.Vector3(0,0,1),KeyA:new e.Vector3(-1,0,0),KeyD:new e.Vector3(1,0,0),KeyR:new e.Vector3(0,1,0),KeyF:new e.Vector3(0,-1,0)},lI={ArrowUp:new e.Vector3(0,0,-1),ArrowDown:new e.Vector3(0,0,1),ArrowLeft:new e.Vector3(-1,0,0),ArrowRight:new e.Vector3(1,0,0),PageUp:new e.Vector3(0,1,0),PageDown:new e.Vector3(0,-1,0)},hI={KeyQ:new e.Vector3(0,0,1),KeyE:new e.Vector3(0,0,-1)},uI={Home:new e.Vector3(0,-1,0),End:new e.Vector3(0,1,0),Insert:new e.Vector3(-1,0,0),Delete:new e.Vector3(1,0,0)};class dI{constructor({canvas:A}){this.lastTime=0,this.fpsMovement=new pI({}),this.pointerControls=new yI({canvas:A})}update(A){const n=performance.now(),t=(n-(this.lastTime||n))/1e3;this.lastTime=n,this.fpsMovement.update(t,A),this.pointerControls.update(t,A)}}class pI{constructor({moveSpeed:A,rollSpeed:n,stickThreshold:t,rotateSpeed:e,keycodeMoveMapping:i,keycodeRotateMapping:s,gamepadMapping:g,capsMultiplier:a,shiftMultiplier:I,ctrlMultiplier:r,xr:B}={}){this.enable=!0,this.moveSpeed=A??1,this.rollSpeed=n??2,this.stickThreshold=t??.1,this.rotateSpeed=e??2,this.keycodeMoveMapping=i??{...cI,...lI},this.keycodeRotateMapping=s??{...hI,...uI},this.gamepadMapping=g??{4:"rollLeft",5:"rollRight",6:"ctrl",7:"shift"},this.capsMultiplier=a??10,this.shiftMultiplier=I??5,this.ctrlMultiplier=r??.2,this.xr=B,this.keydown={},this.keycode={},document.addEventListener("keydown",(A=>{this.keydown[A.key]=!0,this.keycode[A.code]=!0})),document.addEventListener("keyup",(A=>{this.keydown[A.key]=!1,this.keycode[A.code]=!1})),window.addEventListener("blur",(()=>{this.keydown={},this.keycode={}}))}update(A,n){var t,i;if(!this.enable)return;const s=[new e.Vector2,new e.Vector2],g=navigator.getGamepads()[0];g&&(s[0].set(g.axes[0],g.axes[1]),s[1].set(g.axes[2],g.axes[3]));const a=(null==g?void 0:g.buttons.map((A=>A.pressed)))||[],I=Array.from((null==(i=null==(t=this.xr)?void 0:t.getSession())?void 0:i.inputSources)??[]);for(const A of I){const n=A.gamepad;if(n)switch(A.handedness){case"none":s[0].x+=n.axes[0],s[0].y+=n.axes[1],s[1].x+=n.axes[2],s[1].y+=n.axes[3];break;case"left":s[0].x+=n.axes[2],s[0].y+=n.axes[3];break;case"right":s[1].x+=n.axes[2],s[1].y+=n.axes[3]}}for(const A of s)A.x=Math.abs(A.x)>=this.stickThreshold?A.x:0,A.y=Math.abs(A.y)>=this.stickThreshold?A.y:0;const r=new e.Vector3(s[1].x,s[1].y,0).multiplyScalar(this.rotateSpeed);for(const[A,n]of Object.entries(this.keycodeRotateMapping))this.keycode[A]&&r.add(n);for(const A in this.gamepadMapping)if(a[Number.parseInt(A)])switch(this.gamepadMapping[A]){case"rollLeft":r.z+=1;break;case"rollRight":r.z-=1}if(r.multiply(new e.Vector3(this.rotateSpeed,this.rotateSpeed,this.rollSpeed)),r.manhattanLength()>0){r.multiplyScalar(A);const t=(new e.Euler).setFromQuaternion(n.quaternion,"YXZ");t.y-=r.x,t.x=Math.max(-Math.PI/2,Math.min(Math.PI/2,t.x-r.y)),t.z=Math.max(-Math.PI,Math.min(Math.PI,t.z+r.z)),n.quaternion.setFromEuler(t)}const B=new e.Vector3(s[0].x,0,s[0].y);for(const[A,n]of Object.entries(this.keycodeMoveMapping))this.keycode[A]&&B.add(n);let o=1;this.keydown.CapsLock&&(o*=this.capsMultiplier),(this.keycode.ShiftLeft||this.keycode.ShiftRight)&&(o*=this.shiftMultiplier),(this.keycode.ControlLeft||this.keycode.ControlRight)&&(o*=this.ctrlMultiplier);for(const A in this.gamepadMapping)if(a[Number.parseInt(A)])switch(this.gamepadMapping[A]){case"shift":o*=this.shiftMultiplier;break;case"ctrl":o*=this.ctrlMultiplier}B.applyQuaternion(n.quaternion),n.position.add(B.multiplyScalar(this.moveSpeed*o*A))}}class yI{constructor({canvas:A,rotateSpeed:n,slideSpeed:t,scrollSpeed:i,swapRotateSlide:s,reverseRotate:g,reverseSlide:a,reverseSwipe:I,reverseScroll:r,moveInertia:B,rotateInertia:o,pointerRollScale:Q,doublePress:C}){this.enable=!0,this.canvas=A,this.rotateSpeed=n??.002,this.slideSpeed=t??.006,this.scrollSpeed=i??.0015,this.swapRotateSlide=s??!1,this.reverseRotate=g??!1,this.reverseSlide=a??!1,this.reverseSwipe=I??!1,this.reverseScroll=r??!1,this.moveInertia=B??.15,this.rotateInertia=o??.15,this.pointerRollScale=Q??1,this.doublePress=C??(()=>{}),this.doublePressLimitMs=400,this.doublePressDistance=50,this.lastUp=null,this.rotating=null,this.sliding=null,this.dualPress=!1,this.scroll=new e.Vector3,this.rotateVelocity=new e.Vector3,this.moveVelocity=new e.Vector3,A.addEventListener("pointerdown",(n=>{const t=this.getPointerPosition(n),e=t.clone(),i=t.clone(),s=!this.swapRotateSlide&&!this.rotating&&("mouse"!==n.pointerType||0===n.button)||this.swapRotateSlide&&this.sliding&&!this.rotating&&("mouse"!==n.pointerType||1===n.button),{pointerId:g,timeStamp:a}=n;if(s)this.rotating={initial:e,last:i,position:t,pointerId:g,timeStamp:a},A.setPointerCapture(n.pointerId),this.dualPress=!1;else if(!this.sliding){const s="mouse"===n.pointerType?n.button:void 0;this.sliding={initial:e,last:i,position:t,pointerId:g,button:s,timeStamp:a},A.setPointerCapture(n.pointerId),this.dualPress=null!=this.rotating&&a-this.rotating.timeStamp<200}}));const E=n=>{var t,e;(null==(t=this.rotating)?void 0:t.pointerId)===n.pointerId?(this.rotating=null,A.releasePointerCapture(n.pointerId),this.dualPress&&this.sliding&&(A.releasePointerCapture(this.sliding.pointerId),this.sliding=null)):(null==(e=this.sliding)?void 0:e.pointerId)===n.pointerId&&(this.sliding=null,A.releasePointerCapture(n.pointerId),this.dualPress&&this.rotating&&(A.releasePointerCapture(this.rotating.pointerId),this.rotating=null));const i=this.getPointerPosition(n),s=this.lastUp;if(this.lastUp={position:i,time:n.timeStamp},s){if(s.position.distanceTo(i)<this.doublePressDistance){const A=n.timeStamp-s.time;A<this.doublePressLimitMs&&(this.lastUp=null,this.doublePress({position:i,intervalMs:A}))}}};document.addEventListener("pointerup",E),document.addEventListener("pointercancel",E),document.addEventListener("pointermove",(A=>{var n,t;(null==(n=this.rotating)?void 0:n.pointerId)===A.pointerId?this.rotating.position=this.getPointerPosition(A):(null==(t=this.sliding)?void 0:t.pointerId)===A.pointerId&&(this.sliding.position=this.getPointerPosition(A))})),A.addEventListener("contextmenu",(A=>{A.preventDefault()})),A.addEventListener("wheel",(A=>{this.scroll.add(new e.Vector3(A.deltaX,A.deltaY,A.deltaZ)),A.preventDefault()}))}getPointerPosition(A){const n=this.canvas.getBoundingClientRect();return new e.Vector2(A.clientX-n.left,A.clientY-n.top)}update(A,n){if(!this.enable)return;if(this.dualPress&&this.rotating&&this.sliding){const t=[this.rotating.position.clone().sub(this.rotating.last),this.sliding.position.clone().sub(this.sliding.last)],i=t[0].dot(t[1]);if(i>=.2){const i=t[0].clone().add(t[1]),s=new e.Vector3(i.x,-i.y,0);s.multiplyScalar(this.slideSpeed*(this.reverseSwipe?1:-1)),s.applyQuaternion(n.quaternion),n.position.add(s),this.moveVelocity=s.clone().multiplyScalar(1/A)}else if(i<=-.2){const i=this.sliding.last.clone().sub(this.rotating.last),s=i.length();i.multiplyScalar(1/s).normalize();const g=new e.Vector2(-i.y,i.x),a=[t[0].dot(i),t[1].dot(i)],I=[t[0].dot(g),t[1].dot(g)],r=this.rotating.last.clone().add(this.sliding.last).multiplyScalar(.5);let B=new e.Vector3;if(n instanceof e.Camera){const A=new e.Vector2(r.x/this.canvas.clientWidth*2-1,-r.y/this.canvas.clientHeight*2+1),t=new e.Raycaster;t.setFromCamera(A,n),B=t.ray.direction}const o=a[1]-a[0],Q=B.multiplyScalar(o*this.slideSpeed);n.position.add(Q),this.moveVelocity=Q.clone().multiplyScalar(1/A);const C=[Math.atan(I[0]/(-.5*s)),Math.atan(I[1]/(.5*s))],E=.5*(C[0]+C[1])*this.pointerRollScale,c=(new e.Euler).setFromQuaternion(n.quaternion,"YXZ");c.z=Math.max(-Math.PI,Math.min(Math.PI,c.z+.5*E)),n.quaternion.setFromEuler(c)}this.rotating.last.copy(this.rotating.position),this.sliding.last.copy(this.sliding.position)}else{const t=new e.Vector3;if(this.rotating&&!this.dualPress){const n=this.rotating.position.clone().sub(this.rotating.last);this.rotating.last.copy(this.rotating.position),t.set(n.x,n.y,0),t.multiplyScalar(this.rotateSpeed*(this.reverseRotate?-1:1)),this.rotateVelocity=t.clone().multiplyScalar(1/A)}else this.rotateVelocity.multiplyScalar(Math.exp(-A/this.rotateInertia)),t.addScaledVector(this.rotateVelocity,A);const i=(new e.Euler).setFromQuaternion(n.quaternion,"YXZ");if(i.y-=t.x,i.x=Math.max(-Math.PI/2,Math.min(Math.PI/2,i.x-t.y)),i.z*=Math.exp(-0*A),n.quaternion.setFromEuler(i),this.sliding&&!this.dualPress){const t=this.sliding.position.clone().sub(this.sliding.last);this.sliding.last.copy(this.sliding.position);const i=2!==this.sliding.button?new e.Vector3(t.x,0,t.y):new e.Vector3(t.x,-t.y,0);i.multiplyScalar(this.slideSpeed*(this.reverseSlide?-1:1)),i.applyQuaternion(n.quaternion),n.position.add(i),this.moveVelocity=i.clone().multiplyScalar(1/A)}else this.moveVelocity.multiplyScalar(Math.exp(-A/this.moveInertia)),n.position.addScaledVector(this.moveVelocity,A)}const t=this.scroll.multiplyScalar(this.scrollSpeed);t.set(t.x,t.z,t.y),this.reverseScroll&&t.multiplyScalar(-1),t.applyQuaternion(n.quaternion),n.position.add(t),this.scroll.set(0,0,0)}}}}]);